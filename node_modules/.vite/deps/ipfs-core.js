var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod4) => function __require2() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all12) => {
  for (var name22 in all12)
    __defProp(target, name22, { get: all12[name22], enumerable: true });
};
var __copyProps = (to, from33, except, desc) => {
  if (from33 && typeof from33 === "object" || typeof from33 === "function") {
    for (let key of __getOwnPropNames(from33))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from33[key], enumerable: !(desc = __getOwnPropDesc(from33, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));
var __toCommonJS = (mod4) => __copyProps(__defProp({}, "__esModule", { value: true }), mod4);
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value2) => {
      if (Object.prototype.toString.call(value2) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value2);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name22, value2) => Object.defineProperty(object, name22, {
      value: value2,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value2) => {
      const keys = [];
      for (const key in value2) {
        if (hasOwnProperty.call(value2, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value2);
        for (const symbol7 of symbols) {
          if (propertyIsEnumerable.call(value2, symbol7)) {
            keys.push(symbol7);
          }
        }
      }
      return keys;
    };
    function clone(value2) {
      if (Array.isArray(value2)) {
        return cloneArray(value2);
      }
      if (isOptionObject(value2)) {
        return cloneOptionObject(value2);
      }
      return value2;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config2) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge11(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge11(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge11(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge11(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron2;
  }
});

// node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    "use strict";
    var isElectron2 = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron2();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name22) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name22 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce19;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace3) {
        let hash3 = 0;
        for (let i2 = 0; i2 < namespace3.length; i2++) {
          hash3 = (hash3 << 5) - hash3 + namespace3.charCodeAt(i2);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace3) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug13(...args) {
          if (!debug13.enabled) {
            return;
          }
          const self2 = debug13;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format16) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format16];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug13.namespace = namespace3;
        debug13.useColors = createDebug.useColors();
        debug13.color = createDebug.selectColor(namespace3);
        debug13.extend = extend;
        debug13.destroy = createDebug.destroy;
        Object.defineProperty(debug13, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace3);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug13);
        }
        return debug13;
      }
      function extend(namespace3, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace3);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace3) => "-" + namespace3)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name22) {
        if (name22[name22.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name22)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name22)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce19(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign2(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err2, code22, props) {
      if (!err2 || typeof err2 === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code22 === "object") {
        props = code22;
        code22 = "";
      }
      if (code22) {
        props.code = code22;
      }
      try {
        return assign2(err2, props);
      } catch (_) {
        props.message = err2.message;
        props.stack = err2.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err2));
        const output = assign2(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve7, reject) {
        params[offset] = function callback(err2) {
          if (pending) {
            pending = false;
            if (err2)
              reject(err2);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve7.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err2) {
          if (pending) {
            pending = false;
            reject(err2);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base6416 = exports2;
    base6416.length = function length23(string14) {
      var p = string14.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string14.charAt(p) === "=")
        ++n;
      return Math.ceil(string14.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base6416.encode = function encode81(buffer2, start, end) {
      var parts2 = null, chunk = [];
      var i3 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i3++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i3++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i3++] = b64[t | b >> 6];
            chunk[i3++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i3 > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j) {
        chunk[i3++] = b64[t];
        chunk[i3++] = 61;
        if (j === 1)
          chunk[i3++] = 61;
      }
      if (parts2) {
        if (i3)
          parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base6416.decode = function decode97(string14, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i3 = 0; i3 < string14.length; ) {
        var c = string14.charCodeAt(i3++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base6416.test = function test(string14) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string14);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter6;
    function EventEmitter6() {
      this._listeners = {};
    }
    EventEmitter6.prototype.on = function on2(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter6.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter6.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign5 = val < 0 ? 1 : 0;
            if (sign5)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign5 << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign5 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign5 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign5 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign5 * Infinity : exponent === 0 ? sign5 * 1401298464324817e-60 * mantissa : sign5 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign5 = val < 0 ? 1 : 0;
            if (sign5)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign5 << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign5 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign5 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign5 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign5 * Infinity : exponent === 0 ? sign5 * 5e-324 * mantissa : sign5 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string14) {
      var len = 0, c = 0;
      for (var i2 = 0; i2 < string14.length; ++i2) {
        c = string14.charCodeAt(i2);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string14.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts2 = null, chunk = [], i2 = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i2++] = t;
        else if (t > 191 && t < 224)
          chunk[i2++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t >> 10);
          chunk[i2++] = 56320 + (t & 1023);
        } else
          chunk[i2++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i2 > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts2) {
        if (i2)
          parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string14, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i2 = 0; i2 < string14.length; ++i2) {
        c1 = string14.charCodeAt(i2);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string14.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc3, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits2;
    var util5 = require_minimal();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero2 = LongBits2.zero = new LongBits2(0, 0);
    zero2.toNumber = function() {
      return 0;
    };
    zero2.zzEncode = zero2.zzDecode = function() {
      return this;
    };
    zero2.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value2) {
      if (value2 === 0)
        return zero2;
      var sign5 = value2 < 0;
      if (sign5)
        value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign5) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from33(value2) {
      if (typeof value2 === "number")
        return LongBits2.fromNumber(value2);
      if (util5.isString(value2)) {
        if (util5.Long)
          value2 = util5.Long.fromString(value2);
        else
          return LongBits2.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util5.Long ? new util5.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero2;
      return new LongBits2(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length23() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util5 = exports2;
    util5.asPromise = require_aspromise();
    util5.base64 = require_base64();
    util5.EventEmitter = require_eventemitter();
    util5.float = require_float();
    util5.inquire = require_inquire();
    util5.utf8 = require_utf8();
    util5.pool = require_pool();
    util5.LongBits = require_longbits();
    util5.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util5.global = util5.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util5.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util5.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util5.isInteger = Number.isInteger || function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util5.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util5.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util5.isset = util5.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util5.Buffer = function() {
      try {
        var Buffer2 = util5.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util5._Buffer_from = null;
    util5._Buffer_allocUnsafe = null;
    util5.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util5.Buffer ? util5._Buffer_allocUnsafe(sizeOrArray) : new util5.Array(sizeOrArray) : util5.Buffer ? util5._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util5.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util5.Long = util5.global.dcodeIO && util5.global.dcodeIO.Long || util5.global.Long || util5.inquire("long");
    util5.key2Re = /^true|false|0|1$/;
    util5.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util5.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util5.longToHash = function longToHash(value2) {
      return value2 ? util5.LongBits.from(value2).toHash() : util5.LongBits.zeroHash;
    };
    util5.longFromHash = function longFromHash(hash3, unsigned2) {
      var bits2 = util5.LongBits.fromHash(hash3);
      if (util5.Long)
        return util5.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge11(dst, src18, ifNotSet) {
      for (var keys = Object.keys(src18), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src18[keys[i2]];
      return dst;
    }
    util5.merge = merge11;
    util5.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name22) {
      function CustomError(message6, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message6, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message6;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge11(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get3() {
            return name22;
          },
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value: function value2() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util5.newError = newError;
    util5.ProtocolError = newError("ProtocolError");
    util5.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util5.oneOfSetter = function setOneOf(fieldNames) {
      return function(name22) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name22)
            delete this[fieldNames[i2]];
      };
    };
    util5.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util5._configure = function() {
      var Buffer2 = util5.Buffer;
      if (!Buffer2) {
        util5._Buffer_from = util5._Buffer_allocUnsafe = null;
        return;
      }
      util5._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      };
      util5._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util5 = require_minimal();
    var BufferWriter;
    var LongBits2 = util5.LongBits;
    var base6416 = util5.base64;
    var utf8 = util5.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop5() {
    }
    function State(writer5) {
      this.head = writer5.head;
      this.tail = writer5.tail;
      this.len = writer5.len;
      this.next = writer5.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop5, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create26 = function create27() {
      return util5.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create26();
    Writer2.alloc = function alloc3(size) {
      return new util5.Array(size);
    };
    if (util5.Array !== Array)
      Writer2.alloc = util5.pool(Writer2.alloc, util5.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
        value2
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value2)) : this.uint32(value2);
    };
    Writer2.prototype.sint32 = function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value2) {
      var bits2 = LongBits2.from(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer2.prototype.bool = function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value2) {
      return this._push(util5.float.writeFloatLE, 4, value2);
    };
    Writer2.prototype.double = function write_double(value2) {
      return this._push(util5.float.writeDoubleLE, 8, value2);
    };
    var writeBytes = util5.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer2.prototype.bytes = function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util5.isString(value2)) {
        var buf2 = Writer2.alloc(len = base6416.length(value2));
        base6416.decode(value2, buf2, 0);
        value2 = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    };
    Writer2.prototype.string = function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop5, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop5, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create26();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util5 = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util5._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util5.Buffer && util5.Buffer.prototype instanceof Uint8Array && util5.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
      if (util5.isString(value2))
        value2 = util5._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value2);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util5.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value2) {
      var len = util5.Buffer.byteLength(value2);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value2);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util5 = require_minimal();
    var BufferReader;
    var LongBits2 = util5.LongBits;
    var utf8 = util5.utf8;
    function indexOutOfRange(reader6, writeLength) {
      return RangeError("index out of range: " + reader6.pos + " + " + (writeLength || 1) + " > " + reader6.len);
    }
    function Reader2(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader2(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader2(buffer2);
      throw Error("illegal buffer");
    };
    var create26 = function create27() {
      return util5.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader2.create = function create_buffer(buffer3) {
          return util5.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader2.create = create26();
    Reader2.prototype._slice = util5.Array.prototype.subarray || util5.Array.prototype.slice;
    Reader2.prototype.uint32 = function read_uint32_setup() {
      var value2 = 4294967295;
      return function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      };
    }();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    };
    function readLongVarint() {
      var bits2 = new LongBits2(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits2;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util5.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util5.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length23 = this.uint32(), start = this.pos, end = this.pos + length23;
      if (end > this.len)
        throw indexOutOfRange(this, length23);
      this.pos += length23;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader2.prototype.skip = function skip(length23) {
      if (typeof length23 === "number") {
        if (this.pos + length23 > this.len)
          throw indexOutOfRange(this, length23);
        this.pos += length23;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create26();
      BufferReader._configure();
      var fn = util5.Long ? "toLong" : "toNumber";
      util5.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util5 = require_minimal();
    function BufferReader(buffer2) {
      Reader2.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util5.Buffer)
        BufferReader.prototype._slice = util5.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service2;
    var util5 = require_minimal();
    (Service2.prototype = Object.create(util5.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util5.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util5.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err2, response) {
            if (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err3) {
                self2.emit("error", err3, method);
                return callback(err3);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err2) {
        self2.emit("error", err2, method);
        setTimeout(function() {
          callback(err2);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure6;
    function configure6() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure6();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
var init_as_uint8array = __esm({
  "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
  }
});

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
  }
});

// node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "node_modules/retimer/time-browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function getTime() {
      return Date.now();
    };
  }
});

// node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "node_modules/retimer/retimer.js"(exports2, module2) {
    "use strict";
    var getTime = require_time_browser();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer4() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2 + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module2.exports = retimer4;
  }
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
    "use strict";
    var { AbortController: AbortController2 } = globalThis;
    var retimer4 = require_retimer();
    var TimeoutController20 = class extends AbortController2 {
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer4(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController20.prototype);
      }
      abort() {
        this._timer.clear();
        return super.abort();
      }
      clear() {
        this._timer.clear();
      }
      reset() {
        this._timer.clear();
        this._timer = retimer4(() => this.abort(), this._ms);
      }
    };
    module2.exports = {
      TimeoutController: TimeoutController20
    };
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode81;
    var MSB19 = 128;
    var REST19 = 127;
    var MSBALL18 = ~REST19;
    var INT18 = Math.pow(2, 31);
    function encode81(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode81.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT18) {
        out[offset++] = num & 255 | MSB19;
        num /= 128;
      }
      while (num & MSBALL18) {
        out[offset++] = num & 255 | MSB19;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode81.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read19;
    var MSB19 = 128;
    var REST19 = 127;
    function read19(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read19.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST19) << shift : (b & REST19) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB19);
      read19.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N119 = Math.pow(2, 7);
    var N219 = Math.pow(2, 14);
    var N319 = Math.pow(2, 21);
    var N419 = Math.pow(2, 28);
    var N519 = Math.pow(2, 35);
    var N619 = Math.pow(2, 42);
    var N719 = Math.pow(2, 49);
    var N819 = Math.pow(2, 56);
    var N919 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N119 ? 1 : value2 < N219 ? 2 : value2 < N319 ? 3 : value2 < N419 ? 4 : value2 < N519 ? 5 : value2 < N619 ? 6 : value2 < N719 ? 7 : value2 < N819 ? 8 : value2 < N919 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    "use strict";
    var isReactNative3 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative3) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL3 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url2 = "", base30 = defaultBase) {
        this.super = new URL3(url2, base30);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash3) {
        this.super.hash = hash3;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol4) {
        this.super.protocol = protocol4;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      static createObjectURL(o) {
        return URL3.createObjectURL(o);
      }
      static revokeObjectURL(o) {
        URL3.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format16(obj) {
      if (typeof obj === "string") {
        const url2 = new URL3(obj);
        return url2.toString();
      }
      if (!(obj instanceof URL3)) {
        const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol4 = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash3 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path2 = obj.path || pathname + search;
        return `${protocol4}${userPass || auth}${host || hostname + port}${path2}${hash3}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format: format16
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports2, module2) {
    "use strict";
    var { URLWithLegacySupport, format: format16 } = require_url_browser();
    module2.exports = (url2, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol4 = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol4 = (protocolMap[protocol4] || defaultProtocol || protocol4) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url2);
      } catch (err2) {
        urlParsed = {};
      }
      const base30 = Object.assign({}, location2, {
        protocol: protocol4 || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url2, format16(base30)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports2, module2) {
    "use strict";
    var {
      URLWithLegacySupport,
      format: format16,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative2 = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format16,
      relative: relative2,
      defaultBase
    };
  }
});

// node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "node_modules/any-signal/index.js"(exports2, module2) {
    function anySignal14(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener)
            continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener)
          continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal14;
    module2.exports.anySignal = anySignal14;
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache19 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value2) {
        cache19[key] = value2;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache19;
          cache19 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache19[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache19[key] !== void 0)
            cache19[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache19[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value2) {
          if (cache19[key] !== void 0)
            cache19[key] = value2;
          else
            update(key, value2);
        },
        clear: function() {
          cache19 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names3 = [], events2, name22;
      if (this._eventsCount === 0)
        return names3;
      for (name22 in events2 = this._events) {
        if (has.call(events2, name22))
          names3.push(prefix ? name22.slice(1) : name22);
      }
      if (Object.getOwnPropertySymbols) {
        return names3.concat(Object.getOwnPropertySymbols(events2));
      }
      return names3;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length23 = listeners.length, j;
        for (i2 = 0; i2 < length23; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events2 = [], length23 = listeners.length; i2 < length23; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events2.push(listeners[i2]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter6;
    }
  }
});

// node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "node_modules/ipfs-utils/src/http/error.js"(exports2) {
    "use strict";
    var TimeoutError5 = class extends Error {
      constructor(message6 = "Request timed out") {
        super(message6);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError5;
    var AbortError7 = class extends Error {
      constructor(message6 = "The operation was aborted.") {
        super(message6);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError7;
    var HTTPError2 = class extends Error {
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});

// node_modules/node-fetch/browser.js
var require_browser2 = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalObject);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  }
});

// node_modules/ipfs-utils/node_modules/native-fetch/src/index.js
var require_src = __commonJS({
  "node_modules/ipfs-utils/node_modules/native-fetch/src/index.js"(exports2, module2) {
    "use strict";
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser2().default,
        Headers: require_browser2().Headers,
        Request: require_browser2().Request,
        Response: require_browser2().Response
      };
    }
  }
});

// node_modules/ipfs-utils/src/fetch.browser.js
var require_fetch_browser = __commonJS({
  "node_modules/ipfs-utils/src/fetch.browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src();
  }
});

// node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser2 = __commonJS({
  "node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    "use strict";
    var { TimeoutError: TimeoutError5, AbortError: AbortError7 } = require_error();
    var { Response: Response2, Request: Request2, Headers, default: fetch } = require_fetch_browser();
    var fetchWithProgress = (url2, options = {}) => {
      const request2 = new XMLHttpRequest();
      request2.open(options.method || "GET", url2.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request2.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request2.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name22, value2] of new Headers(headers)) {
          request2.setRequestHeader(name22, value2);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request2.abort();
      }
      if (options.onUploadProgress) {
        request2.upload.onprogress = options.onUploadProgress;
      }
      request2.responseType = "arraybuffer";
      return new Promise((resolve7, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve7(Response2.error());
              break;
            }
            case "load": {
              resolve7(
                new ResponseWithURL(request2.responseURL, request2.response, {
                  status: request2.status,
                  statusText: request2.statusText,
                  headers: parseHeaders(request2.getAllResponseHeaders())
                })
              );
              break;
            }
            case "timeout": {
              reject(new TimeoutError5());
              break;
            }
            case "abort": {
              reject(new AbortError7());
              break;
            }
            default: {
              break;
            }
          }
        };
        request2.onerror = handleEvent;
        request2.onload = handleEvent;
        request2.ontimeout = handleEvent;
        request2.onabort = handleEvent;
        request2.send(options.body);
      });
    };
    var fetchWithStreaming = fetch;
    var fetchWith = (url2, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url2, options) : fetchWithStreaming(url2, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      constructor(url2, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url2 });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request: Request2,
      Headers
    };
  }
});

// node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    async function* browserReadableStreamToIt(stream, options = {}) {
      const reader6 = stream.getReader();
      try {
        while (true) {
          const result = await reader6.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader6.cancel();
        }
        reader6.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all12 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all12;
  }
});

// node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    "use strict";
    var { fetch, Request: Request2, Headers } = require_fetch_browser2();
    var { TimeoutError: TimeoutError5, HTTPError: HTTPError2 } = require_error();
    var merge11 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL3, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal14 = require_any_signal();
    var browserReableStreamToIt = require_browser_readablestream_to_it();
    var { isBrowser: isBrowser4, isWebWorker: isWebWorker3 } = require_env();
    var all12 = require_it_all();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve7, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError5());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError5());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve7), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP6 = class {
      constructor(options = {}) {
        this.opts = merge11(defaults, options);
      }
      async fetch(resource, options = {}) {
        const opts = merge11(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL3 || resource instanceof Request2)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url2 = new URL3(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url2.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url2.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal14([abortController.signal, opts.signal]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser4 || isWebWorker3)) {
          opts.body = new Blob(await all12(browserReableStreamToIt(opts.body)));
        }
        const response = await timeout(
          fetch(
            url2.toString(),
            {
              ...opts,
              signal,
              timeout: void 0,
              headers,
              duplex: "half"
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i2 = 0; i2 < lines.length - 1; i2++) {
          const l = lines[i2].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isAsyncIterable2(source)) {
        return source;
      }
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value2) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value: value2 });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader6 = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value: value2 } = await reader6.read();
              if (done)
                return;
              if (value2) {
                yield value2;
              }
            }
          } finally {
            reader6.releaseLock();
          }
        }();
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value2) => {
      return typeof value2 === "object" && value2 !== null && typeof value2[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value2) => {
      return value2 && typeof value2.getReader === "function";
    };
    var isNodeReadableStream = (value2) => Object.prototype.hasOwnProperty.call(value2, "readable") && Object.prototype.hasOwnProperty.call(value2, "writable");
    HTTP6.HTTPError = HTTPError2;
    HTTP6.TimeoutError = TimeoutError5;
    HTTP6.streamToAsyncIterator = fromStream;
    HTTP6.post = (resource, options) => new HTTP6(options).post(resource, options);
    HTTP6.get = (resource, options) => new HTTP6(options).get(resource, options);
    HTTP6.put = (resource, options) => new HTTP6(options).put(resource, options);
    HTTP6.delete = (resource, options) => new HTTP6(options).delete(resource, options);
    HTTP6.options = (resource, options) => new HTTP6(options).options(resource, options);
    module2.exports = HTTP6;
  }
});

// node_modules/it-last/index.js
var require_it_last = __commonJS({
  "node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    var last14 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last14;
  }
});

// node_modules/timestamp-nano/dist/timestamp.min.js
var require_timestamp_min = __commonJS({
  "node_modules/timestamp-nano/dist/timestamp.min.js"(exports2, module2) {
    var Timestamp = function() {
      "undefined" != typeof module2 && (module2.exports = d);
      var l = 86400, s = 3200, T = 146097 * s / 400, e = l * T, f = 1e3 * e, c = 864e13, g = 4294967296, h = 1e6, u = "000000000", m = Math.trunc || function(n2) {
        var t2 = n2 - n2 % 1;
        return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
      }, n = d.prototype, o = (d.fromDate = function(n2) {
        return new d(+n2);
      }, d.fromInt64BE = r(0, 1, 2, 3, 0, 4), d.fromInt64LE = r(3, 2, 1, 0, 4, 0), d.fromString = function(n2) {
        var e2, r2 = new d(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
          var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
          return r2.year = n3 - t2, t2;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
          return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
        }).replace(/\.\d+$/, function(n3) {
          return r2.nano = +(n3 + u).substr(1, 9), "";
        }).split(/\D+/);
        1 < n2.length ? n2[1]-- : n2[1] = 0;
        if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2))
          throw new TypeError("Invalid Date");
        return p(r2);
      }, d.fromTimeT = function(n2) {
        return y(n2, 0);
      }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
        return this.nano += +n2 || 0, this;
      }, n.getNano = function() {
        var n2 = p(this);
        return (n2.time % 1e3 * h + +n2.nano + 1e9) % 1e9;
      }, n.getTimeT = function() {
        var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
        n2 && (t2 += n2 * T * l / s);
        return t2;
      }, n.getYear = function() {
        return this.toDate().getUTCFullYear() + this.year;
      }, n.toDate = function() {
        return M(p(this).time);
      }, n.toJSON = function() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }, n.toString = function(n2) {
        var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
          return C(r2.getUTCHours());
        }, L: function() {
          return D(r2.getUTCMilliseconds(), 3);
        }, M: function() {
          return C(r2.getUTCMinutes());
        }, N: function() {
          return D(t2.getNano(), 9);
        }, S: function() {
          return C(r2.getUTCSeconds());
        }, Y: function() {
          var n3 = t2.getYear();
          return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
        }, a: function() {
          return a[r2.getUTCDay()];
        }, b: function() {
          return i2[r2.getUTCMonth()];
        }, d: function() {
          return C(r2.getUTCDate());
        }, e: function() {
          return function(n3) {
            return (9 < n3 ? "" : " ") + (0 | n3);
          }(r2.getUTCDate());
        }, m: function() {
          return C(r2.getUTCMonth() + 1);
        } };
        return function e2(n3) {
          return n3.replace(/%./g, function(n4) {
            var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
            return r3 ? e2(r3) : t3 ? t3() : n4;
          });
        }(n2 || o);
      }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
      return d;
      function d(n2, t2, r2) {
        var e2 = this;
        if (!(e2 instanceof d))
          return new d(n2, t2, r2);
        e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
      }
      function p(n2) {
        var t2, r2, e2, u2 = n2.year, o2 = n2.time, i3 = n2.nano, a2 = ((i3 < 0 || h <= i3) && (i3 -= (r2 = Math.floor(i3 / h)) * h, o2 += r2, r2 = 1), u2 % s);
        return (o2 < -c || c < o2 || a2) && ((t2 = m(o2 / f)) && (u2 += t2 * s, o2 -= t2 * f), (e2 = M(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m((u2 -= a2) / s)) * f, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i3), n2;
      }
      function M(n2) {
        var t2 = new Date(0);
        return t2.setTime(n2), t2;
      }
      function y(n2, t2) {
        n2 = +n2 || 0;
        var r2 = m((t2 = (t2 | 0) * g) / e) + m(n2 / e), t2 = t2 % e + n2 % e, n2 = m(t2 / e);
        return n2 && (r2 += n2, t2 -= n2 * e), new d(1e3 * t2, 0, r2 * s);
      }
      function t(e2, u2, o2, i3, a2, f2) {
        return function(n2, t2) {
          var r2 = p(this);
          n2 = n2 || new Array(8);
          w(n2, t2 |= 0);
          var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s), u3 = m(r2 / g) + m(e3 / g), r2 = r2 % g + e3 % g, e3 = Math.floor(r2 / g);
          e3 && (u3 += e3, r2 -= e3 * g);
          return c2(n2, t2 + a2, u3), c2(n2, t2 + f2, r2), n2;
        };
        function c2(n2, t2, r2) {
          n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i3] = 255 & r2;
        }
      }
      function r(r2, e2, u2, o2, i3, a2) {
        return function(n2, t2) {
          w(n2, t2 |= 0);
          var r3 = f2(n2, t2 + i3);
          return y(f2(n2, t2 + a2), r3);
        };
        function f2(n2, t2) {
          return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
        }
      }
      function w(n2, t2) {
        n2 = n2 && n2.length;
        if (null == n2)
          throw new TypeError("Invalid Buffer");
        if (n2 < t2 + 8)
          throw new RangeError("Out of range");
      }
      function C(n2) {
        return (9 < n2 ? "" : "0") + (0 | n2);
      }
      function D(n2, t2) {
        return (u + (0 | n2)).substr(-t2);
      }
    }();
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet16, maxline) {
      if (typeof alphabet16 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet16);
      } else {
        var i2 = 0;
        var base30 = alphabet16.length;
        var first10 = alphabet16.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j = 0, carry = input[i2]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base30;
            carry = carry / base30 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base30);
            carry = carry / base30 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first10;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet16[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet16) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet16 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table2 = _reverseAlphabets[alphabet16];
      if (!table2) {
        table2 = _reverseAlphabets[alphabet16] = [];
        for (var i2 = 0; i2 < alphabet16.length; ++i2) {
          table2[alphabet16.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base30 = alphabet16.length;
      var first10 = alphabet16.charAt(0);
      var bytes2 = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value2 = table2[input.charCodeAt(i2)];
        if (value2 === void 0) {
          return;
        }
        for (var j = 0, carry = value2; j < bytes2.length; ++j) {
          carry += bytes2[j] * base30;
          bytes2[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes2.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first10 && k < input.length - 1; ++k) {
        bytes2.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes2.reverse());
      }
      return new Uint8Array(bytes2.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet16) {
      var i2 = 0;
      var base30 = alphabet16.length;
      var first10 = alphabet16.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j = 0, carry = input.at(i2); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base30;
          carry = carry / base30 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base30);
          carry = carry / base30 | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first10;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet16[digits[i2]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge9 = require_forge();
    var baseN = require_baseN();
    var util5 = module2.exports = forge9.util = forge9.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util5.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util5.setImmediate = setImmediate;
        } else {
          util5.setImmediate = util5.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util5.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util5.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util5.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util5.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util5.setImmediate;
        util5.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util5.nextTick = util5.setImmediate;
    })();
    util5.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util5.globalScope = function() {
      if (util5.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util5.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util5.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util5.isArrayBufferView = function(x) {
      return x && util5.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util5.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util5.isArrayBuffer(b) || util5.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util5.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util5.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util5.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util5.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util5.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util5.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util5.ByteStringBuffer.prototype.putBytes = function(bytes2) {
      this.data += bytes2;
      this._optimizeConstructedString(bytes2.length);
      return this;
    };
    util5.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util5.encodeUtf8(str));
    };
    util5.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util5.ByteStringBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      var bytes2 = "";
      do {
        n -= 8;
        bytes2 += String.fromCharCode(i2 >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes2);
    };
    util5.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util5.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
      return this.putBytes(buffer2.getBytes());
    };
    util5.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util5.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util5.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util5.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util5.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util5.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util5.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util5.ByteStringBuffer.prototype.setAt = function(i2, b) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util5.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util5.ByteStringBuffer.prototype.copy = function() {
      var c = util5.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util5.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util5.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util5.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util5.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b = this.data.charCodeAt(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util5.ByteStringBuffer.prototype.toString = function() {
      return util5.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer2 = util5.isArrayBuffer(b);
      var isArrayBufferView = util5.isArrayBufferView(b);
      if (isArrayBuffer2 || isArrayBufferView) {
        if (isArrayBuffer2) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util5.DataBuffer = DataBuffer;
    util5.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util5.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util5.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src18 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src18);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util5.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util5.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i2 = 0; i2 < n; ++i2) {
        this.data.setUint8(b);
      }
      return this;
    };
    util5.DataBuffer.prototype.putBytes = function(bytes2, encoding) {
      if (util5.isArrayBufferView(bytes2)) {
        var src18 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
        var len = src18.byteLength - src18.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src18);
        this.write += len;
        return this;
      }
      if (util5.isArrayBuffer(bytes2)) {
        var src18 = new Uint8Array(bytes2);
        this.accommodate(src18.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src18, this.write);
        this.write += src18.byteLength;
        return this;
      }
      if (bytes2 instanceof util5.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util5.isArrayBufferView(bytes2.data)) {
        var src18 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
        this.accommodate(src18.byteLength);
        var dst = new Uint8Array(bytes2.data.byteLength, this.write);
        dst.set(src18);
        this.write += src18.byteLength;
        return this;
      }
      if (bytes2 instanceof util5.ByteStringBuffer) {
        bytes2 = bytes2.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes2 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes2.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util5.binary.hex.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes2.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util5.binary.base64.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes2 = util5.encodeUtf8(bytes2);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes2.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util5.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes2.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util5.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes2);
    };
    util5.DataBuffer.prototype.putBuffer = function(buffer2) {
      this.putBytes(buffer2);
      buffer2.clear();
      return this;
    };
    util5.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util5.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util5.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util5.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util5.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util5.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util5.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util5.DataBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i2 >> n & 255);
      } while (n > 0);
      return this;
    };
    util5.DataBuffer.prototype.putSignedInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util5.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util5.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util5.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util5.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util5.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util5.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util5.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util5.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util5.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util5.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util5.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util5.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util5.DataBuffer.prototype.setAt = function(i2, b) {
      this.data.setUint8(i2, b);
      return this;
    };
    util5.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util5.DataBuffer.prototype.copy = function() {
      return new util5.DataBuffer(this);
    };
    util5.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src18 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src18.byteLength);
        dst.set(src18);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util5.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util5.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util5.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b = this.data.getUint8(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util5.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util5.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util5.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util5.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util5.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util5.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util5.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util5.encodeUtf8(input);
      }
      return new util5.ByteBuffer(input);
    };
    util5.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util5.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i2 = 0;
      var c = 0;
      for (; n > 0; --n, ++i2) {
        b = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util5.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util5.bytesToHex = function(bytes2) {
      return util5.createBuffer(bytes2).toHex();
    };
    util5.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util5.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util5.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util5.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util5.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util5.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util5.binary.raw.encode = function(bytes2) {
      return String.fromCharCode.apply(null, bytes2);
    };
    util5.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output ? j - offset : out;
    };
    util5.binary.hex.encode = util5.bytesToHex;
    util5.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j = offset;
      if (hex.length & 1) {
        i2 = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j - offset : out;
    };
    util5.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util5.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util5.binary.base58.encode = function(input, maxline) {
      return util5.binary.baseN.encode(input, _base58, maxline);
    };
    util5.binary.base58.decode = function(input, maxline) {
      return util5.binary.baseN.decode(input, _base58, maxline);
    };
    util5.text = {
      utf8: {},
      utf16: {}
    };
    util5.text.utf8.encode = function(str, output, offset) {
      str = util5.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output ? j - offset : out;
    };
    util5.text.utf8.decode = function(bytes2) {
      return util5.decodeUtf8(String.fromCharCode.apply(null, bytes2));
    };
    util5.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k++] = str.charCodeAt(i2);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util5.text.utf16.decode = function(bytes2) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
    };
    util5.deflate = function(api, bytes2, raw) {
      bytes2 = util5.decode64(api.deflate(util5.encode64(bytes2)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes2.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes2 = bytes2.substring(start, bytes2.length - 4);
      }
      return bytes2;
    };
    util5.inflate = function(api, bytes2, raw) {
      var rval = api.inflate(util5.encode64(bytes2)).rval;
      return rval === null ? null : util5.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util5.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util5.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty20 = true;
        for (var prop in obj) {
          empty20 = false;
          break;
        }
        if (empty20) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util5.setItem = function(api, id, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util5.getItem = function(api, id, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util5.removeItem = function(api, id, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util5.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util5.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util5.format = function(format16) {
      var re2 = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts2 = [];
      var last14 = 0;
      while (match = re2.exec(format16)) {
        part = format16.substring(last14, re2.lastIndex - 2);
        if (part.length > 0) {
          parts2.push(part);
        }
        last14 = re2.lastIndex;
        var code22 = match[0][1];
        switch (code22) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts2.push(arguments[argi++ + 1]);
            } else {
              parts2.push("<?>");
            }
            break;
          case "%":
            parts2.push("%");
            break;
          default:
            parts2.push("<%" + code22 + "?>");
        }
      }
      parts2.push(format16.substring(last14));
      return parts2.join("");
    };
    util5.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i2.length > 3 ? i2.length % 3 : 0;
      return s + (j ? i2.substr(0, j) + t : "") + i2.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i2).toFixed(c).slice(2) : "");
    };
    util5.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util5.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util5.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util5.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util5.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util5.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util5.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util5.bytesFromIPv6(ip);
      }
      return null;
    };
    util5.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util5.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util5.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util5.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes2 = util5.hexToBytes(ip[i2]);
        if (bytes2.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes2);
      }
      return b.getBytes();
    };
    util5.bytesToIP = function(bytes2) {
      if (bytes2.length === 4) {
        return util5.bytesToIPv4(bytes2);
      }
      if (bytes2.length === 16) {
        return util5.bytesToIPv6(bytes2);
      }
      return null;
    };
    util5.bytesToIPv4 = function(bytes2) {
      if (bytes2.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes2.length; ++i2) {
        ip.push(bytes2.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util5.bytesToIPv6 = function(bytes2) {
      if (bytes2.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes2.length; i2 += 2) {
        var hex = util5.bytesToHex(bytes2[i2] + bytes2[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last14 = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last14 || idx !== last14.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last14.end = idx;
            if (last14.end - last14.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util5.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util5 && !options.update) {
        return callback(null, util5.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util5.cores = navigator.hardwareConcurrency;
        return callback(null, util5.cores);
      }
      if (typeof Worker === "undefined") {
        util5.cores = 1;
        return callback(null, util5.cores);
      }
      if (typeof Blob === "undefined") {
        util5.cores = 2;
        return callback(null, util5.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util5.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util5.cores);
        }
        map19(numWorkers, function(err2, results) {
          max.push(reduce2(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map19(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge9 = require_forge();
    forge9.pki = forge9.pki || {};
    var oids = module2.exports = forge9.pki.oids = forge9.oids = forge9.oids || {};
    function _IN(id, name22) {
      oids[id] = name22;
      oids[name22] = id;
    }
    function _I_(id, name22) {
      oids[id] = name22;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge9.asn1 = forge9.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value2, options) {
      if (forge9.util.isArray(value2)) {
        var tmp = [];
        for (var i2 = 0; i2 < value2.length; ++i2) {
          if (value2[i2] !== void 0) {
            tmp.push(value2[i2]);
          }
        }
        value2 = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge9.util.isArray(value2),
        value: value2
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge9.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge9.util.isArray(obj1)) {
        if (!forge9.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length23;
      var longForm = b2 & 128;
      if (!longForm) {
        length23 = b2;
      } else {
        length23 = b.getInt((b2 & 127) << 3);
      }
      return length23;
    };
    function _checkBufferLength(bytes2, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes2.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes2, remaining) {
      var b2 = bytes2.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length23;
      var longForm = b2 & 128;
      if (!longForm) {
        length23 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes2, remaining, longFormBytes);
        length23 = bytes2.getInt(longFormBytes << 3);
      }
      if (length23 < 0) {
        throw new Error("Negative length: " + length23);
      }
      return length23;
    };
    asn1.fromDer = function(bytes2, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var byteCount = bytes2.length();
      var value2 = _fromDer(bytes2, bytes2.length(), 0, options);
      if (options.parseAllBytes && bytes2.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes2.length();
        throw error;
      }
      return value2;
    };
    function _fromDer(bytes2, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes2, remaining, 2);
      var b1 = bytes2.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes2.length();
      var length23 = _getValueLength(bytes2, remaining);
      remaining -= start - bytes2.length();
      if (length23 !== void 0 && length23 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes2.length();
          error.remaining = remaining;
          error.requested = length23;
          throw error;
        }
        length23 = remaining;
      }
      var value2;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value2 = [];
        if (length23 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes2, remaining, 2);
            if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
              bytes2.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes2.length();
            value2.push(_fromDer(bytes2, remaining, depth + 1, options));
            remaining -= start - bytes2.length();
          }
        } else {
          while (length23 > 0) {
            start = bytes2.length();
            value2.push(_fromDer(bytes2, length23, depth + 1, options));
            remaining -= start - bytes2.length();
            length23 -= start - bytes2.length();
          }
        }
      }
      if (value2 === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes2.bytes(length23);
      }
      if (value2 === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length23 > 1) {
        var savedRead = bytes2.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes2, remaining, 1);
          unused = bytes2.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes2.length();
            var subOptions = {
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
            var used = start - bytes2.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length23 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value2 = [composed];
            }
          } catch (ex) {
          }
        }
        if (value2 === void 0) {
          bytes2.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value2 === void 0) {
        if (length23 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length23 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value2 = "";
          for (; length23 > 0; length23 -= 2) {
            _checkBufferLength(bytes2, remaining, 2);
            value2 += String.fromCharCode(bytes2.getInt16());
            remaining -= 2;
          }
        } else {
          value2 = bytes2.getBytes(length23);
          remaining -= length23;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value2, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes2 = forge9.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value2 = forge9.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value2.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value2.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value2.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value2.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value2.putBytes(obj.value.substr(1));
          } else {
            value2.putBytes(obj.value);
          }
        }
      }
      bytes2.putByte(b1);
      if (value2.length() <= 127) {
        bytes2.putByte(value2.length() & 127);
      } else {
        var len = value2.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes2.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes2.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes2.putBuffer(value2);
      return bytes2;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes2 = forge9.util.createBuffer();
      bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last14, valueBytes, value2, b;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last14 = true;
        valueBytes = [];
        value2 = parseInt(values[i2], 10);
        do {
          b = value2 & 127;
          value2 = value2 >>> 7;
          if (!last14) {
            b |= 128;
          }
          valueBytes.push(b);
          last14 = false;
        } while (value2 > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes2.putByte(valueBytes[n]);
        }
      }
      return bytes2;
    };
    asn1.derToOid = function(bytes2) {
      var oid;
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var b = bytes2.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value2 = 0;
      while (bytes2.length() > 0) {
        b = bytes2.getByte();
        value2 = value2 << 7;
        if (b & 128) {
          value2 += b & 127;
        } else {
          oid += "." + (value2 + b);
          value2 = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format16 = [];
      format16.push(("" + date.getUTCFullYear()).substr(2));
      format16.push("" + (date.getUTCMonth() + 1));
      format16.push("" + date.getUTCDate());
      format16.push("" + date.getUTCHours());
      format16.push("" + date.getUTCMinutes());
      format16.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format16.length; ++i2) {
        if (format16[i2].length < 2) {
          rval += "0";
        }
        rval += format16[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format16 = [];
      format16.push("" + date.getUTCFullYear());
      format16.push("" + (date.getUTCMonth() + 1));
      format16.push("" + date.getUTCDate());
      format16.push("" + date.getUTCHours());
      format16.push("" + date.getUTCMinutes());
      format16.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format16.length; ++i2) {
        if (format16[i2].length < 2) {
          rval += "0";
        }
        rval += format16[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge9.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes2) {
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var n = bytes2.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes2.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors2) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge9.util.isArray(v.value)) {
            var j = 0;
            for (var i2 = 0; rval && i2 < v.value.length; ++i2) {
              rval = v.value[i2].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i2], capture, errors2);
                if (rval) {
                  ++j;
                } else if (v.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors2) {
                errors2.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value2;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors2) {
          errors2.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors2) {
        if (obj.tagClass !== v.tagClass) {
          errors2.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors2.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge9.pki && forge9.pki.oids) {
            if (oid in forge9.pki.oids) {
              rval += " (" + forge9.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge9.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge9.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge9.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge9.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge9.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge9.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    module2.exports = forge9.cipher = forge9.cipher || {};
    forge9.cipher.algorithms = forge9.cipher.algorithms || {};
    forge9.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge9.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge9.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge9.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge9.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge9.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge9.cipher.registerAlgorithm = function(name22, algorithm) {
      name22 = name22.toUpperCase();
      forge9.cipher.algorithms[name22] = algorithm;
    };
    forge9.cipher.getAlgorithm = function(name22) {
      name22 = name22.toUpperCase();
      if (name22 in forge9.cipher.algorithms) {
        return forge9.cipher.algorithms[name22];
      }
      return null;
    };
    var BlockCipher = forge9.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge9.util.createBuffer();
      this.output = options.output || forge9.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    forge9.cipher = forge9.cipher || {};
    var modes = module2.exports = forge9.cipher.modes = forge9.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge9.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge9.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge9.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge9.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge9.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge9.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x[i2] >>> 1 | (x[i2 - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits2) {
      var multiplier = 8 / bits2;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits2;
        tmp[idx] = 1 << bits2 - 1 << shft;
        m[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
      var size = 1 << bits2;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m[2 * i2], m[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j = 1; j < i2; ++j) {
          var m_i = m[i2];
          var m_j = m[j];
          m[i2 + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c = m[i2 ^ half];
        m[i2] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge9.util.createBuffer(iv);
      }
      if (forge9.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge9.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge9.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge9 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge9.aes = forge9.aes || {};
    forge9.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge9.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge9.aes.Algorithm = function(name22, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name22;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge9.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge9.util.createBuffer(key);
      } else if (forge9.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge9.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge9.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge9.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge9.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge9.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge9.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge9.cipher.modes.gcm);
    function registerAlgorithm(name22, mode) {
      var factory = function() {
        return new forge9.aes.Algorithm(name22, mode);
      };
      forge9.cipher.registerAlgorithm(name22, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i2] = w[i2 - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w[wi];
            wnew[i2 + 1] = w[wi + 3];
            wnew[i2 + 2] = w[wi + 2];
            wnew[i2 + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i2 + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt2) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt2) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt2 ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt2 ? 1 : 3] ^ w[3];
      var i2 = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i2];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i2];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i2];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i2];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i2];
      output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i2];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i2];
      output[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge9.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge9.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge9.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge9 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge9.des = forge9.des || {};
    forge9.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge9.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge9.des.Algorithm = function(name22, mode) {
      var self2 = this;
      self2.name = name22;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge9.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge9.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge9.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge9.cipher.modes.ctr);
    function registerAlgorithm(name22, mode) {
      var factory = function() {
        return new forge9.des.Algorithm(name22, mode);
      };
      forge9.cipher.registerAlgorithm(name22, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt2) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i2 = looping[j]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge9.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge9.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge9.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge9 = require_forge();
    module2.exports = forge9.md = forge9.md || {};
    forge9.md.algorithms = forge9.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge9.hmac = forge9.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge9.md.algorithms) {
              _md = forge9.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge9.util.createBuffer(key);
          } else if (forge9.util.isArray(key)) {
            var tmp = key;
            key = forge9.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge9.util.createBuffer();
          _opadding = forge9.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes2) {
        _md.update(bytes2);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge9 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge9.pkcs5 = forge9.pkcs5 || {};
    var crypto4;
    if (forge9.util.isNodejs && !forge9.options.usePureJavaScript) {
      crypto4 = require_crypto();
    }
    module2.exports = forge9.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge9.util.isNodejs && !forge9.options.usePureJavaScript && crypto4.pbkdf2 && (md === null || typeof md !== "object") && (crypto4.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto4.pbkdf2Sync.length === 4) {
            return crypto4.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto4.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto4.pbkdf2Sync.length === 4) {
          return crypto4.pbkdf2(p, s, c, dkLen, function(err3, key) {
            if (err3) {
              return callback(err3);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto4.pbkdf2(p, s, c, dkLen, md, function(err3, key) {
          if (err3) {
            return callback(err3);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge9.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge9.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err2 = new Error("Derived key is too long.");
        if (callback) {
          return callback(err2);
        }
        throw err2;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge9.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge9.util.int32ToBytes(i2));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge9.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor2 : xor2.substr(0, r);
        }
        return dk;
      }
      var i2 = 1, j;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge9.util.int32ToBytes(i2));
        xor2 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge9.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge9.util.setImmediate(inner);
        }
        dk += i2 < len ? xor2 : xor2.substr(0, r);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var pem = module2.exports = forge9.pem = forge9.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge9.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge9.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length23 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length23) {
        if (length23 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length23 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha25616 = module2.exports = forge9.sha256 = forge9.sha256 || {};
    forge9.md.sha256 = forge9.md.algorithms.sha256 = sha25616;
    sha25616.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1, t2, s0, s1, ch, maj, i2, a, b, c, d, e, f, g, h;
      var len = bytes2.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2] = bytes2.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i2] = t1 + w[i2 - 7] + t2 + w[i2 - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i2] + w[i2];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var _crypto = null;
    if (forge9.util.isNodejs && !forge9.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge9.prng = forge9.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge9.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err2) {
          if (err2) {
            return callback(err2);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge9.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge9.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge9.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err2, bytes2) {
          if (err2) {
            return callback(err2);
          }
          ctx.collect(bytes2);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge9.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge9.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b.putInt32(entropy[i3]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed2 = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed2 & 65535);
            hi = 16807 * (seed2 >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed2 = lo & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed2 >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err2, bytes2) {
            if (err2) {
              return callback(err2);
            }
            callback(null, bytes2.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes2) {
        var count = bytes2.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes2.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n) {
        var bytes2 = "";
        for (var x = 0; x < n; x += 8) {
          bytes2 += String.fromCharCode(i3 >> x & 255);
        }
        ctx.collect(bytes2);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err2, bytes2) {
                worker.postMessage({ forge: { prng: { err: err2, bytes: bytes2 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge9.random && forge9.random.getBytes) {
        module2.exports = forge9.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge9.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge9.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge9.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed2) {
          var tmp = forge9.util.createBuffer(seed2);
          seed2 = new Array(4);
          seed2[0] = tmp.getInt32();
          seed2[1] = tmp.getInt32();
          seed2[2] = tmp.getInt32();
          seed2[3] = tmp.getInt32();
          return seed2;
        };
        prng_aes.cipher = function(key2, seed2) {
          forge9.aes._updateBlock(key2, seed2, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed2) {
          ++seed2[3];
          return seed2;
        };
        prng_aes.md = forge9.md.sha256;
        function spawnPrng() {
          var ctx = forge9.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge9.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge9.options.usePureJavaScript || !forge9.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge9.random) {
          forge9.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge9.random[key] = _ctx[key];
          }
        }
        forge9.random.createInstance = spawnPrng;
        module2.exports = forge9.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word2, bits2) {
      return word2 << bits2 & 65535 | (word2 & 65535) >> 16 - bits2;
    };
    var ror = function(word2, bits2) {
      return (word2 & 65535) >> bits2 | word2 << 16 - bits2 & 65535;
    };
    module2.exports = forge9.rc2 = forge9.rc2 || {};
    forge9.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge9.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T; i2 < 128; i2++) {
        L.putByte(piTable[L.at(i2 - 1) + L.at(i2 - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L.setAt(i2, piTable[L.at(i2 + 1) ^ L.at(i2 + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits2, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j, K2 = [];
      key = forge9.rc2.expandKey(key, bits2);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K2[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            R[i2] = rol(R[i2], s[i2]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K2[R[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] = ror(R[i2], s[i2]);
            R[i2] -= K2[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] -= K2[R[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R[i2]);
            } else {
              R[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i2]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge9.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge9.util.createBuffer();
          _output = output || new forge9.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge9.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge9.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge9.rc2.createEncryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, true);
    };
    forge9.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge9.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge9.rc2.createDecryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge9 = require_forge();
    module2.exports = forge9.jsbn = forge9.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge9.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i2++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i2, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i2] & 32767;
        var h = this.data[i2++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i2, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i2] & 16383;
        var h = this.data[i2++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i2) {
      var c = BI_RC[s.charCodeAt(i2)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r.data[i2] = this.data[i2];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i2) {
      var r = nbi();
      r.fromInt(i2);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x = k == 8 ? s[i2] & 255 : intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i2 = this.t;
      var p = this.DB - i2 * this.DB % k;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i2 >= 0) {
          if (p < k) {
            d = (this.data[i2] & (1 << p) - 1) << k - p;
            d |= this.data[--i2] >> (p += this.DB - k);
          } else {
            d = this.data[i2] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i2 = this.t;
      r = i2 - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i2 >= 0)
        if ((r = this.data[i2] - a.data[i2]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2)
        r.data[i2 + n] = this.data[i2];
      for (i2 = n - 1; i2 >= 0; --i2)
        r.data[i2] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i2 = n; i2 < this.t; ++i2)
        r.data[i2 - n] = this.data[i2];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r.data[i2 + ds + 1] = this.data[i2] >> cbs | c;
        c = (this.data[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2)
        r.data[i2] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
        r.data[i2 - ds] = this.data[i2] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] - a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c -= a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i2++] = this.DV + c;
      else if (c > 0)
        r.data[i2++] = c;
      r.t = i2;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i2 = x.t;
      r.t = i2 + y.t;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = 0; i2 < y.t; ++i2)
        r.data[i2 + x.t] = x.am(0, y.data[i2], r, i2, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i2 = r.t = 2 * x.t;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = 0; i2 < x.t - 1; ++i2) {
        var c = x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
        if ((r.data[i2 + x.t] += x.am(i2 + 1, 2 * x.data[i2], r, 2 * i2 + 1, c, x.t - i2 - 1)) >= x.DV) {
          r.data[i2 + x.t] -= x.DV;
          r.data[i2 + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i2 = r.t, j = i2 - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i2] == y0 ? this.DM : Math.floor(r.data[i2] * d1 + (r.data[i2 - 1] + e) * d2);
        if ((r.data[i2] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i2] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j = x.data[i2] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i2] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i2 + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i2, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i2 = nbits(e) - 1;
      g.copyTo(r);
      while (--i2 >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i2) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i2 = 0; i2 < s.length; ++i2) {
        var x = intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i2 * this.DB % 8, d, k = 0;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i2 >= 0) {
          if (p < 8) {
            d = (this.data[i2] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i2] >> (p += this.DB - 8);
          } else {
            d = this.data[i2] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i2, f, m = Math.min(a.t, this.t);
      for (i2 = 0; i2 < m; ++i2)
        r.data[i2] = op(this.data[i2], a.data[i2]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i2 = m; i2 < this.t; ++i2)
          r.data[i2] = op(this.data[i2], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i2 = m; i2 < a.t; ++i2)
          r.data[i2] = op(f, a.data[i2]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i2 = 0; i2 < this.t; ++i2)
        r.data[i2] = this.DM & ~this.data[i2];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0)
          return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2)
        r += cbit(this.data[i2] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] + a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c += a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i2++] = c;
      else if (c < -1)
        r.data[i2++] = this.DV + c;
      r.t = i2;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i2 = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i2;
      while (i2 > 0)
        r.data[--i2] = 0;
      var j;
      for (j = r.t - this.t; i2 < j; ++i2)
        r.data[i2 + this.t] = this.am(0, a.data[i2], r, i2, 0, this.t);
      for (j = Math.min(a.t, n); i2 < j; ++i2)
        this.am(0, a.data[i2], r, i2, 0, n - i2);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i2 = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = Math.max(n - this.t, 0); i2 < a.t; ++i2)
        r.data[this.t + i2 - n] = this.am(n - i2, a.data[i2], r, 0, 0, this.t + i2 - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i2 = e.bitLength(), k, r = nbv(1), z;
      if (i2 <= 0)
        return r;
      else if (i2 < 18)
        k = 1;
      else if (i2 < 48)
        k = 3;
      else if (i2 < 144)
        k = 4;
      else if (i2 < 768)
        k = 5;
      else
        k = 6;
      if (i2 < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i2 = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i2 >= k1)
          w = e.data[j] >> i2 - k1 & km;
        else {
          w = (e.data[j] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i2 - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i2 -= n) < 0) {
          i2 += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i2) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i2 = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i2 < g)
        g = i2;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i2 = x.getLowestSetBit()) > 0)
          x.rShiftTo(i2, x);
        if ((i2 = y.getLowestSetBit()) > 0)
          y.rShiftTo(i2, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r = (d * r + this.data[i2]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x.data[0] == lowprimes[i2])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m = lowprimes[i2], j = i2 + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i2 < j)
          if (m % lowprimes[i2++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x) {
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge9.sha1 = forge9.sha1 || {};
    forge9.md.sha1 = forge9.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t, a, b, c, d, e, f, i2;
      var len = bytes2.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes2.getInt32();
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 20; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 32; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 40; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 60; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 80; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge9.pkcs1 = forge9.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message6, options) {
      var label;
      var seed2;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed2 = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed2 = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge9.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message6.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message6.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message6.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message6;
      if (!seed2) {
        seed2 = forge9.random.getBytes(md.digestLength);
      } else if (seed2.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed2.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge9.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge9.util.xorBytes(seed2, seedMask, seed2.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge9.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed2 = forge9.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge9.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i2 = 0; i2 < md.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code22 = db.charCodeAt(j);
        var is_0 = code22 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code22 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed2, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge9.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash3.start();
        hash3.update(seed2 + c);
        t += hash3.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge9.prime) {
        module2.exports = forge9.prime;
        return;
      }
      var prime = module2.exports = forge9.prime = forge9.prime || {};
      var BigInteger = forge9.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits2, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge9.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i2 = 0; i2 < x.length; ++i2) {
              x[i2] = b.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits2, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits2, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
        var num = generateRandom(bits2, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits2) {
            num = generateRandom(bits2, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge9.util.setImmediate(function() {
          _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
        }
        var num = generateRandom(bits2, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge9.util.estimateCores(function(err2, cores) {
            if (err2) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits2) {
              num = generateRandom(bits2, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits2, rng) {
        var num = new BigInteger(bits2, rng);
        var bits1 = bits2 - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits2) {
        if (bits2 <= 100)
          return 27;
        if (bits2 <= 150)
          return 18;
        if (bits2 <= 200)
          return 15;
        if (bits2 <= 250)
          return 12;
        if (bits2 <= 300)
          return 9;
        if (bits2 <= 350)
          return 8;
        if (bits2 <= 400)
          return 7;
        if (bits2 <= 500)
          return 6;
        if (bits2 <= 600)
          return 5;
        if (bits2 <= 800)
          return 4;
        if (bits2 <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge9 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge9.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge9.util.isNodejs ? require_crypto() : null;
    var asn1 = forge9.asn1;
    var util5 = forge9.util;
    forge9.pki = forge9.pki || {};
    module2.exports = forge9.pki.rsa = forge9.rsa = forge9.rsa || {};
    var pki2 = forge9.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge9.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki2.oids) {
        oid = pki2.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest15 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest15);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge9.util.bytesToHex(forge9.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki2.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge9.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge9.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge9.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki2.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge9.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge9.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge9.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki2.rsa.createKeyPairGenerationState = function(bits2, e, options) {
      if (typeof bits2 === "string") {
        bits2 = parseInt(bits2, 10);
      }
      bits2 = bits2 || 2048;
      options = options || {};
      var prng = options.prng || forge9.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = b.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits: bits2,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits2 >> 1,
          pBits: bits2 - (bits2 >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki2.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits2 = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits2 - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits2, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits2) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki2.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki2.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki2.rsa.generateKeyPair = function(bits2, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits2 === "object") {
          options = bits2;
          bits2 = void 0;
        } else if (typeof bits2 === "function") {
          callback = bits2;
          bits2 = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits2 === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits2;
          callback = e;
          bits2 = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits2 === void 0) {
        bits2 = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge9.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits2,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err2, pub, priv) {
              if (err2) {
                return callback(err2);
              }
              callback(null, {
                privateKey: pki2.privateKeyFromPem(priv),
                publicKey: pki2.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util5.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair2) {
              return util5.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
            }).then(void 0, function(err2) {
              callback(err2);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge9.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util5.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair2 = e2.target.result;
              var exportOp = util5.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge9.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err2) {
                callback(err2);
              };
            };
            genOp.onerror = function(err2) {
              callback(err2);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits2,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki2.privateKeyFromPem(keypair.privateKey),
              publicKey: pki2.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki2.rsa.createKeyPairGenerationState(bits2, e, options);
      if (!callback) {
        pki2.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge9.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki2.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest15, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest16, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors2 = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors2)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors2;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge9.oids.md2 || oid === forge9.oids.md5 || oid === forge9.oids.sha1 || oid === forge9.oids.sha224 || oid === forge9.oids.sha256 || oid === forge9.oids.sha384 || oid === forge9.oids.sha512 || oid === forge9.oids["sha512-224"] || oid === forge9.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge9.oids.md2 || oid === forge9.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest16 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest16, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest16 === d2;
            }
          };
        }
        var d = pki2.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest15, d, key.n.bitLength());
      };
      return key;
    };
    pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki2.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge9.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki2.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki2.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki2.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors2)) {
        obj = asn1.fromDer(forge9.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors2 = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors2;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge9.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge9.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge9.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge9.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge9.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge9.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge9.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge9.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki2.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki2.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors2)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki2.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors2 = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors2;
        throw error;
      }
      var n = forge9.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge9.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki2.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki2.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki2.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge9.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge9.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge9.util.createBuffer(em);
      var first10 = eb.getByte();
      var bt = eb.getByte();
      if (first10 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero2 = eb.getByte();
      if (zero2 !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err2, num) {
          if (err2) {
            return callback(err2);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err2, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits2, callback2) {
        forge9.prime.generateProbablePrime(bits2, opts, callback2);
      }
      function finish(err2, num) {
        if (err2) {
          return callback(err2);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki2.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki2.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes2 = forge9.util.hexToBytes(hex);
      if (bytes2.length > 1 && (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
        return bytes2.substr(1);
      }
      return bytes2;
    }
    function _getMillerRabinTests(bits2) {
      if (bits2 <= 100)
        return 27;
      if (bits2 <= 150)
        return 18;
      if (bits2 <= 200)
        return 15;
      if (bits2 <= 250)
        return 12;
      if (bits2 <= 300)
        return 9;
      if (bits2 <= 350)
        return 8;
      if (bits2 <= 400)
        return 7;
      if (bits2 <= 500)
        return 6;
      if (bits2 <= 600)
        return 5;
      if (bits2 <= 800)
        return 4;
      if (bits2 <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge9.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util5.globalScope !== "undefined" && typeof util5.globalScope.crypto === "object" && typeof util5.globalScope.crypto.subtle === "object" && typeof util5.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util5.globalScope !== "undefined" && typeof util5.globalScope.msCrypto === "object" && typeof util5.globalScope.msCrypto.subtle === "object" && typeof util5.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes2 = forge9.util.hexToBytes(x.toString(16));
      var buffer2 = new Uint8Array(bytes2.length);
      for (var i2 = 0; i2 < bytes2.length; ++i2) {
        buffer2[i2] = bytes2.charCodeAt(i2);
      }
      return buffer2;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge9.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge9.asn1;
    var pki2 = forge9.pki = forge9.pki || {};
    module2.exports = pki2.pbe = forge9.pbe = forge9.pbe || {};
    var oids = pki2.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki2.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge9.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge9.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge9.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge9.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                params
              ]),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge9.util.ByteBuffer(salt);
        var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge9.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki2.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge9.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
        rval = pki2.encryptPrivateKeyInfo(rval, password, options);
        return pki2.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge9.random.getBytesSync(8);
          cipherFn = forge9.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge9.random.getBytesSync(8);
          cipherFn = forge9.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge9.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki2.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge9.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge9.pem.encode(msg);
    };
    pki2.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge9.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge9.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge9.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge9.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge9.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki2.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki2.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge9.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge9.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge9.util.ByteBuffer();
      var passBuf = new forge9.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge9.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge9.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge9.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i2 = 1; i2 <= c; i2++) {
        var buf2 = new forge9.util.ByteBuffer();
        buf2.putBytes(D.bytes());
        buf2.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf2.getBytes());
          buf2 = md.digest();
        }
        var B = new forge9.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf2.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge9.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge9.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf2);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki2.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki2.oids["pkcs5PBES2"]:
          return pki2.pbe.getCipherForPBES2(oid, params, password);
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki2.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge9.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki2.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge9.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge9.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge9.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var salt = forge9.util.createBuffer(capture.salt);
      var count = forge9.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge9.des.startDecrypting;
          break;
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge9.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge9.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge9.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash3(md, password + salt)];
      for (var length23 = 16, i2 = 1; length23 < dkLen; ++i2, length23 += 16) {
        digests.push(hash3(md, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash3(md, bytes2) {
      return md.start().update(bytes2).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki2.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge9.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge9.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(dkLen.toString(16))
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha51216 = module2.exports = forge9.sha512 = forge9.sha512 || {};
    forge9.md.sha512 = forge9.md.algorithms.sha512 = sha51216;
    var sha384 = forge9.sha384 = forge9.sha512.sha384 = forge9.sha512.sha384 || {};
    sha384.create = function() {
      return sha51216.create("SHA-384");
    };
    forge9.md.sha384 = forge9.md.algorithms.sha384 = sha384;
    forge9.sha512.sha256 = forge9.sha512.sha256 || {
      create: function() {
        return sha51216.create("SHA-512/256");
      }
    };
    forge9.md["sha512/256"] = forge9.md.algorithms["sha512/256"] = forge9.sha512.sha256;
    forge9.sha512.sha224 = forge9.sha512.sha224 || {
      create: function() {
        return sha51216.create("SHA-512/224");
      }
    };
    forge9.md["sha512/224"] = forge9.md.algorithms["sha512/224"] = forge9.sha512.sha224;
    sha51216.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var h = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h[i2] = _h[i2].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i2][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi, lo, w2, w7, w15, w16;
      var len = bytes2.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2][0] = bytes2.getInt32() >>> 0;
          w[i2][1] = bytes2.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w2 = w[i2 - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i2 - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i2 - 7];
          w16 = w[i2 - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i2][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString28();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value2 = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value2));
            case "i":
              return String(Math.floor(value2));
            case "j":
              return JSON.stringify(value2);
            case "s":
              return String(value2);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString28(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString28;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err2, contents) {
          return err2 && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err2 ? callback(err2) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch.xhr(filename, options, callback);
    }
    fetch.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer2 = xhr.response;
          if (!buffer2) {
            buffer2 = [];
            for (var i2 = 0; i2 < xhr.responseText.length; ++i2)
              buffer2.push(xhr.responseText.charCodeAt(i2) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer2) : buffer2);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path2 = exports2;
    var isAbsolute = path2.isAbsolute = function isAbsolute2(path3) {
      return /^(?:\/|\w+:)/.test(path3);
    };
    var normalize = path2.normalize = function normalize2(path3) {
      path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var parts2 = path3.split("/"), absolute = isAbsolute(path3), prefix = "";
      if (absolute)
        prefix = parts2.shift() + "/";
      for (var i2 = 0; i2 < parts2.length; ) {
        if (parts2[i2] === "..") {
          if (i2 > 0 && parts2[i2 - 1] !== "..")
            parts2.splice(--i2, 2);
          else if (absolute)
            parts2.splice(i2, 1);
          else
            ++i2;
        } else if (parts2[i2] === ".")
          parts2.splice(i2, 1);
        else
          ++i2;
      }
      return prefix + parts2.join("/");
    };
    path2.resolve = function resolve7(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types2 = exports2;
    var util5 = require_util2();
    var s = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
    ];
    function bake(values, offset) {
      var i2 = 0, o = {};
      offset |= 0;
      while (i2 < values.length)
        o[s[i2 + offset]] = values[i2++];
      return o;
    }
    types2.basic = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2,
      2
    ]);
    types2.defaults = bake([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      false,
      "",
      util5.emptyArray,
      null
    ]);
    types2.long = bake([
      0,
      0,
      0,
      1,
      1
    ], 7);
    types2.mapKey = bake([
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2
    ], 2);
    types2.packed = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types2 = require_types();
    var util5 = require_util2();
    var Type2;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name22, json) {
      return new Field(name22, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name22, id, type, rule, extend, options, comment) {
      if (util5.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util5.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name22, options);
      if (!util5.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util5.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util5.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util5.Long ? types2.long[type] !== void 0 : false;
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name22, value2, ifNotSet) {
      if (name22 === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name22, value2, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve7() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type2)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util5.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf2;
        if (util5.base64.test(this.typeDefault))
          util5.base64.decode(this.typeDefault, buf2 = util5.newBuffer(util5.base64.length(this.typeDefault)), 0);
        else
          util5.utf8.write(this.typeDefault, buf2 = util5.newBuffer(util5.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf2;
      }
      if (this.map)
        this.defaultValue = util5.emptyObject;
      else if (this.repeated)
        this.defaultValue = util5.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type2)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util5.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util5.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util5.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure6(Type_) {
      Type2 = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util5 = require_util2();
    function OneOf(name22, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name22, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name22, json) {
      return new OneOf(name22, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i2 = 0; i2 < oneof.fieldsArray.length; ++i2)
          if (!oneof.fieldsArray[i2].parent)
            oneof.parent.add(oneof.fieldsArray[i2]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent2) {
      ReflectionObject.prototype.onAdd.call(this, parent2);
      var self2 = this;
      for (var i2 = 0; i2 < this.oneof.length; ++i2) {
        var field = parent2.get(this.oneof[i2]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent2) {
      for (var i2 = 0, field; i2 < this.fieldsArray.length; ++i2)
        if ((field = this.fieldsArray[i2]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent2);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util5.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util5.oneOfGetter(fieldNames),
          set: util5.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util5 = require_util2();
    var OneOf = require_oneof();
    var Type2;
    var Service2;
    var Enum;
    Namespace.fromJSON = function fromJSON(name22, json) {
      return new Namespace(name22, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i2 = 0; i2 < array.length; ++i2)
        obj[array[i2].name] = array[i2].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i2 = 0; i2 < reserved.length; ++i2)
          if (typeof reserved[i2] !== "string" && reserved[i2][0] <= id && reserved[i2][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name22) {
      if (reserved) {
        for (var i2 = 0; i2 < reserved.length; ++i2)
          if (reserved[i2] === name22)
            return true;
      }
      return false;
    };
    function Namespace(name22, options) {
      ReflectionObject.call(this, name22, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace3) {
      namespace3._nestedArray = null;
      return namespace3;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util5.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util5.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names3 = Object.keys(nestedJson), i2 = 0, nested; i2 < names3.length; ++i2) {
          nested = nestedJson[names3[i2]];
          ns.add(
            (nested.fields !== void 0 ? Type2.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service2.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names3[i2], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get3(name22) {
      return this.nested && this.nested[name22] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name22) {
      if (this.nested && this.nested[name22] instanceof Enum)
        return this.nested[name22].values;
      throw Error("no such enum: " + name22);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type2 || object instanceof OneOf || object instanceof Enum || object instanceof Service2 || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev2 = this.get(object.name);
        if (prev2) {
          if (prev2 instanceof Namespace && object instanceof Namespace && !(prev2 instanceof Type2 || prev2 instanceof Service2)) {
            var nested = prev2.nestedArray;
            for (var i2 = 0; i2 < nested.length; ++i2)
              object.add(nested[i2]);
            this.remove(prev2);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev2.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path2, json) {
      if (util5.isString(path2))
        path2 = path2.split(".");
      else if (!Array.isArray(path2))
        throw TypeError("illegal path");
      if (path2 && path2.length && path2[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path2.length > 0) {
        var part = path2.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i2 = 0;
      while (i2 < nested.length)
        if (nested[i2] instanceof Namespace)
          nested[i2++].resolveAll();
        else
          nested[i2++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup3(path2, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util5.isString(path2) && path2.length) {
        if (path2 === ".")
          return this.root;
        path2 = path2.split(".");
      } else if (!path2.length)
        return this;
      if (path2[0] === "")
        return this.root.lookup(path2.slice(1), filterTypes);
      var found = this.get(path2[0]);
      if (found) {
        if (path2.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i2 = 0; i2 < this.nestedArray.length; ++i2)
          if (this._nestedArray[i2] instanceof Namespace && (found = this._nestedArray[i2].lookup(path2, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path2, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path2) {
      var found = this.lookup(path2, [Type2]);
      if (!found)
        throw Error("no such type: " + path2);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path2) {
      var found = this.lookup(path2, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
      var found = this.lookup(path2, [Type2, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path2) {
      var found = this.lookup(path2, [Service2]);
      if (!found)
        throw Error("no such Service '" + path2 + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type2 = Type_;
      Service2 = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types2 = require_types();
    var util5 = require_util2();
    function MapField(name22, id, keyType, type, options, comment) {
      Field.call(this, name22, id, type, void 0, void 0, options, comment);
      if (!util5.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name22, json) {
      return new MapField(name22, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve7() {
      if (this.resolved)
        return this;
      if (types2.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util5.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util5.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util5.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util5 = require_util2();
    function Method(name22, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util5.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util5.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util5.isString(type)))
        throw TypeError("type must be a string");
      if (!util5.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util5.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name22, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name22, json) {
      return new Method(name22, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "type",
        this.type !== "rpc" && this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve7() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service2;
    var Namespace = require_namespace();
    ((Service2.prototype = Object.create(Namespace.prototype)).constructor = Service2).className = "Service";
    var Method = require_method();
    var util5 = require_util2();
    var rpc = require_rpc();
    function Service2(name22, options) {
      Namespace.call(this, name22, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service2.fromJSON = function fromJSON(name22, json) {
      var service = new Service2(name22, json.options);
      if (json.methods)
        for (var names3 = Object.keys(json.methods), i2 = 0; i2 < names3.length; ++i2)
          service.add(Method.fromJSON(names3[i2], json.methods[names3[i2]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service2.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service2.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util5.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service2.prototype.get = function get3(name22) {
      return this.methods[name22] || Namespace.prototype.get.call(this, name22);
    };
    Service2.prototype.resolveAll = function resolveAll() {
      var methods7 = this.methodsArray;
      for (var i2 = 0; i2 < methods7.length; ++i2)
        methods7[i2].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service2.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service2.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service2.prototype.create = function create26(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i2 = 0, method; i2 < this.methodsArray.length; ++i2) {
        var methodName = util5.lcFirst((method = this._methodsArray[i2]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util5.codegen(["r", "c"], util5.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message4;
    var util5 = require_minimal();
    function Message4(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i2 = 0; i2 < keys.length; ++i2)
          this[keys[i2]] = properties[keys[i2]];
    }
    Message4.create = function create26(properties) {
      return this.$type.create(properties);
    };
    Message4.encode = function encode81(message6, writer5) {
      return this.$type.encode(message6, writer5);
    };
    Message4.encodeDelimited = function encodeDelimited(message6, writer5) {
      return this.$type.encodeDelimited(message6, writer5);
    };
    Message4.decode = function decode97(reader6) {
      return this.$type.decode(reader6);
    };
    Message4.decodeDelimited = function decodeDelimited(reader6) {
      return this.$type.decodeDelimited(reader6);
    };
    Message4.verify = function verify3(message6) {
      return this.$type.verify(message6);
    };
    Message4.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message4.toObject = function toObject(message6, options) {
      return this.$type.toObject(message6, options);
    };
    Message4.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util5.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util5 = require_util2();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util5.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i2 = 0;
      for (; i2 < mtype.fieldsArray.length; ++i2) {
        var field = mtype._fieldsArray[i2].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util5.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types2.defaults[field.keyType] !== void 0)
            gen("k=%j", types2.defaults[field.keyType]);
          else
            gen("k=null");
          if (types2.defaults[type] !== void 0)
            gen("value=%j", types2.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types2.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i2);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types2.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else
            gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types2.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types2.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i2);
          else
            gen("%s.push(r.%s())", ref, type);
        } else if (types2.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i2);
        else
          gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i2 = 0; i2 < mtype._fieldsArray.length; ++i2) {
        var rfield = mtype._fieldsArray[i2];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util5 = require_util2();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util5.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i2 = 0; i2 < mtype.fieldsArray.length; ++i2) {
        var field = mtype._fieldsArray[i2].resolve(), ref = "m" + util5.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i2, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i2, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util5.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i2, ref);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util5 = require_util2();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i2 = 0; i2 < keys.length; ++i2) {
            if (values[keys[i2]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated)
                gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i2])("case %i:", values[keys[i2]])("m%s=%j", prop, values[keys[i2]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util5.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2].resolve(), prop = util5.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i2, prop + "[ks[i]]")("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i2, prop + "[i]")("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(gen, field, i2, prop);
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util5.compareFieldsById);
      if (!fields.length)
        return util5.codegen()("return {}");
      var gen = util5.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i2 = 0;
      for (; i2 < fields.length; ++i2)
        if (!fields[i2].partOf)
          (fields[i2].resolve().repeated ? repeatedFields : fields[i2].map ? mapFields : normalFields).push(fields[i2]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i2 = 0; i2 < repeatedFields.length; ++i2)
          gen("d%s=[]", util5.safeProp(repeatedFields[i2].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i2 = 0; i2 < mapFields.length; ++i2)
          gen("d%s={}", util5.safeProp(mapFields[i2].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i2 = 0; i2 < normalFields.length; ++i2) {
          var field = normalFields[i2], prop = util5.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2], index = mtype._fieldsArray.indexOf(field), prop = util5.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(gen, field, index, prop);
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util5.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message4 = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name22 = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name22);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message6, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name22 = "";
        if (options && options.json && message6.type_url && message6.value) {
          name22 = message6.type_url.substring(message6.type_url.lastIndexOf("/") + 1);
          prefix = message6.type_url.substring(0, message6.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name22);
          if (type)
            message6 = type.decode(message6.value);
        }
        if (!(message6 instanceof this.ctor) && message6 instanceof Message4) {
          var object = message6.$type.toObject(message6, options);
          var messageName = message6.$type.fullName[0] === "." ? message6.$type.fullName.slice(1) : message6.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name22 = prefix + messageName;
          object["@type"] = name22;
          return object;
        }
        return this.toObject(message6, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type2;
    var Namespace = require_namespace();
    ((Type2.prototype = Object.create(Namespace.prototype)).constructor = Type2).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service2 = require_service2();
    var Message4 = require_message();
    var Reader2 = require_reader();
    var Writer2 = require_writer();
    var util5 = require_util2();
    var encoder2 = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type2(name22, options) {
      Namespace.call(this, name22, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type2.prototype, {
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names3 = Object.keys(this.fields), i2 = 0; i2 < names3.length; ++i2) {
            var field = this.fields[names3[i2]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util5.toArray(this.fields));
        }
      },
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util5.toArray(this.oneofs));
        }
      },
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type2.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message4)) {
            (ctor.prototype = new Message4()).constructor = ctor;
            util5.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util5.merge(ctor, Message4, true);
          this._ctor = ctor;
          var i2 = 0;
          for (; i2 < this.fieldsArray.length; ++i2)
            this._fieldsArray[i2].resolve();
          var ctorProperties = {};
          for (i2 = 0; i2 < this.oneofsArray.length; ++i2)
            ctorProperties[this._oneofsArray[i2].resolve().name] = {
              get: util5.oneOfGetter(this._oneofsArray[i2].oneof),
              set: util5.oneOfSetter(this._oneofsArray[i2].oneof)
            };
          if (i2)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type2.generateConstructor = function generateConstructor(mtype) {
      var gen = util5.codegen(["p"], mtype.name);
      for (var i2 = 0, field; i2 < mtype.fieldsArray.length; ++i2)
        if ((field = mtype._fieldsArray[i2]).map)
          gen("this%s={}", util5.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util5.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type2.fromJSON = function fromJSON(name22, json) {
      var type = new Type2(name22, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names3 = Object.keys(json.fields), i2 = 0;
      for (; i2 < names3.length; ++i2)
        type.add(
          (typeof json.fields[names3[i2]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names3[i2], json.fields[names3[i2]])
        );
      if (json.oneofs)
        for (names3 = Object.keys(json.oneofs), i2 = 0; i2 < names3.length; ++i2)
          type.add(OneOf.fromJSON(names3[i2], json.oneofs[names3[i2]]));
      if (json.nested)
        for (names3 = Object.keys(json.nested), i2 = 0; i2 < names3.length; ++i2) {
          var nested = json.nested[names3[i2]];
          type.add(
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type2.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service2.fromJSON : Namespace.fromJSON)(names3[i2], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type2.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type2.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i2 = 0;
      while (i2 < fields.length)
        fields[i2++].resolve();
      var oneofs = this.oneofsArray;
      i2 = 0;
      while (i2 < oneofs.length)
        oneofs[i2++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type2.prototype.get = function get3(name22) {
      return this.fields[name22] || this.oneofs && this.oneofs[name22] || this.nested && this.nested[name22] || null;
    };
    Type2.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type2.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type2.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type2.prototype.isReservedName = function isReservedName(name22) {
      return Namespace.isReservedName(this.reserved, name22);
    };
    Type2.prototype.create = function create26(properties) {
      return new this.ctor(properties);
    };
    Type2.prototype.setup = function setup() {
      var fullName = this.fullName, types2 = [];
      for (var i2 = 0; i2 < this.fieldsArray.length; ++i2)
        types2.push(this._fieldsArray[i2].resolve().resolvedType);
      this.encode = encoder2(this)({
        Writer: Writer2,
        types: types2,
        util: util5
      });
      this.decode = decoder(this)({
        Reader: Reader2,
        types: types2,
        util: util5
      });
      this.verify = verifier(this)({
        types: types2,
        util: util5
      });
      this.fromObject = converter.fromObject(this)({
        types: types2,
        util: util5
      });
      this.toObject = converter.toObject(this)({
        types: types2,
        util: util5
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type2.prototype.encode = function encode_setup(message6, writer5) {
      return this.setup().encode(message6, writer5);
    };
    Type2.prototype.encodeDelimited = function encodeDelimited(message6, writer5) {
      return this.encode(message6, writer5 && writer5.len ? writer5.fork() : writer5).ldelim();
    };
    Type2.prototype.decode = function decode_setup(reader6, length23) {
      return this.setup().decode(reader6, length23);
    };
    Type2.prototype.decodeDelimited = function decodeDelimited(reader6) {
      if (!(reader6 instanceof Reader2))
        reader6 = Reader2.create(reader6);
      return this.decode(reader6, reader6.uint32());
    };
    Type2.prototype.verify = function verify_setup(message6) {
      return this.setup().verify(message6);
    };
    Type2.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type2.prototype.toObject = function toObject(message6, options) {
      return this.setup().toObject(message6, options);
    };
    Type2.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util5.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root2;
    var Namespace = require_namespace();
    ((Root2.prototype = Object.create(Namespace.prototype)).constructor = Root2).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util5 = require_util2();
    var Type2;
    var parse4;
    var common2;
    function Root2(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root2.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root2();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root2.prototype.resolvePath = util5.path.resolve;
    Root2.prototype.fetch = util5.fetch;
    function SYNC2() {
    }
    Root2.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util5.asPromise(load, self2, filename, options);
      var sync = callback === SYNC2;
      function finish(err2, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err2;
        cb(err2, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common2)
            return altname;
        }
        return null;
      }
      function process5(filename2, source) {
        try {
          if (util5.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util5.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse4.filename = filename2;
            var parsed = parse4(source, self2, options), resolved2, i3 = 0;
            if (parsed.imports) {
              for (; i3 < parsed.imports.length; ++i3)
                if (resolved2 = getBundledFileName(parsed.imports[i3]) || self2.resolvePath(filename2, parsed.imports[i3]))
                  fetch(resolved2);
            }
            if (parsed.weakImports) {
              for (i3 = 0; i3 < parsed.weakImports.length; ++i3)
                if (resolved2 = getBundledFileName(parsed.weakImports[i3]) || self2.resolvePath(filename2, parsed.weakImports[i3]))
                  fetch(resolved2, true);
            }
          }
        } catch (err2) {
          finish(err2);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch(filename2, weak) {
        filename2 = getBundledFileName(filename2) || filename2;
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common2) {
          if (sync)
            process5(filename2, common2[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process5(filename2, common2[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util5.fs.readFileSync(filename2).toString("utf8");
          } catch (err2) {
            if (!weak)
              finish(err2);
            return;
          }
          process5(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err2, source2) {
            --queued;
            if (!callback)
              return;
            if (err2) {
              if (!weak)
                finish(err2);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process5(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util5.isString(filename))
        filename = [filename];
      for (var i2 = 0, resolved; i2 < filename.length; ++i2)
        if (resolved = self2.resolvePath("", filename[i2]))
          fetch(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root2.prototype.loadSync = function loadSync(filename, options) {
      if (!util5.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC2);
    };
    Root2.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        if (extendedType.get(sisterField.name)) {
          return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root2.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0 && !object.extensionField) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type2)
          for (var i2 = 0; i2 < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i2]))
              this.deferred.splice(i2, 1);
            else
              ++i2;
        for (var j = 0; j < object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root2.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0) {
          if (object.extensionField) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i2 = 0; i2 < object.nestedArray.length; ++i2)
          this._handleRemove(object._nestedArray[i2]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root2._configure = function(Type_, parse_, common_) {
      Type2 = Type_;
      parse4 = parse_;
      common2 = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util2 = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util5 = module2.exports = require_minimal();
    var roots = require_roots();
    var Type2;
    var Enum;
    util5.codegen = require_codegen();
    util5.fetch = require_fetch();
    util5.path = require_path();
    util5.fs = util5.inquire("fs");
    util5.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util5.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util5.isReserved = function isReserved(name22) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name22);
    };
    util5.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util5.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util5.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util5.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util5.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util5.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util5.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util5.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type2)
        Type2 = require_type();
      var type = new Type2(typeName || ctor.name);
      util5.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util5.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util5.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util5.setProperty = function setProperty(dst, path2, value2) {
      function setProp(dst2, path3, value3) {
        var part = path3.shift();
        if (part === "__proto__") {
          return dst2;
        }
        if (path3.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path3, value3);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value3 = [].concat(prevValue).concat(value3);
          dst2[part] = value3;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path2)
        throw TypeError("path must be specified");
      path2 = path2.split(".");
      return setProp(dst, path2, value2);
    };
    Object.defineProperty(util5, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util5 = require_util2();
    var Root2;
    function ReflectionObject(name22, options) {
      if (!util5.isString(name22))
        throw TypeError("name must be a string");
      if (options && !util5.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name22;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      fullName: {
        get: function() {
          var path2 = [this.name], ptr = this.parent;
          while (ptr) {
            path2.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path2.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent2) {
      if (this.parent && this.parent !== parent2)
        this.parent.remove(this);
      this.parent = parent2;
      this.resolved = false;
      var root = parent2.root;
      if (root instanceof Root2)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent2) {
      var root = parent2.root;
      if (root instanceof Root2)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve7() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root2)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name22) {
      if (this.options)
        return this.options[name22];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name22, value2, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name22] === void 0)
        (this.options || (this.options = {}))[name22] = value2;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name22, value2, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name22);
        });
        if (opt) {
          var newValue = opt[name22];
          util5.setProperty(newValue, propName, value2);
        } else {
          opt = {};
          opt[name22] = util5.setProperty({}, propName, value2);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name22] = value2;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i2 = 0; i2 < keys.length; ++i2)
          this.setOption(keys[i2], options[keys[i2]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString28() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root2 = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util5 = require_util2();
    function Enum(name22, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name22, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i2 = 0; i2 < keys.length; ++i2)
          if (typeof values[keys[i2]] === "number")
            this.valuesById[this.values[keys[i2]] = values[keys[i2]]] = keys[i2];
      }
    }
    Enum.fromJSON = function fromJSON(name22, json) {
      var enm = new Enum(name22, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util5.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name22, id, comment, options) {
      if (!util5.isString(name22))
        throw TypeError("name must be a string");
      if (!util5.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name22] !== void 0)
        throw Error("duplicate name '" + name22 + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name22))
        throw Error("name '" + name22 + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name22] = id;
      } else
        this.valuesById[this.values[name22] = id] = name22;
      if (options) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name22] = options || null;
      }
      this.comments[name22] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name22) {
      if (!util5.isString(name22))
        throw TypeError("name must be a string");
      var val = this.values[name22];
      if (val == null)
        throw Error("name '" + name22 + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name22];
      delete this.comments[name22];
      if (this.valuesOptions)
        delete this.valuesOptions[name22];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name22) {
      return Namespace.isReservedName(this.reserved, name22);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder2;
    var Enum = require_enum();
    var types2 = require_types();
    var util5 = require_util2();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder2(mtype) {
      var gen = util5.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i2, ref;
      var fields = mtype.fieldsArray.slice().sort(util5.compareFieldsById);
      for (var i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types2.basic[type];
        ref = "m" + util5.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types2.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types2.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util2();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length23 = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString2() {
        var re2 = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re2.lastIndex = offset - 1;
        var match = re2.exec(source);
        if (!match)
          throw illegal("string");
        offset = re2.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i2 = 0; i2 < lines.length; ++i2)
          lines[i2] = lines[i2].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length23 && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString2();
        var repeat, prev2, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length23)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length23)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length23) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length23) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length23) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length23, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length23) {
                  throw illegal("comment");
                }
                prev2 = curr;
                curr = charAt(offset);
              } while (prev2 !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length23 && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals41 = actual === expected;
        if (equals41) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse4;
    parse4.filename = null;
    parse4.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root2 = require_root();
    var Type2 = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service2 = require_service2();
    var Method = require_method();
    var types2 = require_types();
    var util5 = require_util2();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse4(source, root, options) {
      if (!(root instanceof Root2)) {
        options = root;
        root = new Root2();
      }
      if (!options)
        options = parse4.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name22) {
        return name22;
      } : util5.camelCase;
      function illegal(token2, name22, insideTryCatch) {
        var filename = parse4.filename;
        if (!insideTryCatch)
          parse4.filename = null;
        return Error("illegal " + (name22 || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString2() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString2();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(token2, true);
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString2());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign5 = 1;
        if (token2.charAt(0) === "-") {
          sign5 = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign5 * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign5 * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign5 * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign5 * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign5 * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString2();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString2();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent2, token2) {
        switch (token2) {
          case "option":
            parseOption(parent2, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent2, token2);
            return true;
          case "enum":
            parseEnum(parent2, token2);
            return true;
          case "service":
            parseService(parent2, token2);
            return true;
          case "extend":
            parseExtension(parent2, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse4.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type2(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent2.add(type);
      }
      function parseField(parent2, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent2, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name22 = next();
        if (!nameRe.test(name22))
          throw illegal(name22, "name");
        name22 = applyCase(name22);
        skip("=");
        var field = new Field(name22, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name22);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent2.add(oneof);
        } else {
          parent2.add(field);
        }
        if (!isProto3 && field.repeated && (types2.packed[type] !== void 0 || types2.basic[type] === void 0))
          field.setOption("packed", false, true);
      }
      function parseGroup(parent2, rule) {
        var name22 = next();
        if (!nameRe.test(name22))
          throw illegal(name22, "name");
        var fieldName = util5.lcFirst(name22);
        if (name22 === fieldName)
          name22 = util5.ucFirst(name22);
        skip("=");
        var id = parseId(next());
        var type = new Type2(name22);
        type.group = true;
        var field = new Field(fieldName, id, name22, rule);
        field.filename = parse4.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token2);
              break;
            case "enum":
              parseEnum(type, token2);
              break;
            default:
              throw illegal(token2);
          }
        });
        parent2.add(type).add(field);
      }
      function parseMapField(parent2) {
        skip("<");
        var keyType = next();
        if (types2.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name22 = next();
        if (!nameRe.test(name22))
          throw illegal(name22, "name");
        skip("=");
        var field = new MapField(applyCase(name22), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent2.add(field);
      }
      function parseOneOf(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent2.add(oneof);
      }
      function parseEnum(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent2.add(enm);
      }
      function parseEnumValue(parent2, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value2 = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.setOption = function(name22, value3) {
          if (this.options === void 0)
            this.options = {};
          this.options[name22] = value3;
        };
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent2.add(token2, value2, dummy.comment, dummy.options);
      }
      function parseOption(parent2, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name22 = token2;
        var option = name22;
        var propName;
        if (isCustom) {
          skip(")");
          name22 = "(" + name22 + ")";
          option = name22;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.slice(1);
            name22 += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent2, name22);
        setParsedOption(parent2, option, optionValue, propName);
      }
      function parseOptionValue(parent2, name22) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next())) {
              throw illegal(token, "name");
            }
            var value2;
            var propName = token;
            skip(":", true);
            if (peek() === "{")
              value2 = parseOptionValue(parent2, name22 + "." + token);
            else if (peek() === "[") {
              value2 = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value2.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent2, name22 + "." + token, lastValue);
                }
              }
            } else {
              value2 = readValue(true);
              setOption(parent2, name22 + "." + token, value2);
            }
            var prevValue = objectResult[propName];
            if (prevValue)
              value2 = [].concat(prevValue).concat(value2);
            objectResult[propName] = value2;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent2, name22, simpleValue);
        return simpleValue;
      }
      function setOption(parent2, name22, value2) {
        if (parent2.setOption)
          parent2.setOption(name22, value2);
      }
      function setParsedOption(parent2, name22, value2, propName) {
        if (parent2.setParsedOption)
          parent2.setParsedOption(name22, value2, propName);
      }
      function parseInlineOptions(parent2) {
        if (skip("[", true)) {
          do {
            parseOption(parent2, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent2;
      }
      function parseService(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service2(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent2.add(service);
      }
      function parseMethod(parent2, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name22 = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name22, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent2.add(method);
      }
      function parseExtension(parent2, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent2, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent2, "proto3_optional", reference);
              } else {
                parseField(parent2, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent2, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse4.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common2 = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common2;
    var commonRe = /\/|\./;
    function common2(name22, json) {
      if (!commonRe.test(name22)) {
        name22 = "google/protobuf/" + name22 + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common2[name22] = json;
    }
    common2("any", {
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common2("duration", {
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common2("timestamp", {
      Timestamp: timeType
    });
    common2("empty", {
      Empty: {
        fields: {}
      }
    });
    common2("struct", {
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common2("wrappers", {
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common2("field_mask", {
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common2.get = function get3(file) {
      return common2[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common2();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src2();
  }
});

// node_modules/uint8arrays/esm/src/concat.js
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat4
});
function concat4(arrays, length23) {
  if (!length23) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "node_modules/it-drain/index.js"(exports2, module2) {
    "use strict";
    var drain14 = async (source) => {
      for await (const _ of source) {
      }
    };
    module2.exports = drain14;
  }
});

// node_modules/is-domain-name/index.js
var require_is_domain_name = __commonJS({
  "node_modules/is-domain-name/index.js"(exports2, module2) {
    "use strict";
    var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
    module2.exports = function isDomainName(domainName, rootDot) {
      if (rootDot == null)
        rootDot = false;
      if (domainName.length < 2)
        return false;
      if (domainName.length > 255)
        return false;
      var lastChar = domainName[domainName.length - 1];
      if (rootDot) {
        if (lastChar !== ".")
          return false;
      } else {
        if (lastChar === ".")
          return false;
      }
      return domainNameRegex.test(domainName);
    };
  }
});

// node_modules/it-parallel/node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/it-parallel/node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    var pDefer2 = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve7, reject) => {
        deferred.resolve = resolve7;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer2;
  }
});

// node_modules/it-parallel/index.js
var require_it_parallel = __commonJS({
  "node_modules/it-parallel/index.js"(exports2, module2) {
    "use strict";
    var defer = require_p_defer();
    var CustomEvent2 = globalThis.CustomEvent || Event;
    async function* parallel5(source, options = {}) {
      let concurrency = options.concurrency || Infinity;
      if (concurrency < 1) {
        concurrency = Infinity;
      }
      const ordered = options.ordered == null ? false : options.ordered;
      const emitter = new EventTarget();
      const ops = [];
      let slotAvailable = defer();
      let resultAvailable = defer();
      let sourceFinished = false;
      let sourceErr;
      let opErred = false;
      emitter.addEventListener("task-complete", () => {
        resultAvailable.resolve();
      });
      Promise.resolve().then(async () => {
        try {
          for await (const task of source) {
            if (ops.length === concurrency) {
              slotAvailable = defer();
              await slotAvailable.promise;
            }
            if (opErred) {
              break;
            }
            const op = {
              done: false
            };
            ops.push(op);
            task().then((result) => {
              op.done = true;
              op.ok = true;
              op.value = result;
              emitter.dispatchEvent(new CustomEvent2("task-complete"));
            }, (err2) => {
              op.done = true;
              op.err = err2;
              emitter.dispatchEvent(new CustomEvent2("task-complete"));
            });
          }
          sourceFinished = true;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        } catch (err2) {
          sourceErr = err2;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }
      });
      function valuesAvailable() {
        if (ordered) {
          return Boolean(ops[0] && ops[0].done);
        }
        return Boolean(ops.find((op) => op.done));
      }
      function* yieldOrderedValues() {
        while (ops.length && ops[0].done) {
          const op = ops[0];
          ops.shift();
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
      function* yieldUnOrderedValues() {
        while (valuesAvailable()) {
          for (let i2 = 0; i2 < ops.length; i2++) {
            if (ops[i2].done) {
              const op = ops[i2];
              ops.splice(i2, 1);
              i2--;
              if (op.ok) {
                yield op.value;
              } else {
                opErred = true;
                slotAvailable.resolve();
                throw op.err;
              }
              slotAvailable.resolve();
            }
          }
        }
      }
      while (true) {
        if (!valuesAvailable()) {
          resultAvailable = defer();
          await resultAvailable.promise;
        }
        if (sourceErr) {
          throw sourceErr;
        }
        if (ordered) {
          yield* yieldOrderedValues();
        } else {
          yield* yieldUnOrderedValues();
        }
        if (sourceFinished && ops.length === 0) {
          break;
        }
      }
    }
    module2.exports = parallel5;
  }
});

// node_modules/it-map/index.js
var require_it_map = __commonJS({
  "node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    var map19 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module2.exports = map19;
  }
});

// node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "node_modules/it-filter/index.js"(exports2, module2) {
    "use strict";
    var filter14 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module2.exports = filter14;
  }
});

// node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "node_modules/blob-to-it/index.js"(exports2, module2) {
    "use strict";
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module2.exports = blobToIt2;
  }
});

// node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "node_modules/it-peekable/index.js"(exports2, module2) {
    "use strict";
    function peekableIterator(iterable) {
      const [iterator, symbol7] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value2) => {
          queue.push(value2);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol7]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "node_modules/it-batch/index.js"(exports2, module2) {
    "use strict";
    async function* batch3(source, size = 1) {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      for await (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    module2.exports = batch3;
  }
});

// node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "node_modules/it-parallel-batch/index.js"(exports2, module2) {
    "use strict";
    var batch3 = require_it_batch();
    async function* parallelBatch4(source, size = 1) {
      for await (const tasks of batch3(source, size)) {
        const things = tasks.map(
          (p) => {
            return p().then((value2) => ({ ok: true, value: value2 }), (err2) => ({ ok: false, err: err2 }));
          }
        );
        for (let i2 = 0; i2 < things.length; i2++) {
          const result = await things[i2];
          if (result.ok) {
            yield result.value;
          } else {
            throw result.err;
          }
        }
      }
    }
    module2.exports = parallelBatch4;
  }
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i2 = 0; i2 < bytes2.length; i2++) {
          if (!Number.isInteger(bytes2[i2]) || bytes2[i2] < 0 || bytes2[i2] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed2;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
          k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i2 + 2] << 16;
          case 2:
            k1 ^= bytes2[i2 + 1] << 8;
          case 1:
            k1 ^= bytes2[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed2;
        var h2 = seed2;
        var h3 = seed2;
        var h4 = seed2;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
          k2 = bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24;
          k3 = bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24;
          k4 = bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i2 + 14] << 16;
          case 14:
            k4 ^= bytes2[i2 + 13] << 8;
          case 13:
            k4 ^= bytes2[i2 + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i2 + 11] << 24;
          case 11:
            k3 ^= bytes2[i2 + 10] << 16;
          case 10:
            k3 ^= bytes2[i2 + 9] << 8;
          case 9:
            k3 ^= bytes2[i2 + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i2 + 7] << 24;
          case 7:
            k2 ^= bytes2[i2 + 6] << 16;
          case 6:
            k2 ^= bytes2[i2 + 5] << 8;
          case 5:
            k2 ^= bytes2[i2 + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i2 + 3] << 24;
          case 3:
            k1 ^= bytes2[i2 + 2] << 16;
          case 2:
            k1 ^= bytes2[i2 + 1] << 8;
          case 1:
            k1 ^= bytes2[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed2];
        var h2 = [0, seed2];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = [bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24, bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24];
          k2 = [bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24, bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i2 + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i2]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    module2.exports = require_murmurHash3js();
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength2;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup3 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code22 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code22.length; i2 < len; ++i2) {
      lookup3[i2] = code22[i2];
      revLookup[code22.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts2 = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts2.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 2] + lookup3[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 10] + lookup3[tmp >> 4 & 63] + lookup3[tmp << 2 & 63] + "="
        );
      }
      return parts2.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value2 += rt / c;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value2 * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base6416 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length23) {
      if (length23 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length23 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length23);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length23) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe19(arg);
      }
      return from33(arg, encodingOrOffset, length23);
    }
    Buffer2.poolSize = 8192;
    function from33(value2, encodingOrOffset, length23) {
      if (typeof value2 === "string") {
        return fromString27(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length23);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length23);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length23);
      }
      const b = fromObject(value2);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length23);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length23) {
      return from33(value2, encodingOrOffset, length23);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc3(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc3(size, fill, encoding);
    };
    function allocUnsafe19(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe19(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe19(size);
    };
    function fromString27(string14, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length23 = byteLength2(string14, encoding) | 0;
      let buf2 = createBuffer(length23);
      const actual = buf2.write(string14, encoding);
      if (actual !== length23) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length23 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length23);
      for (let i2 = 0; i2 < length23; i2 += 1) {
        buf2[i2] = array[i2] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length23) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length23 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length23 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length23 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length23);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length23) {
      if (length23 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length23 | 0;
    }
    function SlowBuffer(length23) {
      if (+length23 != length23) {
        length23 = 0;
      }
      return Buffer2.alloc(+length23);
    }
    Buffer2.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare4(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
        if (a[i2] !== b[i2]) {
          x = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat8(list, length23) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length23 === void 0) {
        length23 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length23 += list[i2].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length23);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf2 = list[i2];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2))
              buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength2(string14, encoding) {
      if (Buffer2.isBuffer(string14)) {
        return string14.length;
      }
      if (ArrayBuffer.isView(string14) || isInstance(string14, ArrayBuffer)) {
        return string14.byteLength;
      }
      if (typeof string14 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string14
        );
      }
      const len = string14.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string14).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string14).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string14).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i2 = b[n];
      b[n] = b[m];
      b[m] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString28() {
      const length23 = this.length;
      if (length23 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length23);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals41(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read19(buf2, i3) {
        if (indexSize === 1) {
          return buf2[i3];
        } else {
          return buf2.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read19(arr, i2) === read19(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read19(arr, i2 + j) !== read19(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string14, offset, length23) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length23) {
        length23 = remaining;
      } else {
        length23 = Number(length23);
        if (length23 > remaining) {
          length23 = remaining;
        }
      }
      const strLen = string14.length;
      if (length23 > strLen / 2) {
        length23 = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length23; ++i2) {
        const parsed = parseInt(string14.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf2[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf2, string14, offset, length23) {
      return blitBuffer(utf8ToBytes2(string14, buf2.length - offset), buf2, offset, length23);
    }
    function asciiWrite(buf2, string14, offset, length23) {
      return blitBuffer(asciiToBytes(string14), buf2, offset, length23);
    }
    function base64Write(buf2, string14, offset, length23) {
      return blitBuffer(base64ToBytes(string14), buf2, offset, length23);
    }
    function ucs2Write(buf2, string14, offset, length23) {
      return blitBuffer(utf16leToBytes(string14, buf2.length - offset), buf2, offset, length23);
    }
    Buffer2.prototype.write = function write3(string14, offset, length23, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length23 = this.length;
        offset = 0;
      } else if (length23 === void 0 && typeof offset === "string") {
        encoding = offset;
        length23 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length23)) {
          length23 = length23 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length23;
          length23 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length23 === void 0 || length23 > remaining)
        length23 = remaining;
      if (string14.length > 0 && (length23 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string14, offset, length23);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string14, offset, length23);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string14, offset, length23);
          case "base64":
            return base64Write(this, string14, offset, length23);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string14, offset, length23);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base6416.fromByteArray(buf2);
      } else {
        return base6416.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf2[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i2 + 1];
              thirdByte = buf2[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i2 + 1];
              thirdByte = buf2[i2 + 2];
              fourthByte = buf2[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf2[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf2[i2]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf2[i2]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes2 = buf2.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length23) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length23)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first10 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last14 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first10 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last14;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let i2 = byteLength3;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last14 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first10 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first10 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last14);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value2, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset, byteLength3, maxBytes, 0);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value2, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code22 = val.charCodeAt(0);
          if (encoding === "utf8" && code22 < 128 || encoding === "latin1") {
            val = code22;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes2.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes2[i2 % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name22) {
        if (name22) {
          return `${name22} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name22, actual) {
        return `The "${name22}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
        boundsError(offset, buf2.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value2, min, max, buf2, offset, byteLength3) {
      if (value2 > max || value2 < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength3 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value2);
      }
      checkBounds(buf2, offset, byteLength3);
    }
    function validateNumber(value2, name22) {
      if (typeof value2 !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name22, "number", value2);
      }
    }
    function boundsError(value2, length23, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
      }
      if (length23 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length23}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string14, units) {
      units = units || Infinity;
      let codePoint;
      const length23 = string14.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i2 = 0; i2 < length23; ++i2) {
        codePoint = string14.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length23) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base6416.toByteArray(base64clean(str));
    }
    function blitBuffer(src18, dst, offset, length23) {
      let i2;
      for (i2 = 0; i2 < length23; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src18.length)
          break;
        dst[i2 + offset] = src18[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet16 = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet16[i2] + alphabet16[j];
        }
      }
      return table2;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var symbol7 = Symbol.for("BufferList");
    function BufferList3(buf2) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf2);
      }
      BufferList3._init.call(this, buf2);
    }
    BufferList3._init = function _init(buf2) {
      Object.defineProperty(this, symbol7, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf2) {
        this.append(buf2);
      }
    };
    BufferList3.prototype._new = function _new(buf2) {
      return new BufferList3(buf2);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i2 = 0; i2 < this._bufs.length; i2++) {
        const _t = tot + this._bufs[i2].length;
        if (offset < _t || i2 === this._bufs.length - 1) {
          return [i2, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i2 = 0; i2 < bufferId; i2++) {
        offset += this._bufs[i2].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get3(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes2 = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i2 = 0; i2 < this._bufs.length; i2++) {
          this._bufs[i2].copy(dst, bufoff);
          bufoff += this._bufs[i2].length;
        }
        return dst;
      }
      if (bytes2 <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off[0]].slice(start, start + bytes2);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i2 = off[0]; i2 < this._bufs.length; i2++) {
        const l = this._bufs[i2].length - start;
        if (bytes2 > l) {
          this._bufs[i2].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i2].copy(dst, bufoff, start, start + bytes2);
          bufoff += l;
          break;
        }
        bytes2 -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString28(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes2 >= this._bufs[0].length) {
          bytes2 -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes2);
          this.length -= bytes2;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i2 = 0; i2 < this._bufs.length; i2++) {
        copy.append(this._bufs[i2]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf2) {
      if (buf2 == null) {
        return this;
      }
      if (buf2.buffer) {
        this._appendBuffer(Buffer2.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      } else if (Array.isArray(buf2)) {
        for (let i2 = 0; i2 < buf2.length; i2++) {
          this.append(buf2[i2]);
        }
      } else if (this._isBufferList(buf2)) {
        for (let i2 = 0; i2 < buf2._bufs.length; i2++) {
          this.append(buf2._bufs[i2]);
        }
      } else {
        if (typeof buf2 === "number") {
          buf2 = buf2.toString();
        }
        this._appendBuffer(Buffer2.from(buf2));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
      this._bufs.push(buf2);
      this.length += buf2.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods7 = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods7) {
        (function(m2) {
          if (methods7[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength2) {
              return this.slice(offset, offset + byteLength2)[m2](0, byteLength2);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods7[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol7];
    };
    module2.exports = BufferList3;
  }
});

// node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    var Rabin = class {
      constructor(asModule, bits2 = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits2;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits2, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});

// node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "node_modules/@assemblyscript/loader/index.js"(exports2) {
    "use strict";
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length23 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length23 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length23));
      const parts2 = [];
      do {
        const last14 = U16[offset + CHUNKSIZE - 1];
        const size = last14 >= 55296 && last14 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts2.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length23 -= size;
      } while (length23 > CHUNKSIZE);
      return parts2.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length23));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table2 = rawExports.table;
      const alloc3 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length23 = str.length;
        const ptr = alloc3(length23 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i2 = 0, p = ptr >>> 1; i2 < length23; ++i2)
          U16[p + i2] = str.charCodeAt(i2);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer2 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length23 = values.length;
        const buf2 = alloc3(length23 << align, ARRAYBUFFER_ID);
        const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length23 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length23;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i2 = 0; i2 < length23; ++i2)
            view[(buf2 >>> align) + i2] = retain(values[i2]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length23 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length23);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i2 = 0; i2 < len; i2++)
          out[i2] = input[i2];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length23 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length23);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table2;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    async function instantiate(source, imports) {
      if (isResponse(source = await source))
        return instantiateStreaming(source, imports);
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        await WebAssembly.instantiate(
          source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
          imports
        )
      );
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        new WebAssembly.Instance(
          source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
          imports
        )
      );
    }
    exports2.instantiateSync = instantiateSync;
    async function instantiateStreaming(source, imports) {
      if (!WebAssembly.instantiateStreaming) {
        return instantiate(
          isResponse(source = await source) ? source.arrayBuffer() : source,
          imports
        );
      }
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        (await WebAssembly.instantiateStreaming(source, imports)).instance
      );
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length23) {
        exports3["__argumentsLength"].value = length23;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts2 = internalName.split(".");
        let curr = module3;
        while (parts2.length > 1) {
          let part = parts2.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name22 = parts2[0];
        let hash3 = name22.indexOf("#");
        if (hash3 >= 0) {
          let className = name22.substring(0, hash3);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach(
                (name23) => Object.defineProperty(ctor, name23, Object.getOwnPropertyDescriptor(classElem, name23))
              );
            curr[className] = ctor;
          }
          name22 = name22.substring(hash3 + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name22)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name22 = name22.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name22, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value2) {
                  setter(this[THIS], value2);
                },
                enumerable: true
              });
            }
          } else {
            if (name22 === "constructor") {
              (curr[name22] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name22] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name22)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name22 = name22.substring(4))) {
              Object.defineProperty(curr, name22, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name22] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name22] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});

// node_modules/rabin-wasm/dist/rabin-wasm.js
var require_rabin_wasm = __commonJS({
  "node_modules/rabin-wasm/dist/rabin-wasm.js"(exports2, module2) {
    var { instantiate } = require_loader();
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(imp = {}) {
      if (!loadWebAssembly.supported)
        return null;
      var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
      return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
    }
    module2.exports = loadWebAssembly;
  }
});

// node_modules/rabin-wasm/src/index.js
var require_src3 = __commonJS({
  "node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm();
    var create26 = async (avg, min, max, windowSize, polynomial) => {
      const compiled = await getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    };
    module2.exports = {
      Rabin,
      create: create26
    };
  }
});

// node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value2) {
        let pos = this._internalPositionFor(index, false);
        if (value2 === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value2, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value2) {
        this.set(this.length, value2);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last14 = this._data[this._data.length - 1];
          this._length = last14 ? last14[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i2 = 0;
        while (i2 < this.length) {
          iterator(this.get(i2), i2, this);
          i2++;
        }
      }
      map(iterator) {
        let i2 = 0;
        let mapped = new Array(this.length);
        while (i2 < this.length) {
          mapped[i2] = iterator(this.get(i2), i2, this);
          i2++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i2 = 0;
        let acc = initialValue;
        while (i2 < this.length) {
          const value2 = this.get(i2);
          acc = reducer(acc, value2, i2);
          i2++;
        }
        return acc;
      }
      find(finder) {
        let i2 = 0, found, last14;
        while (i2 < this.length && !found) {
          last14 = this.get(i2);
          found = finder(last14);
          i2++;
        }
        return found ? last14 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists2 = (byte & 1 << bitPos) > 0;
        if (!exists2) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value2, needsSort) {
        const data = this._data;
        const elem = [index, value2];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes2 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes2.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
          const value2 = bytes2[i2];
          if (value2 === 0) {
            bytes2.pop();
          } else {
            break;
          }
        }
        return bytes2;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// node_modules/iso-constants/index.browser.js
var require_index_browser = __commonJS({
  "node_modules/iso-constants/index.browser.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 100,
      "EADDRNOTAVAIL": 101,
      "EAFNOSUPPORT": 102,
      "EAGAIN": 11,
      "EALREADY": 103,
      "EBADF": 9,
      "EBADMSG": 104,
      "EBUSY": 16,
      "ECANCELED": 105,
      "ECHILD": 10,
      "ECONNABORTED": 106,
      "ECONNREFUSED": 107,
      "ECONNRESET": 108,
      "EDEADLK": 36,
      "EDESTADDRREQ": 109,
      "EDOM": 33,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 110,
      "EIDRM": 111,
      "EILSEQ": 42,
      "EINPROGRESS": 112,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 113,
      "EISDIR": 21,
      "ELOOP": 114,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 115,
      "ENAMETOOLONG": 38,
      "ENETDOWN": 116,
      "ENETRESET": 117,
      "ENETUNREACH": 118,
      "ENFILE": 23,
      "ENOBUFS": 119,
      "ENODATA": 120,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 39,
      "ENOLINK": 121,
      "ENOMEM": 12,
      "ENOMSG": 122,
      "ENOPROTOOPT": 123,
      "ENOSPC": 28,
      "ENOSR": 124,
      "ENOSTR": 125,
      "ENOSYS": 40,
      "ENOTCONN": 126,
      "ENOTDIR": 20,
      "ENOTEMPTY": 41,
      "ENOTSOCK": 128,
      "ENOTSUP": 129,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 130,
      "EOVERFLOW": 132,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 134,
      "EPROTONOSUPPORT": 135,
      "EPROTOTYPE": 136,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ETIME": 137,
      "ETIMEDOUT": 138,
      "ETXTBSY": 139,
      "EWOULDBLOCK": 140,
      "EXDEV": 18,
      "WSAEINTR": 10004,
      "WSAEBADF": 10009,
      "WSAEACCES": 10013,
      "WSAEFAULT": 10014,
      "WSAEINVAL": 10022,
      "WSAEMFILE": 10024,
      "WSAEWOULDBLOCK": 10035,
      "WSAEINPROGRESS": 10036,
      "WSAEALREADY": 10037,
      "WSAENOTSOCK": 10038,
      "WSAEDESTADDRREQ": 10039,
      "WSAEMSGSIZE": 10040,
      "WSAEPROTOTYPE": 10041,
      "WSAENOPROTOOPT": 10042,
      "WSAEPROTONOSUPPORT": 10043,
      "WSAESOCKTNOSUPPORT": 10044,
      "WSAEOPNOTSUPP": 10045,
      "WSAEPFNOSUPPORT": 10046,
      "WSAEAFNOSUPPORT": 10047,
      "WSAEADDRINUSE": 10048,
      "WSAEADDRNOTAVAIL": 10049,
      "WSAENETDOWN": 10050,
      "WSAENETUNREACH": 10051,
      "WSAENETRESET": 10052,
      "WSAECONNABORTED": 10053,
      "WSAECONNRESET": 10054,
      "WSAENOBUFS": 10055,
      "WSAEISCONN": 10056,
      "WSAENOTCONN": 10057,
      "WSAESHUTDOWN": 10058,
      "WSAETOOMANYREFS": 10059,
      "WSAETIMEDOUT": 10060,
      "WSAECONNREFUSED": 10061,
      "WSAELOOP": 10062,
      "WSAENAMETOOLONG": 10063,
      "WSAEHOSTDOWN": 10064,
      "WSAEHOSTUNREACH": 10065,
      "WSAENOTEMPTY": 10066,
      "WSAEPROCLIM": 10067,
      "WSAEUSERS": 10068,
      "WSAEDQUOT": 10069,
      "WSAESTALE": 10070,
      "WSAEREMOTE": 10071,
      "WSASYSNOTREADY": 10091,
      "WSAVERNOTSUPPORTED": 10092,
      "WSANOTINITIALISED": 10093,
      "WSAEDISCON": 10101,
      "WSAENOMORE": 10102,
      "WSAECANCELLED": 10103,
      "WSAEINVALIDPROCTABLE": 10104,
      "WSAEINVALIDPROVIDER": 10105,
      "WSAEPROVIDERFAILEDINIT": 10106,
      "WSASYSCALLFAILURE": 10107,
      "WSASERVICE_NOT_FOUND": 10108,
      "WSATYPE_NOT_FOUND": 10109,
      "WSA_E_NO_MORE": 10110,
      "WSA_E_CANCELLED": 10111,
      "WSAEREFUSED": 10112,
      "PRIORITY_LOW": 19,
      "PRIORITY_BELOW_NORMAL": 10,
      "PRIORITY_NORMAL": 0,
      "PRIORITY_ABOVE_NORMAL": -7,
      "PRIORITY_HIGH": -14,
      "PRIORITY_HIGHEST": -20,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGILL": 4,
      "SIGABRT": 22,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGSEGV": 11,
      "SIGTERM": 15,
      "SIGBREAK": 21,
      "SIGWINCH": 28,
      "UV_FS_SYMLINK_DIR": 1,
      "UV_FS_SYMLINK_JUNCTION": 2,
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "UV_DIRENT_UNKNOWN": 0,
      "UV_DIRENT_FILE": 1,
      "UV_DIRENT_DIR": 2,
      "UV_DIRENT_LINK": 3,
      "UV_DIRENT_FIFO": 4,
      "UV_DIRENT_SOCKET": 5,
      "UV_DIRENT_CHAR": 6,
      "UV_DIRENT_BLOCK": 7,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFLNK": 40960,
      "O_CREAT": 256,
      "O_EXCL": 1024,
      "UV_FS_O_FILEMAP": 536870912,
      "O_TRUNC": 512,
      "O_APPEND": 8,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_FS_COPYFILE_EXCL": 1,
      "COPYFILE_EXCL": 1,
      "UV_FS_COPYFILE_FICLONE": 2,
      "COPYFILE_FICLONE": 2,
      "UV_FS_COPYFILE_FICLONE_FORCE": 4,
      "COPYFILE_FICLONE_FORCE": 4,
      "OPENSSL_VERSION_NUMBER": 269488367,
      "SSL_OP_ALL": 2147485780,
      "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_RENEGOTIATION": 1073741824,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 0,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_NO_TLSv1_3": 536870912,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_PRIORITIZE_CHACHA": 2097152,
      "SSL_OP_SINGLE_DH_USE": 0,
      "SSL_OP_SINGLE_ECDH_USE": 0,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
      "SSL_OP_TLS_D5_BUG": 0,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_RSA": 1,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_EC": 2048,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "RSA_PSS_SALTLEN_DIGEST": -1,
      "RSA_PSS_SALTLEN_MAX_SIGN": -2,
      "RSA_PSS_SALTLEN_AUTO": -2,
      "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      "TLS1_VERSION": 769,
      "TLS1_1_VERSION": 770,
      "TLS1_2_VERSION": 771,
      "TLS1_3_VERSION": 772,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6
    };
  }
});

// node_modules/it-to-buffer/index.js
var require_it_to_buffer = __commonJS({
  "node_modules/it-to-buffer/index.js"(exports2, module2) {
    "use strict";
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    async function toBuffer3(stream) {
      let buffer2 = new Uint8Array(0);
      for await (const buf2 of stream) {
        buffer2 = uint8ArrayConcat([buffer2, buf2], buffer2.length + buf2.length);
      }
      return buffer2;
    }
    module2.exports = toBuffer3;
  }
});

// node_modules/it-first/index.js
var require_it_first = __commonJS({
  "node_modules/it-first/index.js"(exports2, module2) {
    "use strict";
    var first10 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module2.exports = first10;
  }
});

// node_modules/it-length/index.js
var require_it_length = __commonJS({
  "node_modules/it-length/index.js"(exports2, module2) {
    "use strict";
    var length23 = async (iterator) => {
      let count = 0;
      for await (const _ of iterator) {
        count++;
      }
      return count;
    };
    module2.exports = length23;
  }
});

// node_modules/fnv1a/index.js
var require_fnv1a = __commonJS({
  "node_modules/fnv1a/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    hash3.BASE = 2166136261;
    function hash3(s, h = hash3.BASE) {
      const l = s.length;
      for (let i2 = 0; i2 < l; i2++) {
        h ^= s.charCodeAt(i2);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    exports2.default = hash3;
    module2.exports = hash3;
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format16;
    module2.exports.parse = parse4;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map19 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value2, options) {
      if (typeof value2 === "string") {
        return parse4(value2);
      }
      if (typeof value2 === "number") {
        return format16(value2, options);
      }
      return null;
    }
    function format16(value2, options) {
      if (!Number.isFinite(value2)) {
        return null;
      }
      var mag = Math.abs(value2);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map19[unit.toLowerCase()]) {
        if (mag >= map19.pb) {
          unit = "PB";
        } else if (mag >= map19.tb) {
          unit = "TB";
        } else if (mag >= map19.gb) {
          unit = "GB";
        } else if (mag >= map19.mb) {
          unit = "MB";
        } else if (mag >= map19.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value2 / map19[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i2) {
          return i2 === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse4(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map19[unit] * floatValue);
    }
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last14 = this.buffer[this.btm];
        if (last14 === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last14;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    var FixedFIFO2 = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO2(this.hwm);
        this.tail = this.head;
      }
      push(val) {
        if (!this.head.push(val)) {
          const prev2 = this.head;
          this.head = prev2.next = new FixedFIFO2(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        return this.tail.peek();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});

// node_modules/it-merge/node_modules/it-pushable/index.js
var require_it_pushable = __commonJS({
  "node_modules/it-merge/node_modules/it-pushable/index.js"(exports2, module2) {
    var FIFO3 = require_fast_fifo();
    module2.exports = (options) => {
      options = options || {};
      let onEnd;
      if (typeof options === "function") {
        onEnd = options;
        options = {};
      } else {
        onEnd = options.onEnd;
      }
      let buffer2 = new FIFO3();
      let pushable2, onNext, ended;
      const waitNext = () => {
        if (!buffer2.isEmpty()) {
          if (options.writev) {
            let next2;
            const values = [];
            while (!buffer2.isEmpty()) {
              next2 = buffer2.shift();
              if (next2.error)
                throw next2.error;
              values.push(next2.value);
            }
            return { done: next2.done, value: values };
          }
          const next = buffer2.shift();
          if (next.error)
            throw next.error;
          return next;
        }
        if (ended)
          return { done: true };
        return new Promise((resolve7, reject) => {
          onNext = (next) => {
            onNext = null;
            if (next.error) {
              reject(next.error);
            } else {
              if (options.writev && !next.done) {
                resolve7({ done: next.done, value: [next.value] });
              } else {
                resolve7(next);
              }
            }
            return pushable2;
          };
        });
      };
      const bufferNext = (next) => {
        if (onNext)
          return onNext(next);
        buffer2.push(next);
        return pushable2;
      };
      const bufferError = (err2) => {
        buffer2 = new FIFO3();
        if (onNext)
          return onNext({ error: err2 });
        buffer2.push({ error: err2 });
        return pushable2;
      };
      const push = (value2) => {
        if (ended)
          return pushable2;
        return bufferNext({ done: false, value: value2 });
      };
      const end = (err2) => {
        if (ended)
          return pushable2;
        ended = true;
        return err2 ? bufferError(err2) : bufferNext({ done: true });
      };
      const _return = () => {
        buffer2 = new FIFO3();
        end();
        return { done: true };
      };
      const _throw = (err2) => {
        end(err2);
        return { done: true };
      };
      pushable2 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: waitNext,
        return: _return,
        throw: _throw,
        push,
        end
      };
      if (!onEnd)
        return pushable2;
      const _pushable2 = pushable2;
      pushable2 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return _pushable2.next();
        },
        throw(err2) {
          _pushable2.throw(err2);
          if (onEnd) {
            onEnd(err2);
            onEnd = null;
          }
          return { done: true };
        },
        return() {
          _pushable2.return();
          if (onEnd) {
            onEnd();
            onEnd = null;
          }
          return { done: true };
        },
        push,
        end(err2) {
          _pushable2.end(err2);
          if (onEnd) {
            onEnd(err2);
            onEnd = null;
          }
          return pushable2;
        }
      };
      return pushable2;
    };
  }
});

// node_modules/it-merge/index.js
var require_it_merge = __commonJS({
  "node_modules/it-merge/index.js"(exports2, module2) {
    "use strict";
    var pushable2 = require_it_pushable();
    var merge11 = async function* (...sources) {
      const output = pushable2();
      setTimeout(async () => {
        try {
          await Promise.all(
            sources.map(async (source) => {
              for await (const item of source) {
                output.push(item);
              }
            })
          );
          output.end();
        } catch (err2) {
          output.end(err2);
        }
      }, 0);
      yield* output;
    };
    module2.exports = merge11;
  }
});

// node_modules/level-supports/index.js
var require_level_supports = __commonJS({
  "node_modules/level-supports/index.js"(exports2) {
    "use strict";
    exports2.supports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: Object.assign({}, manifest.encodings),
        events: Object.assign({}, manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
  }
});

// node_modules/module-error/index.js
var require_module_error = __commonJS({
  "node_modules/module-error/index.js"(exports2, module2) {
    "use strict";
    module2.exports = class ModuleError extends Error {
      constructor(message6, options) {
        super(message6 || "");
        if (typeof options === "object" && options !== null) {
          if (options.code)
            this.code = String(options.code);
          if (options.expected)
            this.expected = true;
          if (options.transient)
            this.transient = true;
          if (options.cause)
            this.cause = options.cause;
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
  }
});

// node_modules/level-transcoder/lib/text-endec.js
var require_text_endec = __commonJS({
  "node_modules/level-transcoder/lib/text-endec.js"(exports2, module2) {
    "use strict";
    var lazy = null;
    module2.exports = function() {
      if (lazy === null) {
        lazy = {
          textEncoder: new TextEncoder(),
          textDecoder: new TextDecoder()
        };
      }
      return lazy;
    };
  }
});

// node_modules/level-transcoder/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/level-transcoder/lib/encoding.js"(exports2) {
    "use strict";
    var ModuleError = require_module_error();
    var formats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Encoding = class {
      constructor(options) {
        this.encode = options.encode || this.encode;
        this.decode = options.decode || this.decode;
        this.name = options.name || this.name;
        this.format = options.format || this.format;
        if (typeof this.encode !== "function") {
          throw new TypeError("The 'encode' property must be a function");
        }
        if (typeof this.decode !== "function") {
          throw new TypeError("The 'decode' property must be a function");
        }
        this.encode = this.encode.bind(this);
        this.decode = this.decode.bind(this);
        if (typeof this.name !== "string" || this.name === "") {
          throw new TypeError("The 'name' property must be a string");
        }
        if (typeof this.format !== "string" || !formats.has(this.format)) {
          throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
        }
        if (options.createViewTranscoder) {
          this.createViewTranscoder = options.createViewTranscoder;
        }
        if (options.createBufferTranscoder) {
          this.createBufferTranscoder = options.createBufferTranscoder;
        }
        if (options.createUTF8Transcoder) {
          this.createUTF8Transcoder = options.createUTF8Transcoder;
        }
      }
      get commonName() {
        return this.name.split("+")[0];
      }
      createBufferTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      createViewTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      createUTF8Transcoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
    };
    exports2.Encoding = Encoding;
  }
});

// node_modules/level-transcoder/lib/formats.js
var require_formats = __commonJS({
  "node_modules/level-transcoder/lib/formats.js"(exports2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer() || {};
    var { Encoding } = require_encoding();
    var textEndec = require_text_endec();
    var BufferFormat = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "buffer" });
      }
      createViewTranscoder() {
        return new ViewFormat({
          encode: this.encode,
          decode: (data) => this.decode(
            Buffer2.from(data.buffer, data.byteOffset, data.byteLength)
          ),
          name: `${this.name}+view`
        });
      }
      createBufferTranscoder() {
        return this;
      }
    };
    var ViewFormat = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "view" });
      }
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => {
            const view = this.encode(data);
            return Buffer2.from(view.buffer, view.byteOffset, view.byteLength);
          },
          decode: this.decode,
          name: `${this.name}+buffer`
        });
      }
      createViewTranscoder() {
        return this;
      }
    };
    var UTF8Format = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "utf8" });
      }
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => Buffer2.from(this.encode(data), "utf8"),
          decode: (data) => this.decode(data.toString("utf8")),
          name: `${this.name}+buffer`
        });
      }
      createViewTranscoder() {
        const { textEncoder: textEncoder18, textDecoder: textDecoder17 } = textEndec();
        return new ViewFormat({
          encode: (data) => textEncoder18.encode(this.encode(data)),
          decode: (data) => this.decode(textDecoder17.decode(data)),
          name: `${this.name}+view`
        });
      }
      createUTF8Transcoder() {
        return this;
      }
    };
    exports2.BufferFormat = BufferFormat;
    exports2.ViewFormat = ViewFormat;
    exports2.UTF8Format = UTF8Format;
  }
});

// node_modules/level-transcoder/lib/encodings.js
var require_encodings = __commonJS({
  "node_modules/level-transcoder/lib/encodings.js"(exports2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer() || { Buffer: { isBuffer: () => false } };
    var { textEncoder: textEncoder18, textDecoder: textDecoder17 } = require_text_endec()();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var identity29 = (v) => v;
    exports2.utf8 = new UTF8Format({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder17.decode(data) : String(data);
      },
      decode: identity29,
      name: "utf8",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : textEncoder18.encode(data);
          },
          decode: function(data) {
            return textDecoder17.decode(data);
          },
          name: `${this.name}+view`
        });
      },
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return data.toString("utf8");
          },
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.json = new UTF8Format({
      encode: JSON.stringify,
      decode: JSON.parse,
      name: "json"
    });
    exports2.buffer = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
      },
      decode: identity29,
      name: "buffer",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          },
          name: `${this.name}+view`
        });
      }
    });
    exports2.view = new ViewFormat({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder18.encode(data);
      },
      decode: identity29,
      name: "view",
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: identity29,
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.hex = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "hex");
      },
      decode: function(buffer2) {
        return buffer2.toString("hex");
      },
      name: "hex"
    });
    exports2.base64 = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "base64");
      },
      decode: function(buffer2) {
        return buffer2.toString("base64");
      },
      name: "base64"
    });
  }
});

// node_modules/level-transcoder/index.js
var require_level_transcoder = __commonJS({
  "node_modules/level-transcoder/index.js"(exports2) {
    "use strict";
    var ModuleError = require_module_error();
    var encodings = require_encodings();
    var { Encoding } = require_encoding();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var kFormats = Symbol("formats");
    var kEncodings = Symbol("encodings");
    var validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Transcoder = class {
      constructor(formats) {
        if (!Array.isArray(formats)) {
          throw new TypeError("The first argument 'formats' must be an array");
        } else if (!formats.every((f) => validFormats.has(f))) {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
        this[kEncodings] = /* @__PURE__ */ new Map();
        this[kFormats] = new Set(formats);
        for (const k in encodings) {
          try {
            this.encoding(k);
          } catch (err2) {
            if (err2.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
              throw err2;
          }
        }
      }
      encodings() {
        return Array.from(new Set(this[kEncodings].values()));
      }
      encoding(encoding) {
        let resolved = this[kEncodings].get(encoding);
        if (resolved === void 0) {
          if (typeof encoding === "string" && encoding !== "") {
            resolved = lookup3[encoding];
            if (!resolved) {
              throw new ModuleError(`Encoding '${encoding}' is not found`, {
                code: "LEVEL_ENCODING_NOT_FOUND"
              });
            }
          } else if (typeof encoding !== "object" || encoding === null) {
            throw new TypeError("First argument 'encoding' must be a string or object");
          } else {
            resolved = from33(encoding);
          }
          const { name: name22, format: format16 } = resolved;
          if (!this[kFormats].has(format16)) {
            if (this[kFormats].has("view")) {
              resolved = resolved.createViewTranscoder();
            } else if (this[kFormats].has("buffer")) {
              resolved = resolved.createBufferTranscoder();
            } else if (this[kFormats].has("utf8")) {
              resolved = resolved.createUTF8Transcoder();
            } else {
              throw new ModuleError(`Encoding '${name22}' cannot be transcoded`, {
                code: "LEVEL_ENCODING_NOT_SUPPORTED"
              });
            }
          }
          for (const k of [encoding, name22, resolved.name, resolved.commonName]) {
            this[kEncodings].set(k, resolved);
          }
        }
        return resolved;
      }
    };
    exports2.Transcoder = Transcoder;
    function from33(options) {
      if (options instanceof Encoding) {
        return options;
      }
      const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
      const name22 = options.name || maybeType || `anonymous-${anonymousCount++}`;
      switch (detectFormat(options)) {
        case "view":
          return new ViewFormat({ ...options, name: name22 });
        case "utf8":
          return new UTF8Format({ ...options, name: name22 });
        case "buffer":
          return new BufferFormat({ ...options, name: name22 });
        default: {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
      }
    }
    function detectFormat(options) {
      if ("format" in options && options.format !== void 0) {
        return options.format;
      } else if ("buffer" in options && typeof options.buffer === "boolean") {
        return options.buffer ? "buffer" : "utf8";
      } else if ("code" in options && Number.isInteger(options.code)) {
        return "view";
      } else {
        return "buffer";
      }
    }
    var aliases = {
      binary: encodings.buffer,
      "utf-8": encodings.utf8
    };
    var lookup3 = {
      ...encodings,
      ...aliases
    };
    var anonymousCount = 0;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter6() {
      EventEmitter6.init.call(this);
    }
    module2.exports = EventEmitter6;
    module2.exports.once = once;
    EventEmitter6.EventEmitter = EventEmitter6;
    EventEmitter6.prototype._events = void 0;
    EventEmitter6.prototype._eventsCount = 0;
    EventEmitter6.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter6, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter6.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter6.prototype.setMaxListeners = function setMaxListeners13(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter6.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter6.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter6.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter6.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter6.prototype.on = EventEmitter6.prototype.addListener;
    EventEmitter6.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter6.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i2, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i2;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap3) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter6.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter6.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter6.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter6.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i2 = 0; i2 < n; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name22) {
      return new Promise(function(resolve7, reject) {
        function errorListener(err2) {
          emitter.removeListener(name22, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve7([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name22, resolver, { once: true });
        if (name22 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name22, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name22, listener);
        } else {
          emitter.on(name22, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name22, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name22, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/catering/next-tick-browser.js
var require_next_tick_browser = __commonJS({
  "node_modules/catering/next-tick-browser.js"(exports2, module2) {
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// node_modules/catering/index.js
var require_catering = __commonJS({
  "node_modules/catering/index.js"(exports2) {
    "use strict";
    var nextTick2 = require_next_tick_browser();
    exports2.fromCallback = function(callback, symbol7) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve7, reject) {
          callback = function(err2, res) {
            if (err2)
              reject(err2);
            else
              resolve7(res);
          };
        });
        callback[symbol7 !== void 0 ? symbol7 : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports2.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        nextTick2(() => callback(null, res));
      }).catch(function(err2) {
        nextTick2(() => callback(err2));
      });
    };
  }
});

// node_modules/abstract-level/lib/common.js
var require_common3 = __commonJS({
  "node_modules/abstract-level/lib/common.js"(exports2) {
    "use strict";
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options, def2) {
      if (typeof options === "object" && options !== null) {
        return options;
      }
      if (def2 !== void 0) {
        return def2;
      }
      return {};
    };
  }
});

// node_modules/abstract-level/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-level/abstract-iterator.js"(exports2) {
    "use strict";
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getOptions, getCallback } = require_common3();
    var kPromise = Symbol("promise");
    var kCallback = Symbol("callback");
    var kWorking = Symbol("working");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kAutoClose = Symbol("autoClose");
    var kFinishWork = Symbol("finishWork");
    var kReturnMany = Symbol("returnMany");
    var kClosing = Symbol("closing");
    var kHandleClose = Symbol("handleClose");
    var kClosed = Symbol("closed");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var kAbortOnClose = Symbol("abortOnClose");
    var kLegacy = Symbol("legacy");
    var kKeys = Symbol("keys");
    var kValues = Symbol("values");
    var kLimit = Symbol("limit");
    var kCount = Symbol("count");
    var emptyOptions = Object.freeze({});
    var noop5 = () => {
    };
    var warnedEnd = false;
    var CommonIterator = class {
      constructor(db, options, legacy) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError("The second argument must be an options object");
        }
        this[kClosed] = false;
        this[kCloseCallbacks] = [];
        this[kWorking] = false;
        this[kClosing] = false;
        this[kAutoClose] = false;
        this[kCallback] = null;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kHandleClose] = this[kHandleClose].bind(this);
        this[kKeyEncoding] = options[kKeyEncoding];
        this[kValueEncoding] = options[kValueEncoding];
        this[kLegacy] = legacy;
        this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
        this[kCount] = 0;
        this[kAbortOnClose] = !!options.abortOnClose;
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get count() {
        return this[kCount];
      }
      get limit() {
        return this[kLimit];
      }
      next(callback) {
        let promise;
        if (callback === void 0) {
          promise = new Promise((resolve7, reject) => {
            callback = (err2, key, value2) => {
              if (err2)
                reject(err2);
              else if (!this[kLegacy])
                resolve7(key);
              else if (key === void 0 && value2 === void 0)
                resolve7();
              else
                resolve7([key, value2]);
            };
          });
        } else if (typeof callback !== "function") {
          throw new TypeError("Callback must be a function");
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call next() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleOne], null);
          else
            this._next(this[kHandleOne]);
        }
        return promise;
      }
      _next(callback) {
        this.nextTick(callback);
      }
      nextv(size, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (!Number.isInteger(size)) {
          this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
          return callback[kPromise];
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call nextv() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          if (size < 1)
            size = 1;
          if (this[kLimit] < Infinity)
            size = Math.min(size, this[kLimit] - this[kCount]);
          this[kWorking] = true;
          this[kCallback] = callback;
          if (size <= 0)
            this.nextTick(this[kHandleMany], null, []);
          else
            this._nextv(size, options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _nextv(size, options, callback) {
        const acc = [];
        const onnext = (err2, key, value2) => {
          if (err2) {
            return callback(err2);
          } else if (this[kLegacy] ? key === void 0 && value2 === void 0 : key === void 0) {
            return callback(null, acc);
          }
          acc.push(this[kLegacy] ? [key, value2] : key);
          if (acc.length === size) {
            callback(null, acc);
          } else {
            this._next(onnext);
          }
        };
        this._next(onnext);
      }
      all(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call all() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          this[kAutoClose] = true;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleMany], null, []);
          else
            this._all(options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _all(options, callback) {
        let count = this[kCount];
        const acc = [];
        const nextv = () => {
          const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
          if (size <= 0) {
            this.nextTick(callback, null, acc);
          } else {
            this._nextv(size, emptyOptions, onnextv);
          }
        };
        const onnextv = (err2, items) => {
          if (err2) {
            callback(err2);
          } else if (items.length === 0) {
            callback(null, acc);
          } else {
            acc.push.apply(acc, items);
            count += items.length;
            nextv();
          }
        };
        nextv();
      }
      [kFinishWork]() {
        const cb = this[kCallback];
        if (this[kAbortOnClose] && cb === null)
          return noop5;
        this[kWorking] = false;
        this[kCallback] = null;
        if (this[kClosing])
          this._close(this[kHandleClose]);
        return cb;
      }
      [kReturnMany](cb, err2, items) {
        if (this[kAutoClose]) {
          this.close(cb.bind(null, err2, items));
        } else {
          cb(err2, items);
        }
      }
      seek(target, options) {
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
        } else if (this[kWorking]) {
          throw new ModuleError("Iterator is busy: cannot call seek() until next() has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          });
        } else {
          const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
          const keyFormat = keyEncoding.format;
          if (options.keyEncoding !== keyFormat) {
            options = { ...options, keyEncoding: keyFormat };
          }
          const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
          this._seek(mapped, options);
        }
      }
      _seek(target, options) {
        throw new ModuleError("Iterator does not support seek()", {
          code: "LEVEL_NOT_SUPPORTED"
        });
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kClosed]) {
          this.nextTick(callback);
        } else if (this[kClosing]) {
          this[kCloseCallbacks].push(callback);
        } else {
          this[kClosing] = true;
          this[kCloseCallbacks].push(callback);
          if (!this[kWorking]) {
            this._close(this[kHandleClose]);
          } else if (this[kAbortOnClose]) {
            const cb = this[kFinishWork]();
            cb(new ModuleError("Aborted on iterator close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kHandleClose]() {
        this[kClosed] = true;
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
      async *[Symbol.asyncIterator]() {
        try {
          let item;
          while ((item = await this.next()) !== void 0) {
            yield item;
          }
        } finally {
          if (!this[kClosed])
            await this.close();
        }
      }
    };
    var AbstractIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, true);
        this[kKeys] = options.keys !== false;
        this[kValues] = options.values !== false;
      }
      [kHandleOne](err2, key, value2) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          value2 = this[kValues] && value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("entry", err3));
        }
        if (!(key === void 0 && value2 === void 0)) {
          this[kCount]++;
        }
        cb(null, key, value2);
      }
      [kHandleMany](err2, entries) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (const entry of entries) {
            const key = entry[0];
            const value2 = entry[1];
            entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            entry[1] = this[kValues] && value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("entries", err3));
        }
        this[kCount] += entries.length;
        this[kReturnMany](cb, null, entries);
      }
      end(callback) {
        if (!warnedEnd && typeof console !== "undefined") {
          warnedEnd = true;
          console.warn(new ModuleError(
            "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
            { code: "LEVEL_LEGACY" }
          ));
        }
        return this.close(callback);
      }
    };
    var AbstractKeyIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, key) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("key", err3));
        }
        if (key !== void 0)
          this[kCount]++;
        cb(null, key);
      }
      [kHandleMany](err2, keys) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            keys[i2] = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("keys", err3));
        }
        this[kCount] += keys.length;
        this[kReturnMany](cb, null, keys);
      }
    };
    var AbstractValueIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, value2) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          value2 = value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("value", err3));
        }
        if (value2 !== void 0)
          this[kCount]++;
        cb(null, value2);
      }
      [kHandleMany](err2, values) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i2 = 0; i2 < values.length; i2++) {
            const value2 = values[i2];
            values[i2] = value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("values", err3));
        }
        this[kCount] += values.length;
        this[kReturnMany](cb, null, values);
      }
    };
    var IteratorDecodeError = class extends ModuleError {
      constructor(subject, cause) {
        super(`Iterator could not decode ${subject}`, {
          code: "LEVEL_DECODE_ERROR",
          cause
        });
      }
    };
    for (const k of ["_ended property", "_nexting property", "_end method"]) {
      Object.defineProperty(AbstractIterator.prototype, k.split(" ")[0], {
        get() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        },
        set() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        }
      });
    }
    AbstractIterator.keyEncoding = kKeyEncoding;
    AbstractIterator.valueEncoding = kValueEncoding;
    exports2.AbstractIterator = AbstractIterator;
    exports2.AbstractKeyIterator = AbstractKeyIterator;
    exports2.AbstractValueIterator = AbstractValueIterator;
  }
});

// node_modules/abstract-level/lib/default-kv-iterator.js
var require_default_kv_iterator = __commonJS({
  "node_modules/abstract-level/lib/default-kv-iterator.js"(exports2) {
    "use strict";
    var { AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kIterator = Symbol("iterator");
    var kCallback = Symbol("callback");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var DefaultKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: true, values: false });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    var DefaultValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: false, values: true });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    for (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {
      const keys = Iterator === DefaultKeyIterator;
      const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype[kHandleOne] = function(err2, key, value2) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, keys ? key : value2);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
      Iterator.prototype[kHandleMany] = function(err2, entries) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, entries.map(mapEntry));
      };
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.DefaultKeyIterator = DefaultKeyIterator;
    exports2.DefaultValueIterator = DefaultValueIterator;
  }
});

// node_modules/abstract-level/lib/deferred-iterator.js
var require_deferred_iterator = __commonJS({
  "node_modules/abstract-level/lib/deferred-iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var ModuleError = require_module_error();
    var kNut = Symbol("nut");
    var kUndefer = Symbol("undefer");
    var kFactory = Symbol("factory");
    var DeferredIterator = class extends AbstractIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.iterator(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.keys(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.values(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    for (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {
      Iterator.prototype[kUndefer] = function() {
        if (this.db.status === "open") {
          this[kNut] = this[kFactory]();
        }
      };
      Iterator.prototype._next = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].next(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._next(callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        if (this[kNut] !== null) {
          this[kNut].nextv(size, options, callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._nextv(size, options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._all = function(options, callback) {
        if (this[kNut] !== null) {
          this[kNut].all(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._all(options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._seek = function(target, options) {
        if (this[kNut] !== null) {
          this[kNut]._seek(target, options);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._seek(target, options));
        }
      };
      Iterator.prototype._close = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].close(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._close(callback));
        } else {
          this.nextTick(callback);
        }
      };
    }
    exports2.DeferredIterator = DeferredIterator;
    exports2.DeferredKeyIterator = DeferredKeyIterator;
    exports2.DeferredValueIterator = DeferredValueIterator;
  }
});

// node_modules/abstract-level/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-level/abstract-chained-batch.js"(exports2) {
    "use strict";
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getCallback, getOptions } = require_common3();
    var kPromise = Symbol("promise");
    var kStatus = Symbol("status");
    var kOperations = Symbol("operations");
    var kFinishClose = Symbol("finishClose");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var AbstractChainedBatch = class {
      constructor(db) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        this[kOperations] = [];
        this[kCloseCallbacks] = [];
        this[kStatus] = "open";
        this[kFinishClose] = this[kFinishClose].bind(this);
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get length() {
        return this[kOperations].length;
      }
      put(key, value2, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call put() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key) || this.db._checkValue(value2);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const valueEncoding = db.valueEncoding(options && options.valueEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
        if (db !== this.db) {
          options.sublevel = null;
        }
        const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value2);
        this._put(mappedKey, mappedValue, options);
        this[kOperations].push({ ...original, type: "put", key, value: value2 });
        return this;
      }
      _put(key, value2, options) {
      }
      del(key, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call del() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat };
        if (db !== this.db) {
          options.sublevel = null;
        }
        this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
        this[kOperations].push({ ...original, type: "del", key });
        return this;
      }
      _del(key, options) {
      }
      clear() {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call clear() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        this._clear();
        this[kOperations] = [];
        return this;
      }
      _clear() {
      }
      write(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options);
        if (this[kStatus] !== "open") {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        } else if (this.length === 0) {
          this.close(callback);
        } else {
          this[kStatus] = "writing";
          this._write(options, (err2) => {
            this[kStatus] = "closing";
            this[kCloseCallbacks].push(() => callback(err2));
            if (!err2)
              this.db.emit("batch", this[kOperations]);
            this._close(this[kFinishClose]);
          });
        }
        return callback[kPromise];
      }
      _write(options, callback) {
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kStatus] === "closing") {
          this[kCloseCallbacks].push(callback);
        } else if (this[kStatus] === "closed") {
          this.nextTick(callback);
        } else {
          this[kCloseCallbacks].push(callback);
          if (this[kStatus] !== "writing") {
            this[kStatus] = "closing";
            this._close(this[kFinishClose]);
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kFinishClose]() {
        this[kStatus] = "closed";
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
    };
    exports2.AbstractChainedBatch = AbstractChainedBatch;
  }
});

// node_modules/abstract-level/lib/default-chained-batch.js
var require_default_chained_batch = __commonJS({
  "node_modules/abstract-level/lib/default-chained-batch.js"(exports2) {
    "use strict";
    var { AbstractChainedBatch } = require_abstract_chained_batch();
    var ModuleError = require_module_error();
    var kEncoded = Symbol("encoded");
    var DefaultChainedBatch = class extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kEncoded] = [];
      }
      _put(key, value2, options) {
        this[kEncoded].push({ ...options, type: "put", key, value: value2 });
      }
      _del(key, options) {
        this[kEncoded].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kEncoded] = [];
      }
      _write(options, callback) {
        if (this.db.status === "opening") {
          this.db.defer(() => this._write(options, callback));
        } else if (this.db.status === "open") {
          if (this[kEncoded].length === 0)
            this.nextTick(callback);
          else
            this.db._batch(this[kEncoded], options, callback);
        } else {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        }
      }
    };
    exports2.DefaultChainedBatch = DefaultChainedBatch;
  }
});

// node_modules/abstract-level/lib/range-options.js
var require_range_options = __commonJS({
  "node_modules/abstract-level/lib/range-options.js"(exports2, module2) {
    "use strict";
    var ModuleError = require_module_error();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var rangeOptions = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
    module2.exports = function(options, keyEncoding) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty.call(options, k))
          continue;
        if (k === "keyEncoding" || k === "valueEncoding")
          continue;
        if (k === "start" || k === "end") {
          throw new ModuleError(`The legacy range option '${k}' has been removed`, {
            code: "LEVEL_LEGACY"
          });
        } else if (k === "encoding") {
          throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
            code: "LEVEL_LEGACY"
          });
        }
        if (rangeOptions.has(k)) {
          result[k] = keyEncoding.encode(options[k]);
        } else {
          result[k] = options[k];
        }
      }
      result.reverse = !!result.reverse;
      result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
      return result;
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});

// node_modules/abstract-level/lib/next-tick-browser.js
var require_next_tick_browser2 = __commonJS({
  "node_modules/abstract-level/lib/next-tick-browser.js"(exports2, module2) {
    "use strict";
    var queueMicrotask2 = require_queue_microtask();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/abstract-level/lib/abstract-sublevel-iterator.js
var require_abstract_sublevel_iterator = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel-iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kUnfix = Symbol("unfix");
    var kIterator = Symbol("iterator");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kCallback = Symbol("callback");
    var AbstractSublevelIterator = class extends AbstractIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key, value2) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key, value2);
      }
      [kHandleMany](err2, entries) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (const entry of entries) {
          const key = entry[0];
          if (key !== void 0)
            entry[0] = this[kUnfix](key);
        }
        callback(err2, entries);
      }
    };
    var AbstractSublevelKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key);
      }
      [kHandleMany](err2, keys) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          if (key !== void 0)
            keys[i2] = this[kUnfix](key);
        }
        callback(err2, keys);
      }
    };
    var AbstractSublevelValueIterator = class extends AbstractValueIterator {
      constructor(db, options, iterator) {
        super(db, options);
        this[kIterator] = iterator;
      }
    };
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
    }
    for (const Iterator of [AbstractSublevelValueIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kIterator].next(callback);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kIterator].nextv(size, options, callback);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kIterator].all(options, callback);
      };
    }
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.AbstractSublevelIterator = AbstractSublevelIterator;
    exports2.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
    exports2.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  }
});

// node_modules/abstract-level/lib/abstract-sublevel.js
var require_abstract_sublevel = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel.js"(exports2, module2) {
    "use strict";
    var ModuleError = require_module_error();
    var { Buffer: Buffer2 } = require_buffer() || {};
    var {
      AbstractSublevelIterator,
      AbstractSublevelKeyIterator,
      AbstractSublevelValueIterator
    } = require_abstract_sublevel_iterator();
    var kPrefix = Symbol("prefix");
    var kUpperBound = Symbol("upperBound");
    var kPrefixRange = Symbol("prefixRange");
    var kParent = Symbol("parent");
    var kUnfix = Symbol("unfix");
    var textEncoder18 = new TextEncoder();
    var defaults = { separator: "!" };
    module2.exports = function({ AbstractLevel }) {
      class AbstractSublevel extends AbstractLevel {
        static defaults(options) {
          if (typeof options === "string") {
            throw new ModuleError("The subleveldown string shorthand for { separator } has been removed", {
              code: "LEVEL_LEGACY"
            });
          } else if (options && options.open) {
            throw new ModuleError("The subleveldown open option has been removed", {
              code: "LEVEL_LEGACY"
            });
          }
          if (options == null) {
            return defaults;
          } else if (!options.separator) {
            return { ...options, separator: "!" };
          } else {
            return options;
          }
        }
        constructor(db, name22, options) {
          const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
          name22 = trim(name22, separator);
          const reserved = separator.charCodeAt(0) + 1;
          const parent2 = db[kParent] || db;
          if (!textEncoder18.encode(name22).every((x) => x > reserved && x < 127)) {
            throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {
              code: "LEVEL_INVALID_PREFIX"
            });
          }
          super(mergeManifests(parent2, manifest), forward);
          const prefix = (db.prefix || "") + separator + name22 + separator;
          const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
          this[kParent] = parent2;
          this[kPrefix] = new MultiFormat(prefix);
          this[kUpperBound] = new MultiFormat(upperBound);
          this[kUnfix] = new Unfixer();
          this.nextTick = parent2.nextTick;
        }
        prefixKey(key, keyFormat) {
          if (keyFormat === "utf8") {
            return this[kPrefix].utf8 + key;
          } else if (key.byteLength === 0) {
            return this[kPrefix][keyFormat];
          } else if (keyFormat === "view") {
            const view = this[kPrefix].view;
            const result = new Uint8Array(view.byteLength + key.byteLength);
            result.set(view, 0);
            result.set(key, view.byteLength);
            return result;
          } else {
            const buffer2 = this[kPrefix].buffer;
            return Buffer2.concat([buffer2, key], buffer2.byteLength + key.byteLength);
          }
        }
        [kPrefixRange](range, keyFormat) {
          if (range.gte !== void 0) {
            range.gte = this.prefixKey(range.gte, keyFormat);
          } else if (range.gt !== void 0) {
            range.gt = this.prefixKey(range.gt, keyFormat);
          } else {
            range.gte = this[kPrefix][keyFormat];
          }
          if (range.lte !== void 0) {
            range.lte = this.prefixKey(range.lte, keyFormat);
          } else if (range.lt !== void 0) {
            range.lt = this.prefixKey(range.lt, keyFormat);
          } else {
            range.lte = this[kUpperBound][keyFormat];
          }
        }
        get prefix() {
          return this[kPrefix].utf8;
        }
        get db() {
          return this[kParent];
        }
        _open(options, callback) {
          this[kParent].open({ passive: true }, callback);
        }
        _put(key, value2, options, callback) {
          this[kParent].put(key, value2, options, callback);
        }
        _get(key, options, callback) {
          this[kParent].get(key, options, callback);
        }
        _getMany(keys, options, callback) {
          this[kParent].getMany(keys, options, callback);
        }
        _del(key, options, callback) {
          this[kParent].del(key, options, callback);
        }
        _batch(operations, options, callback) {
          this[kParent].batch(operations, options, callback);
        }
        _clear(options, callback) {
          this[kPrefixRange](options, options.keyEncoding);
          this[kParent].clear(options, callback);
        }
        _iterator(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].iterator(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelIterator(this, options, iterator, unfix);
        }
        _keys(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].keys(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
        }
        _values(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].values(options);
          return new AbstractSublevelValueIterator(this, options, iterator);
        }
      }
      return { AbstractSublevel };
    };
    var mergeManifests = function(parent2, manifest) {
      return {
        ...parent2.supports,
        createIfMissing: false,
        errorIfExists: false,
        events: {},
        additionalMethods: {},
        ...manifest,
        encodings: {
          utf8: supportsEncoding(parent2, "utf8"),
          buffer: supportsEncoding(parent2, "buffer"),
          view: supportsEncoding(parent2, "view")
        }
      };
    };
    var supportsEncoding = function(parent2, encoding) {
      return parent2.supports.encodings[encoding] ? parent2.keyEncoding(encoding).name === encoding : false;
    };
    var MultiFormat = class {
      constructor(key) {
        this.utf8 = key;
        this.view = textEncoder18.encode(key);
        this.buffer = Buffer2 ? Buffer2.from(this.view.buffer, 0, this.view.byteLength) : {};
      }
    };
    var Unfixer = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(prefixLength, keyFormat) {
        let unfix = this.cache.get(keyFormat);
        if (unfix === void 0) {
          if (keyFormat === "view") {
            unfix = function(prefixLength2, key) {
              return key.subarray(prefixLength2);
            }.bind(null, prefixLength);
          } else {
            unfix = function(prefixLength2, key) {
              return key.slice(prefixLength2);
            }.bind(null, prefixLength);
          }
          this.cache.set(keyFormat, unfix);
        }
        return unfix;
      }
    };
    var trim = function(str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char)
        start++;
      while (end > start && str[end - 1] === char)
        end--;
      return str.slice(start, end);
    };
  }
});

// node_modules/abstract-level/abstract-level.js
var require_abstract_level = __commonJS({
  "node_modules/abstract-level/abstract-level.js"(exports2) {
    "use strict";
    var { supports } = require_level_supports();
    var { Transcoder } = require_level_transcoder();
    var { EventEmitter: EventEmitter6 } = require_events();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { AbstractIterator } = require_abstract_iterator();
    var { DefaultKeyIterator, DefaultValueIterator } = require_default_kv_iterator();
    var { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require_deferred_iterator();
    var { DefaultChainedBatch } = require_default_chained_batch();
    var { getCallback, getOptions } = require_common3();
    var rangeOptions = require_range_options();
    var kPromise = Symbol("promise");
    var kLanded = Symbol("landed");
    var kResources = Symbol("resources");
    var kCloseResources = Symbol("closeResources");
    var kOperations = Symbol("operations");
    var kUndefer = Symbol("undefer");
    var kDeferOpen = Symbol("deferOpen");
    var kOptions = Symbol("options");
    var kStatus = Symbol("status");
    var kDefaultOptions = Symbol("defaultOptions");
    var kTranscoder = Symbol("transcoder");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var noop5 = () => {
    };
    var AbstractLevel = class extends EventEmitter6 {
      constructor(manifest, options) {
        super();
        if (typeof manifest !== "object" || manifest === null) {
          throw new TypeError("The first argument 'manifest' must be an object");
        }
        options = getOptions(options);
        const { keyEncoding, valueEncoding, passive, ...forward } = options;
        this[kResources] = /* @__PURE__ */ new Set();
        this[kOperations] = [];
        this[kDeferOpen] = true;
        this[kOptions] = forward;
        this[kStatus] = "opening";
        this.supports = supports(manifest, {
          status: true,
          promises: true,
          clear: true,
          getMany: true,
          deferredOpen: true,
          snapshots: manifest.snapshots !== false,
          permanence: manifest.permanence !== false,
          keyIterator: true,
          valueIterator: true,
          iteratorNextv: true,
          iteratorAll: true,
          encodings: manifest.encodings || {},
          events: Object.assign({}, manifest.events, {
            opening: true,
            open: true,
            closing: true,
            closed: true,
            put: true,
            del: true,
            batch: true,
            clear: true
          })
        });
        this[kTranscoder] = new Transcoder(formats(this));
        this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
        this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
        for (const encoding of this[kTranscoder].encodings()) {
          if (!this.supports.encodings[encoding.commonName]) {
            this.supports.encodings[encoding.commonName] = true;
          }
        }
        this[kDefaultOptions] = {
          empty: Object.freeze({}),
          entry: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName,
            valueEncoding: this[kValueEncoding].commonName
          }),
          key: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName
          })
        };
        this.nextTick(() => {
          if (this[kDeferOpen]) {
            this.open({ passive: false }, noop5);
          }
        });
      }
      get status() {
        return this[kStatus];
      }
      keyEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
      }
      valueEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
      }
      open(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = { ...this[kOptions], ...getOptions(options) };
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        const maybeOpened = (err2) => {
          if (this[kStatus] === "closing" || this[kStatus] === "opening") {
            this.once(kLanded, err2 ? () => maybeOpened(err2) : maybeOpened);
          } else if (this[kStatus] !== "open") {
            callback(new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (options.passive) {
          if (this[kStatus] === "opening") {
            this.once(kLanded, maybeOpened);
          } else {
            this.nextTick(maybeOpened);
          }
        } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
          this[kDeferOpen] = false;
          this[kStatus] = "opening";
          this.emit("opening");
          this._open(options, (err2) => {
            if (err2) {
              this[kStatus] = "closed";
              this[kCloseResources](() => {
                this.emit(kLanded);
                maybeOpened(err2);
              });
              this[kUndefer]();
              return;
            }
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            if (this[kStatus] === "open")
              this.emit("open");
            if (this[kStatus] === "open")
              this.emit("ready");
            maybeOpened();
          });
        } else if (this[kStatus] === "open") {
          this.nextTick(maybeOpened);
        } else {
          this.once(kLanded, () => this.open(options, callback));
        }
        return callback[kPromise];
      }
      _open(options, callback) {
        this.nextTick(callback);
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        const maybeClosed = (err2) => {
          if (this[kStatus] === "opening" || this[kStatus] === "closing") {
            this.once(kLanded, err2 ? maybeClosed(err2) : maybeClosed);
          } else if (this[kStatus] !== "closed") {
            callback(new ModuleError("Database is not closed", {
              code: "LEVEL_DATABASE_NOT_CLOSED",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (this[kStatus] === "open") {
          this[kStatus] = "closing";
          this.emit("closing");
          const cancel = (err2) => {
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            maybeClosed(err2);
          };
          this[kCloseResources](() => {
            this._close((err2) => {
              if (err2)
                return cancel(err2);
              this[kStatus] = "closed";
              this[kUndefer]();
              this.emit(kLanded);
              if (this[kStatus] === "closed")
                this.emit("closed");
              maybeClosed();
            });
          });
        } else if (this[kStatus] === "closed") {
          this.nextTick(maybeClosed);
        } else {
          this.once(kLanded, () => this.close(callback));
        }
        return callback[kPromise];
      }
      [kCloseResources](callback) {
        if (this[kResources].size === 0) {
          return this.nextTick(callback);
        }
        let pending = this[kResources].size;
        let sync = true;
        const next = () => {
          if (--pending === 0) {
            if (sync)
              this.nextTick(callback);
            else
              callback();
          }
        };
        for (const resource of this[kResources]) {
          resource.close(next);
        }
        sync = false;
        this[kResources].clear();
      }
      _close(callback) {
        this.nextTick(callback);
      }
      get(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.get(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3, value2) => {
          if (err3) {
            if (err3.code === "LEVEL_NOT_FOUND" || err3.notFound || /NotFound/i.test(err3)) {
              if (!err3.code)
                err3.code = "LEVEL_NOT_FOUND";
              if (!err3.notFound)
                err3.notFound = true;
              if (!err3.status)
                err3.status = 404;
            }
            return callback(err3);
          }
          try {
            value2 = valueEncoding.decode(value2);
          } catch (err4) {
            return callback(new ModuleError("Could not decode value", {
              code: "LEVEL_DECODE_ERROR",
              cause: err4
            }));
          }
          callback(null, value2);
        });
        return callback[kPromise];
      }
      _get(key, options, callback) {
        this.nextTick(callback, new Error("NotFound"));
      }
      getMany(keys, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.getMany(keys, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(keys)) {
          this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
          return callback[kPromise];
        }
        if (keys.length === 0) {
          this.nextTick(callback, null, []);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKeys = new Array(keys.length);
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          const err2 = this._checkKey(key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          mappedKeys[i2] = this.prefixKey(keyEncoding.encode(key), keyFormat);
        }
        this._getMany(mappedKeys, options, (err2, values) => {
          if (err2)
            return callback(err2);
          try {
            for (let i2 = 0; i2 < values.length; i2++) {
              if (values[i2] !== void 0) {
                values[i2] = valueEncoding.decode(values[i2]);
              }
            }
          } catch (err3) {
            return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
              code: "LEVEL_DECODE_ERROR",
              cause: err3
            }));
          }
          callback(null, values);
        });
        return callback[kPromise];
      }
      _getMany(keys, options, callback) {
        this.nextTick(callback, null, new Array(keys.length).fill(void 0));
      }
      put(key, value2, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.put(key, value2, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key) || this._checkValue(value2);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value2);
        this._put(mappedKey, mappedValue, options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("put", key, value2);
          callback();
        });
        return callback[kPromise];
      }
      _put(key, value2, options, callback) {
        this.nextTick(callback);
      }
      del(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].key);
        if (this[kStatus] === "opening") {
          this.defer(() => this.del(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const keyFormat = keyEncoding.format;
        if (options.keyEncoding !== keyFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat });
        }
        this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("del", key);
          callback();
        });
        return callback[kPromise];
      }
      _del(key, options, callback) {
        this.nextTick(callback);
      }
      batch(operations, options, callback) {
        if (!arguments.length) {
          if (this[kStatus] === "opening")
            return new DefaultChainedBatch(this);
          if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._chainedBatch();
        }
        if (typeof operations === "function")
          callback = operations;
        else
          callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.batch(operations, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(operations)) {
          this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
          return callback[kPromise];
        }
        if (operations.length === 0) {
          this.nextTick(callback);
          return callback[kPromise];
        }
        const mapped = new Array(operations.length);
        const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;
        for (let i2 = 0; i2 < operations.length; i2++) {
          if (typeof operations[i2] !== "object" || operations[i2] === null) {
            this.nextTick(callback, new TypeError("A batch operation must be an object"));
            return callback[kPromise];
          }
          const op = Object.assign({}, operations[i2]);
          if (op.type !== "put" && op.type !== "del") {
            this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
            return callback[kPromise];
          }
          const err2 = this._checkKey(op.key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          const db = op.sublevel != null ? op.sublevel : this;
          const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
          const keyFormat = keyEncoding.format;
          op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
          op.keyEncoding = keyFormat;
          if (op.type === "put") {
            const valueErr = this._checkValue(op.value);
            if (valueErr) {
              this.nextTick(callback, valueErr);
              return callback[kPromise];
            }
            const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
            op.value = valueEncoding.encode(op.value);
            op.valueEncoding = valueEncoding.format;
          }
          if (db !== this) {
            op.sublevel = null;
          }
          mapped[i2] = op;
        }
        this._batch(mapped, forward, (err2) => {
          if (err2)
            return callback(err2);
          this.emit("batch", operations);
          callback();
        });
        return callback[kPromise];
      }
      _batch(operations, options, callback) {
        this.nextTick(callback);
      }
      sublevel(name22, options) {
        return this._sublevel(name22, AbstractSublevel.defaults(options));
      }
      _sublevel(name22, options) {
        return new AbstractSublevel(this, name22, options);
      }
      prefixKey(key, keyFormat) {
        return key;
      }
      clear(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.clear(options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const original = options;
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keyEncoding = keyEncoding.format;
        if (options.limit === 0) {
          this.nextTick(callback);
        } else {
          this._clear(options, (err2) => {
            if (err2)
              return callback(err2);
            this.emit("clear", original);
            callback();
          });
        }
        return callback[kPromise];
      }
      _clear(options, callback) {
        this.nextTick(callback);
      }
      iterator(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._iterator(options);
      }
      _iterator(options) {
        return new AbstractIterator(this, options);
      }
      keys(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredKeyIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._keys(options);
      }
      _keys(options) {
        return new DefaultKeyIterator(this, options);
      }
      values(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredValueIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._values(options);
      }
      _values(options) {
        return new DefaultValueIterator(this, options);
      }
      defer(fn) {
        if (typeof fn !== "function") {
          throw new TypeError("The first argument must be a function");
        }
        this[kOperations].push(fn);
      }
      [kUndefer]() {
        if (this[kOperations].length === 0) {
          return;
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          op();
        }
      }
      attachResource(resource) {
        if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
          throw new TypeError("The first argument must be a resource object");
        }
        this[kResources].add(resource);
      }
      detachResource(resource) {
        this[kResources].delete(resource);
      }
      _chainedBatch() {
        return new DefaultChainedBatch(this);
      }
      _checkKey(key) {
        if (key === null || key === void 0) {
          return new ModuleError("Key cannot be null or undefined", {
            code: "LEVEL_INVALID_KEY"
          });
        }
      }
      _checkValue(value2) {
        if (value2 === null || value2 === void 0) {
          return new ModuleError("Value cannot be null or undefined", {
            code: "LEVEL_INVALID_VALUE"
          });
        }
      }
    };
    AbstractLevel.prototype.nextTick = require_next_tick_browser2();
    var { AbstractSublevel } = require_abstract_sublevel()({ AbstractLevel });
    exports2.AbstractLevel = AbstractLevel;
    exports2.AbstractSublevel = AbstractSublevel;
    var maybeError = function(db, callback) {
      if (db[kStatus] !== "open") {
        db.nextTick(callback, new ModuleError("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        }));
        return true;
      }
      return false;
    };
    var formats = function(db) {
      return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
    };
  }
});

// node_modules/abstract-level/index.js
var require_abstract_level2 = __commonJS({
  "node_modules/abstract-level/index.js"(exports2) {
    "use strict";
    exports2.AbstractLevel = require_abstract_level().AbstractLevel;
    exports2.AbstractSublevel = require_abstract_level().AbstractSublevel;
    exports2.AbstractIterator = require_abstract_iterator().AbstractIterator;
    exports2.AbstractKeyIterator = require_abstract_iterator().AbstractKeyIterator;
    exports2.AbstractValueIterator = require_abstract_iterator().AbstractValueIterator;
    exports2.AbstractChainedBatch = require_abstract_chained_batch().AbstractChainedBatch;
  }
});

// node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports2, module2) {
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb)
            cb(err2, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each3(i2, err2, result) {
        results[i2] = result;
        if (err2)
          isErrored = true;
        if (--pending === 0 || err2) {
          done(err2);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err3, result2) {
              each3(key, err3, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err3, result2) {
              each3(key, err3, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i2) {
          tasks[key](function(err2, result) {
            each3(key, err2, result);
          });
          if (i2 === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i2) {
          task(function(err2, result) {
            each3(i2, err2, result);
          });
          if (i2 === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// node_modules/browser-level/util/key-range.js
var require_key_range = __commonJS({
  "node_modules/browser-level/util/key-range.js"(exports2, module2) {
    "use strict";
    module2.exports = function createKeyRange(options) {
      const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
      const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
      const lowerExclusive = options.gte === void 0;
      const upperExclusive = options.lte === void 0;
      if (lower !== void 0 && upper !== void 0) {
        return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
      } else if (lower !== void 0) {
        return IDBKeyRange.lowerBound(lower, lowerExclusive);
      } else if (upper !== void 0) {
        return IDBKeyRange.upperBound(upper, upperExclusive);
      } else {
        return null;
      }
    };
  }
});

// node_modules/browser-level/util/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/browser-level/util/deserialize.js"(exports2, module2) {
    "use strict";
    var textEncoder18 = new TextEncoder();
    module2.exports = function(data) {
      if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      } else {
        return textEncoder18.encode(data);
      }
    };
  }
});

// node_modules/browser-level/iterator.js
var require_iterator = __commonJS({
  "node_modules/browser-level/iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator } = require_abstract_level2();
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var kCache = Symbol("cache");
    var kFinished = Symbol("finished");
    var kOptions = Symbol("options");
    var kCurrentOptions = Symbol("currentOptions");
    var kPosition = Symbol("position");
    var kLocation = Symbol("location");
    var kFirst = Symbol("first");
    var emptyOptions = {};
    var Iterator = class extends AbstractIterator {
      constructor(db, location2, options) {
        super(db, options);
        this[kCache] = [];
        this[kFinished] = this.limit === 0;
        this[kOptions] = options;
        this[kCurrentOptions] = { ...options };
        this[kPosition] = void 0;
        this[kLocation] = location2;
        this[kFirst] = true;
      }
      _nextv(size, options, callback) {
        this[kFirst] = false;
        if (this[kFinished]) {
          return this.nextTick(callback, null, []);
        } else if (this[kCache].length > 0) {
          size = Math.min(size, this[kCache].length);
          return this.nextTick(callback, null, this[kCache].splice(0, size));
        }
        if (this[kPosition] !== void 0) {
          if (this[kOptions].reverse) {
            this[kCurrentOptions].lt = this[kPosition];
            this[kCurrentOptions].lte = void 0;
          } else {
            this[kCurrentOptions].gt = this[kPosition];
            this[kCurrentOptions].gte = void 0;
          }
        }
        let keyRange;
        try {
          keyRange = createKeyRange(this[kCurrentOptions]);
        } catch (_) {
          this[kFinished] = true;
          return this.nextTick(callback, null, []);
        }
        const transaction = this.db.db.transaction([this[kLocation]], "readonly");
        const store = transaction.objectStore(this[kLocation]);
        const entries = [];
        if (!this[kOptions].reverse) {
          let keys;
          let values;
          const complete = () => {
            if (keys === void 0 || values === void 0)
              return;
            const length23 = Math.max(keys.length, values.length);
            if (length23 === 0 || size === Infinity) {
              this[kFinished] = true;
            } else {
              this[kPosition] = keys[length23 - 1];
            }
            entries.length = length23;
            for (let i2 = 0; i2 < length23; i2++) {
              const key = keys[i2];
              const value2 = values[i2];
              entries[i2] = [
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value2 !== void 0 ? deserialize(value2) : void 0
              ];
            }
            maybeCommit(transaction);
          };
          if (this[kOptions].keys || size < Infinity) {
            store.getAllKeys(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              keys = ev.target.result;
              complete();
            };
          } else {
            keys = [];
            this.nextTick(complete);
          }
          if (this[kOptions].values) {
            store.getAll(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              values = ev.target.result;
              complete();
            };
          } else {
            values = [];
            this.nextTick(complete);
          }
        } else {
          const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
          store[method](keyRange, "prev").onsuccess = (ev) => {
            const cursor = ev.target.result;
            if (cursor) {
              const { key, value: value2 } = cursor;
              this[kPosition] = key;
              entries.push([
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value2 !== void 0 ? deserialize(value2) : void 0
              ]);
              if (entries.length < size) {
                cursor.continue();
              } else {
                maybeCommit(transaction);
              }
            } else {
              this[kFinished] = true;
            }
          };
        }
        transaction.onabort = () => {
          callback(transaction.error || new Error("aborted by user"));
          callback = null;
        };
        transaction.oncomplete = () => {
          callback(null, entries);
          callback = null;
        };
      }
      _next(callback) {
        if (this[kCache].length > 0) {
          const [key, value2] = this[kCache].shift();
          this.nextTick(callback, null, key, value2);
        } else if (this[kFinished]) {
          this.nextTick(callback);
        } else {
          let size = Math.min(100, this.limit - this.count);
          if (this[kFirst]) {
            this[kFirst] = false;
            size = 1;
          }
          this._nextv(size, emptyOptions, (err2, entries) => {
            if (err2)
              return callback(err2);
            this[kCache] = entries;
            this._next(callback);
          });
        }
      }
      _all(options, callback) {
        this[kFirst] = false;
        const cache19 = this[kCache].splice(0, this[kCache].length);
        const size = this.limit - this.count - cache19.length;
        if (size <= 0) {
          return this.nextTick(callback, null, cache19);
        }
        this._nextv(size, emptyOptions, (err2, entries) => {
          if (err2)
            return callback(err2);
          if (cache19.length > 0)
            entries = cache19.concat(entries);
          callback(null, entries);
        });
      }
      _seek(target, options) {
        this[kFirst] = true;
        this[kCache] = [];
        this[kFinished] = false;
        this[kPosition] = void 0;
        this[kCurrentOptions] = { ...this[kOptions] };
        let keyRange;
        try {
          keyRange = createKeyRange(this[kOptions]);
        } catch (_) {
          this[kFinished] = true;
          return;
        }
        if (keyRange !== null && !keyRange.includes(target)) {
          this[kFinished] = true;
        } else if (this[kOptions].reverse) {
          this[kCurrentOptions].lte = target;
        } else {
          this[kCurrentOptions].gte = target;
        }
      }
    };
    exports2.Iterator = Iterator;
    function maybeCommit(transaction) {
      if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
  }
});

// node_modules/browser-level/util/clear.js
var require_clear = __commonJS({
  "node_modules/browser-level/util/clear.js"(exports2, module2) {
    "use strict";
    module2.exports = function clear(db, location2, keyRange, options, callback) {
      if (options.limit === 0)
        return db.nextTick(callback);
      const transaction = db.db.transaction([location2], "readwrite");
      const store = transaction.objectStore(location2);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});

// node_modules/browser-level/index.js
var require_browser_level = __commonJS({
  "node_modules/browser-level/index.js"(exports2) {
    "use strict";
    var { AbstractLevel } = require_abstract_level2();
    var ModuleError = require_module_error();
    var parallel5 = require_run_parallel_limit();
    var { fromCallback } = require_catering();
    var { Iterator } = require_iterator();
    var deserialize = require_deserialize();
    var clear = require_clear();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    var kIDB = Symbol("idb");
    var kNamePrefix = Symbol("namePrefix");
    var kLocation = Symbol("location");
    var kVersion = Symbol("version");
    var kStore = Symbol("store");
    var kOnComplete = Symbol("onComplete");
    var kPromise = Symbol("promise");
    var BrowserLevel = class extends AbstractLevel {
      constructor(location2, options, _) {
        if (typeof options === "function" || typeof _ === "function") {
          throw new ModuleError("The levelup-style callback argument has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        const { prefix, version: version4, ...forward } = options || {};
        super({
          encodings: { view: true },
          snapshots: false,
          createIfMissing: false,
          errorIfExists: false,
          seek: true
        }, forward);
        if (typeof location2 !== "string") {
          throw new Error("constructor requires a location string argument");
        }
        this[kLocation] = location2;
        this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
        this[kVersion] = parseInt(version4 || 1, 10);
        this[kIDB] = null;
      }
      get location() {
        return this[kLocation];
      }
      get namePrefix() {
        return this[kNamePrefix];
      }
      get version() {
        return this[kVersion];
      }
      get db() {
        return this[kIDB];
      }
      get type() {
        return "browser-level";
      }
      _open(options, callback) {
        const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
        req.onerror = function() {
          callback(req.error || new Error("unknown error"));
        };
        req.onsuccess = () => {
          this[kIDB] = req.result;
          callback();
        };
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains(this[kLocation])) {
            db.createObjectStore(this[kLocation]);
          }
        };
      }
      [kStore](mode) {
        const transaction = this[kIDB].transaction([this[kLocation]], mode);
        return transaction.objectStore(this[kLocation]);
      }
      [kOnComplete](request2, callback) {
        const transaction = request2.transaction;
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback(null, request2.result);
        };
      }
      _get(key, options, callback) {
        const store = this[kStore]("readonly");
        let req;
        try {
          req = store.get(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, function(err2, value2) {
          if (err2)
            return callback(err2);
          if (value2 === void 0) {
            return callback(new ModuleError("Entry not found", {
              code: "LEVEL_NOT_FOUND"
            }));
          }
          callback(null, deserialize(value2));
        });
      }
      _getMany(keys, options, callback) {
        const store = this[kStore]("readonly");
        const tasks = keys.map((key) => (next) => {
          let request2;
          try {
            request2 = store.get(key);
          } catch (err2) {
            return next(err2);
          }
          request2.onsuccess = () => {
            const value2 = request2.result;
            next(null, value2 === void 0 ? value2 : deserialize(value2));
          };
          request2.onerror = (ev) => {
            ev.stopPropagation();
            next(request2.error);
          };
        });
        parallel5(tasks, 16, callback);
      }
      _del(key, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.delete(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _put(key, value2, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.put(value2, key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _iterator(options) {
        return new Iterator(this, this[kLocation], options);
      }
      _batch(operations, options, callback) {
        const store = this[kStore]("readwrite");
        const transaction = store.transaction;
        let index = 0;
        let error;
        transaction.onabort = function() {
          callback(error || transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback();
        };
        function loop() {
          const op = operations[index++];
          const key = op.key;
          let req;
          try {
            req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
          } catch (err2) {
            error = err2;
            transaction.abort();
            return;
          }
          if (index < operations.length) {
            req.onsuccess = loop;
          } else if (typeof transaction.commit === "function") {
            transaction.commit();
          }
        }
        loop();
      }
      _clear(options, callback) {
        let keyRange;
        let req;
        try {
          keyRange = createKeyRange(options);
        } catch (e) {
          return this.nextTick(callback);
        }
        if (options.limit >= 0) {
          return clear(this, this[kLocation], keyRange, options, callback);
        }
        try {
          const store = this[kStore]("readwrite");
          req = keyRange ? store.delete(keyRange) : store.clear();
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _close(callback) {
        this[kIDB].close();
        this.nextTick(callback);
      }
    };
    BrowserLevel.destroy = function(location2, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      callback = fromCallback(callback, kPromise);
      const request2 = indexedDB.deleteDatabase(prefix + location2);
      request2.onsuccess = function() {
        callback();
      };
      request2.onerror = function(err2) {
        callback(err2);
      };
      return callback[kPromise];
    };
    exports2.BrowserLevel = BrowserLevel;
  }
});

// node_modules/level/browser.js
var require_browser3 = __commonJS({
  "node_modules/level/browser.js"(exports2) {
    exports2.Level = require_browser_level().BrowserLevel;
  }
});

// node_modules/it-take/index.js
var require_it_take = __commonJS({
  "node_modules/it-take/index.js"(exports2, module2) {
    "use strict";
    var take5 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module2.exports = take5;
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits2;
    var util5 = require_minimal3();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero2 = LongBits2.zero = new LongBits2(0, 0);
    zero2.toNumber = function() {
      return 0;
    };
    zero2.zzEncode = zero2.zzDecode = function() {
      return this;
    };
    zero2.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value2) {
      if (value2 === 0)
        return zero2;
      var sign5 = value2 < 0;
      if (sign5)
        value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign5) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from33(value2) {
      if (typeof value2 === "number")
        return LongBits2.fromNumber(value2);
      if (util5.isString(value2)) {
        if (util5.Long)
          value2 = util5.Long.fromString(value2);
        else
          return LongBits2.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util5.Long ? new util5.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero2;
      return new LongBits2(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length23() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util5 = exports2;
    util5.asPromise = require_aspromise();
    util5.base64 = require_base64();
    util5.EventEmitter = require_eventemitter();
    util5.float = require_float();
    util5.inquire = require_inquire();
    util5.utf8 = require_utf8();
    util5.pool = require_pool();
    util5.LongBits = require_longbits2();
    util5.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util5.global = util5.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util5.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util5.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util5.isInteger = Number.isInteger || function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util5.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util5.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util5.isset = util5.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util5.Buffer = function() {
      try {
        var Buffer2 = util5.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util5._Buffer_from = null;
    util5._Buffer_allocUnsafe = null;
    util5.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util5.Buffer ? util5._Buffer_allocUnsafe(sizeOrArray) : new util5.Array(sizeOrArray) : util5.Buffer ? util5._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util5.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util5.Long = util5.global.dcodeIO && util5.global.dcodeIO.Long || util5.global.Long || util5.inquire("long");
    util5.key2Re = /^true|false|0|1$/;
    util5.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util5.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util5.longToHash = function longToHash(value2) {
      return value2 ? util5.LongBits.from(value2).toHash() : util5.LongBits.zeroHash;
    };
    util5.longFromHash = function longFromHash(hash3, unsigned2) {
      var bits2 = util5.LongBits.fromHash(hash3);
      if (util5.Long)
        return util5.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge11(dst, src18, ifNotSet) {
      for (var keys = Object.keys(src18), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src18[keys[i2]];
      return dst;
    }
    util5.merge = merge11;
    util5.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name22) {
      function CustomError(message6, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message6, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message6;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge11(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name22;
      } });
      CustomError.prototype.toString = function toString28() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util5.newError = newError;
    util5.ProtocolError = newError("ProtocolError");
    util5.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util5.oneOfSetter = function setOneOf(fieldNames) {
      return function(name22) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name22)
            delete this[fieldNames[i2]];
      };
    };
    util5.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util5._configure = function() {
      var Buffer2 = util5.Buffer;
      if (!Buffer2) {
        util5._Buffer_from = util5._Buffer_allocUnsafe = null;
        return;
      }
      util5._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      };
      util5._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util5 = require_minimal3();
    var BufferWriter;
    var LongBits2 = util5.LongBits;
    var base6416 = util5.base64;
    var utf8 = util5.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop5() {
    }
    function State(writer5) {
      this.head = writer5.head;
      this.tail = writer5.tail;
      this.len = writer5.len;
      this.next = writer5.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop5, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create26 = function create27() {
      return util5.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create26();
    Writer2.alloc = function alloc3(size) {
      return new util5.Array(size);
    };
    if (util5.Array !== Array)
      Writer2.alloc = util5.pool(Writer2.alloc, util5.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
        value2
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value2)) : this.uint32(value2);
    };
    Writer2.prototype.sint32 = function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value2) {
      var bits2 = LongBits2.from(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer2.prototype.bool = function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value2) {
      return this._push(util5.float.writeFloatLE, 4, value2);
    };
    Writer2.prototype.double = function write_double(value2) {
      return this._push(util5.float.writeDoubleLE, 8, value2);
    };
    var writeBytes = util5.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer2.prototype.bytes = function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util5.isString(value2)) {
        var buf2 = Writer2.alloc(len = base6416.length(value2));
        base6416.decode(value2, buf2, 0);
        value2 = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    };
    Writer2.prototype.string = function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop5, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop5, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create26();
      BufferWriter._configure();
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer2();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util5 = require_minimal3();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util5._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util5.Buffer && util5.Buffer.prototype instanceof Uint8Array && util5.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
      if (util5.isString(value2))
        value2 = util5._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value2);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util5.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value2) {
      var len = util5.Buffer.byteLength(value2);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value2);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util5 = require_minimal3();
    var BufferReader;
    var LongBits2 = util5.LongBits;
    var utf8 = util5.utf8;
    function indexOutOfRange(reader6, writeLength) {
      return RangeError("index out of range: " + reader6.pos + " + " + (writeLength || 1) + " > " + reader6.len);
    }
    function Reader2(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader2(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader2(buffer2);
      throw Error("illegal buffer");
    };
    var create26 = function create27() {
      return util5.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader2.create = function create_buffer(buffer3) {
          return util5.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader2.create = create26();
    Reader2.prototype._slice = util5.Array.prototype.subarray || util5.Array.prototype.slice;
    Reader2.prototype.uint32 = function read_uint32_setup() {
      var value2 = 4294967295;
      return function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      };
    }();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    };
    function readLongVarint() {
      var bits2 = new LongBits2(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits2;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util5.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util5.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length23 = this.uint32(), start = this.pos, end = this.pos + length23;
      if (end > this.len)
        throw indexOutOfRange(this, length23);
      this.pos += length23;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader2.prototype.skip = function skip(length23) {
      if (typeof length23 === "number") {
        if (this.pos + length23 > this.len)
          throw indexOutOfRange(this, length23);
        this.pos += length23;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create26();
      BufferReader._configure();
      var fn = util5.Long ? "toLong" : "toNumber";
      util5.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader2();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util5 = require_minimal3();
    function BufferReader(buffer2) {
      Reader2.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util5.Buffer)
        BufferReader.prototype._slice = util5.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc/service.js
var require_service3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service2;
    var util5 = require_minimal3();
    (Service2.prototype = Object.create(util5.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util5.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util5.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err2, response) {
            if (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err3) {
                self2.emit("error", err3, method);
                return callback(err3);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err2) {
        self2.emit("error", err2, method);
        setTimeout(function() {
          callback(err2);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service3();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure6;
    function configure6() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure6();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal2();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs
var require_rpc3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal4());
    })(exports2, function($protobuf10) {
      "use strict";
      var $Reader9 = $protobuf10.Reader, $Writer9 = $protobuf10.Writer, $util9 = $protobuf10.util;
      var $root9 = $protobuf10.roots["default"] || ($protobuf10.roots["default"] = {});
      $root9.RPC = function() {
        function RPC3(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        RPC3.prototype.subscriptions = $util9.emptyArray;
        RPC3.prototype.messages = $util9.emptyArray;
        RPC3.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC3.prototype, "_control", {
          get: $util9.oneOfGetter($oneOfFields = ["control"]),
          set: $util9.oneOfSetter($oneOfFields)
        });
        RPC3.encode = function encode81(m, w) {
          if (!w)
            w = $Writer9.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i2 = 0; i2 < m.subscriptions.length; ++i2)
              $root9.RPC.SubOpts.encode(m.subscriptions[i2], w.uint32(10).fork()).ldelim();
          }
          if (m.messages != null && m.messages.length) {
            for (var i2 = 0; i2 < m.messages.length; ++i2)
              $root9.RPC.Message.encode(m.messages[i2], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root9.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC3.decode = function decode97(r, l) {
          if (!(r instanceof $Reader9))
            r = $Reader9.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root9.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.messages && m.messages.length))
                  m.messages = [];
                m.messages.push($root9.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root9.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC3.fromObject = function fromObject(d) {
          if (d instanceof $root9.RPC)
            return d;
          var m = new $root9.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i2 = 0; i2 < d.subscriptions.length; ++i2) {
              if (typeof d.subscriptions[i2] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i2] = $root9.RPC.SubOpts.fromObject(d.subscriptions[i2]);
            }
          }
          if (d.messages) {
            if (!Array.isArray(d.messages))
              throw TypeError(".RPC.messages: array expected");
            m.messages = [];
            for (var i2 = 0; i2 < d.messages.length; ++i2) {
              if (typeof d.messages[i2] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m.messages[i2] = $root9.RPC.Message.fromObject(d.messages[i2]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root9.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC3.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.messages = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root9.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.messages && m.messages.length) {
            d.messages = [];
            for (var j = 0; j < m.messages.length; ++j) {
              d.messages[j] = $root9.RPC.Message.toObject(m.messages[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root9.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC3.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
        };
        RPC3.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util9.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
              w.uint32(18).string(m.topic);
            return w;
          };
          SubOpts.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.SubOpts)
              return d;
            var m = new $root9.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
              if (o.oneofs)
                d._topic = "topic";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC3.Message = function() {
          function Message4(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          Message4.prototype.from = null;
          Message4.prototype.data = null;
          Message4.prototype.seqno = null;
          Message4.prototype.topic = "";
          Message4.prototype.signature = null;
          Message4.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message4.prototype, "_from", {
            get: $util9.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_data", {
            get: $util9.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_seqno", {
            get: $util9.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_signature", {
            get: $util9.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_key", {
            get: $util9.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Message4.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            w.uint32(34).string(m.topic);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message4.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  m.topic = r.string();
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("topic"))
              throw $util9.ProtocolError("missing required 'topic'", { instance: m });
            return m;
          };
          Message4.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.Message)
              return d;
            var m = new $root9.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util9.base64.decode(d.from, m.from = $util9.newBuffer($util9.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util9.base64.decode(d.data, m.data = $util9.newBuffer($util9.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util9.base64.decode(d.seqno, m.seqno = $util9.newBuffer($util9.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util9.base64.decode(d.signature, m.signature = $util9.newBuffer($util9.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util9.base64.decode(d.key, m.key = $util9.newBuffer($util9.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message4.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.topic = "";
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util9.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util9.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util9.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util9.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util9.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message4.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return Message4;
        }();
        RPC3.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlMessage.prototype.ihave = $util9.emptyArray;
          ControlMessage.prototype.iwant = $util9.emptyArray;
          ControlMessage.prototype.graft = $util9.emptyArray;
          ControlMessage.prototype.prune = $util9.emptyArray;
          ControlMessage.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i2 = 0; i2 < m.ihave.length; ++i2)
                $root9.RPC.ControlIHave.encode(m.ihave[i2], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i2 = 0; i2 < m.iwant.length; ++i2)
                $root9.RPC.ControlIWant.encode(m.iwant[i2], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i2 = 0; i2 < m.graft.length; ++i2)
                $root9.RPC.ControlGraft.encode(m.graft[i2], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i2 = 0; i2 < m.prune.length; ++i2)
                $root9.RPC.ControlPrune.encode(m.prune[i2], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root9.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root9.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root9.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root9.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlMessage)
              return d;
            var m = new $root9.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i2 = 0; i2 < d.ihave.length; ++i2) {
                if (typeof d.ihave[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i2] = $root9.RPC.ControlIHave.fromObject(d.ihave[i2]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i2 = 0; i2 < d.iwant.length; ++i2) {
                if (typeof d.iwant[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i2] = $root9.RPC.ControlIWant.fromObject(d.iwant[i2]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i2 = 0; i2 < d.graft.length; ++i2) {
                if (typeof d.graft[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i2] = $root9.RPC.ControlGraft.fromObject(d.graft[i2]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i2 = 0; i2 < d.prune.length; ++i2) {
                if (typeof d.prune[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i2] = $root9.RPC.ControlPrune.fromObject(d.prune[i2]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root9.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root9.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root9.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root9.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC3.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util9.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
                w.uint32(18).bytes(m.messageIDs[i2]);
            }
            return w;
          };
          ControlIHave.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlIHave)
              return d;
            var m = new $root9.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
                if (typeof d.messageIDs[i2] === "string")
                  $util9.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util9.newBuffer($util9.base64.length(d.messageIDs[i2])), 0);
                else if (d.messageIDs[i2].length)
                  m.messageIDs[i2] = d.messageIDs[i2];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util9.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC3.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlIWant.prototype.messageIDs = $util9.emptyArray;
          ControlIWant.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
                w.uint32(10).bytes(m.messageIDs[i2]);
            }
            return w;
          };
          ControlIWant.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlIWant)
              return d;
            var m = new $root9.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
                if (typeof d.messageIDs[i2] === "string")
                  $util9.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util9.newBuffer($util9.base64.length(d.messageIDs[i2])), 0);
                else if (d.messageIDs[i2].length)
                  m.messageIDs[i2] = d.messageIDs[i2];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util9.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC3.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlGraft)
              return d;
            var m = new $root9.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC3.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util9.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util9.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i2 = 0; i2 < m.peers.length; ++i2)
                $root9.RPC.PeerInfo.encode(m.peers[i2], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root9.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlPrune)
              return d;
            var m = new $root9.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i2 = 0; i2 < d.peers.length; ++i2) {
                if (typeof d.peers[i2] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i2] = $root9.RPC.PeerInfo.fromObject(d.peers[i2]);
              }
            }
            if (d.backoff != null) {
              if ($util9.Long)
                (m.backoff = $util9.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util9.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root9.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util9.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util9.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC3.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util9.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = function encode81(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo.decode = function decode97(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.PeerInfo)
              return d;
            var m = new $root9.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util9.base64.decode(d.peerID, m.peerID = $util9.newBuffer($util9.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util9.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util9.newBuffer($util9.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util9.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util9.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return PeerInfo;
        }();
        return RPC3;
      }();
      return $root9;
    });
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque2(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque2.prototype.peekAt = function peekAt(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i2 >= len || i2 < -len)
        return void 0;
      if (i2 < 0)
        i2 += len;
      i2 = this._head + i2 & this._capacityMask;
      return this._list[i2];
    };
    Denque2.prototype.get = function get3(i2) {
      return this.peekAt(i2);
    };
    Denque2.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque2.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque2.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque2.prototype, "length", {
      get: function length23() {
        return this.size();
      }
    });
    Denque2.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.removeOne = function removeOne(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size)
        return void 0;
      if (i2 < 0)
        i2 += size;
      i2 = this._head + i2 & this._capacityMask;
      var item = this._list[i2];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 - 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 + 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque2.prototype.remove = function remove(index, count) {
      var i2 = index;
      var removed;
      var del_count = count;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size || count < 1)
        return void 0;
      if (i2 < 0)
        i2 += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i2);
        return removed;
      }
      if (i2 === 0 && i2 + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i2 + count > size)
        count = size - i2;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i2 + k & this._capacityMask];
      }
      i2 = this._head + i2 & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i2 < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i2 = i2 - 1 + len & this._capacityMask]);
        }
        i2 = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i2 = i2 - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i2;
      } else {
        this._tail = i2;
        i2 = i2 + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i2++]);
        }
        i2 = this._tail;
        while (del_count > 0) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque2.prototype.splice = function splice(index, count) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i2 < 0)
        i2 += size;
      if (i2 > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i2 < size / 2) {
          temp = new Array(i2);
          for (k = 0; k < i2; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 > 0) {
              this._head = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._head = this._head + i2 + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i2; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i2 + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 != size) {
              this._tail = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i2, count);
      }
    };
    Denque2.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque2.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque2.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque2.prototype._fromArray = function _fromArray(array) {
      for (var i2 = 0; i2 < array.length; i2++)
        this.push(array[i2]);
    };
    Denque2.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i2;
      if (fullCopy || this._head > this._tail) {
        for (i2 = this._head; i2 < len; i2++)
          newArray.push(list[i2]);
        for (i2 = 0; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      } else {
        for (i2 = this._head; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      }
      return newArray;
    };
    Denque2.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque2.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque2;
  }
});

// node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "node_modules/stream-to-it/source.js"(exports2, module2) {
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator])
        return readable;
      if (readable.getReader) {
        return async function* () {
          const reader6 = readable.getReader();
          try {
            while (true) {
              const { done, value: value2 } = await reader6.read();
              if (done)
                return;
              yield value2;
            }
          } finally {
            reader6.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});

// browser-external:ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "browser-external:ipfs-utils/src/files/glob-source.js"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "ipfs-utils/src/files/glob-source.js" has been externalized for browser compatibility. Cannot access "ipfs-utils/src/files/glob-source.js.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    "use strict";
    var HTTP6 = require_http();
    var urlSource2 = (url2, options) => {
      return {
        path: decodeURIComponent(new URL(url2).pathname.split("/").pop() || ""),
        content: readURLContent(url2, options)
      };
    };
    async function* readURLContent(url2, options) {
      const http = new HTTP6();
      const response = await http.get(url2, options);
      yield* response.iterator();
    }
    module2.exports = urlSource2;
  }
});

// node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS({
  "node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    function randomBytes3(size) {
      const bytes2 = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(
                bytes2.subarray(generated, generated + (size - generated))
              );
              generated += size - generated;
            } else {
              crypto.getRandomValues(
                bytes2.subarray(generated, generated + MAX_BYTES)
              );
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes2);
        }
      }
      return bytes2;
    }
    module2.exports = randomBytes3;
  }
});

// node_modules/delay/index.js
var require_delay = __commonJS({
  "node_modules/delay/index.js"(exports2, module2) {
    "use strict";
    var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
    var createAbortError = () => {
      const error = new Error("Delay aborted");
      error.name = "AbortError";
      return error;
    };
    var createDelay = ({ clearTimeout: defaultClear, setTimeout: set2, willResolve }) => (ms, { value: value2, signal } = {}) => {
      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFn;
      const clear = defaultClear || clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFn(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve7, reject) => {
        settle = () => {
          cleanup();
          if (willResolve) {
            resolve7(value2);
          } else {
            reject(value2);
          }
        };
        rejectFn = reject;
        timeoutId = (set2 || setTimeout)(settle, ms);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      delayPromise.clear = () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      };
      return delayPromise;
    };
    var createWithTimers = (clearAndSet) => {
      const delay4 = createDelay({ ...clearAndSet, willResolve: true });
      delay4.reject = createDelay({ ...clearAndSet, willResolve: false });
      delay4.range = (minimum, maximum, options) => delay4(randomInteger(minimum, maximum), options);
      return delay4;
    };
    var delay3 = createWithTimers();
    delay3.createWithTimers = createWithTimers;
    module2.exports = delay3;
    module2.exports.default = delay3;
  }
});

// node_modules/set-delayed-interval/src/index.js
var require_src4 = __commonJS({
  "node_modules/set-delayed-interval/src/index.js"(exports2, module2) {
    "use strict";
    var intervals = /* @__PURE__ */ new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err2) {
          setTimeout(() => {
            throw err2;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve7) => {
          const _timeout = setTimeout(resolve7, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval3(task, interval, delay3) {
      delay3 = delay3 || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay3);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval3(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module2.exports = {
      setDelayedInterval: setDelayedInterval3,
      clearDelayedInterval: clearDelayedInterval3
    };
  }
});

// node_modules/libp2p/node_modules/it-sort/index.js
var require_it_sort = __commonJS({
  "node_modules/libp2p/node_modules/it-sort/index.js"(exports2, module2) {
    "use strict";
    var all12 = require_it_all();
    var sort5 = async function* (source, sorter) {
      const arr = await all12(source);
      yield* arr.sort(sorter);
    };
    module2.exports = sort5;
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports2) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i2, j, n, ref;
        b = [];
        for (i2 = j = 0; j <= 3; i2 = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i2 > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base30, dmax, i2, n, start;
        n = 0;
        base30 = 10;
        dmax = "9";
        i2 = 0;
        if (s.length > 1 && s[i2] === "0") {
          if (s[i2 + 1] === "x" || s[i2 + 1] === "X") {
            i2 += 2;
            base30 = 16;
          } else if ("0" <= s[i2 + 1] && s[i2 + 1] <= "9") {
            i2++;
            base30 = 8;
            dmax = "7";
          }
        }
        start = i2;
        while (i2 < s.length) {
          if ("0" <= s[i2] && s[i2] <= dmax) {
            n = n * base30 + (chr(s[i2]) - chr0) >>> 0;
          } else if (base30 === 16) {
            if ("a" <= s[i2] && s[i2] <= "f") {
              n = n * base30 + (10 + chr(s[i2]) - chra) >>> 0;
            } else if ("A" <= s[i2] && s[i2] <= "F") {
              n = n * base30 + (10 + chr(s[i2]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i2++;
        }
        if (i2 === start) {
          throw new Error("empty octet");
        }
        return [n, i2];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i2, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i2 = j = 32; j >= 0; i2 = --j) {
              if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
                this.bitmask = i2;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports2.ip2long = ip2long;
      exports2.long2ip = long2ip;
      exports2.Netmask = Netmask2;
    }).call(exports2);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string14, parts2) {
        if (string14.indexOf("::") !== string14.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string14.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string14 = string14.replace(/%.+$/, "");
        }
        while ((lastColon = string14.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string14.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string14.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts2) {
          return null;
        }
        replacementCount = parts2 - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string14 = string14.replace("::", replacement);
        if (string14[0] === ":") {
          string14 = string14.slice(1);
        }
        if (string14[string14.length - 1] === ":") {
          string14 = string14.slice(0, -1);
        }
        parts2 = function() {
          const ref = string14.split(":");
          const results = [];
          for (let i2 = 0; i2 < ref.length; i2++) {
            results.push(parseInt(ref[i2], 16));
          }
          return results;
        }();
        return {
          parts: parts2,
          zoneId
        };
      }
      function matchCIDR(first10, second3, partSize, cidrBits) {
        if (first10.length !== second3.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first10[part] >> shift !== second3[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string14) {
        if (hexRegex.test(string14)) {
          return parseInt(string14, 16);
        }
        if (string14[0] === "0" && !isNaN(parseInt(string14[1], 10))) {
          if (octalRegex.test(string14)) {
            return parseInt(string14, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string14} as octal`);
        }
        return parseInt(string14, 10);
      }
      function padPart(part, length23) {
        while (part.length < length23) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr2 = {};
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i2, octet;
          for (i2 = 0; i2 < octets.length; i2++) {
            octet = octets[i2];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i2, octet, zeros;
          for (i2 = 3; i2 >= 0; i2 -= 1) {
            octet = this.octets[i2];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string14) {
        try {
          const cidr = this.parseCIDR(string14);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i2 = 0;
          while (i2 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string14) {
        return this.parser(string14) !== null;
      };
      ipaddr2.IPv4.isValid = function(string14) {
        try {
          new this(this.parser(string14));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string14) {
        if (ipaddr2.IPv4.isValid(string14) && string14.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string14) {
        let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string14);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i2 = 0;
          while (i2 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string14) {
        const parts2 = this.parser(string14);
        if (parts2 === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts2);
      };
      ipaddr2.IPv4.parseCIDR = function(string14) {
        let match;
        if (match = string14.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string14) {
        let match, part, value2;
        if (match = string14.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i2 = 0; i2 < ref.length; i2++) {
              part = ref[i2];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string14.match(ipv4Regexes.longValue)) {
          value2 = parseIntAuto(match[1]);
          if (value2 > 4294967295 || value2 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value2 >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string14.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value2 = parseIntAuto(ref[1]);
            if (value2 > 16777215 || value2 < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value2 >> 16 & 255);
            results.push(value2 >> 8 & 255);
            results.push(value2 & 255);
            return results;
          }();
        } else if (match = string14.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value2 = parseIntAuto(ref[2]);
            if (value2 > 65535 || value2 < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value2 >> 8 & 255);
            results.push(value2 & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts2, zoneId) {
          let i2, part;
          if (parts2.length === 16) {
            this.parts = [];
            for (i2 = 0; i2 <= 14; i2 += 2) {
              this.parts.push(parts2[i2] << 8 | parts2[i2 + 1]);
            }
          } else if (parts2.length === 8) {
            this.parts = parts2;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i2 = 0; i2 < this.parts.length; i2++) {
            part = this.parts[i2];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i2 = 7; i2 >= 0; i2 -= 1) {
            part = this.parts[i2];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i2 = 0; i2 < ref.length; i2++) {
            part = ref[i2];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i2 = 0; i2 < this.parts.length; i2++) {
              results.push(padPart(this.parts[i2].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i2 = 0; i2 < this.parts.length; i2++) {
              results.push(this.parts[i2].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string14 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string14)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string14;
          }
          return `${string14.substring(0, bestMatchIndex)}::${string14.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string14) {
        try {
          const cidr = this.parseCIDR(string14);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i2 = 0;
          while (i2 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string14) {
        return this.parser(string14) !== null;
      };
      ipaddr2.IPv6.isValid = function(string14) {
        if (typeof string14 === "string" && string14.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string14);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string14) {
        let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string14);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i2 = 0;
          while (i2 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string14) {
        const addr = this.parser(string14);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string14) {
        let maskLength, match, parsed;
        if (match = string14.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string14) {
        let addr, i2, match, octet, octets, zoneId;
        if (match = string14.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string14)) {
          return expandIPv6(string14, 8);
        }
        if (match = string14.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i2 = 0; i2 < octets.length; i2++) {
              octet = octets[i2];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes2) {
        const length23 = bytes2.length;
        if (length23 === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length23 === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string14) {
        return ipaddr2.IPv6.isValid(string14) || ipaddr2.IPv4.isValid(string14);
      };
      ipaddr2.parse = function(string14) {
        if (ipaddr2.IPv6.isValid(string14)) {
          return ipaddr2.IPv6.parse(string14);
        } else if (ipaddr2.IPv4.isValid(string14)) {
          return ipaddr2.IPv4.parse(string14);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string14) {
        try {
          return ipaddr2.IPv6.parseCIDR(string14);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string14);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string14) {
        const addr = this.parse(string14);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i2, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i2 = 0; i2 < rangeSubnets.length; i2++) {
              subnet = rangeSubnets[i2];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr2;
      } else {
        root.ipaddr = ipaddr2;
      }
    })(exports2);
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate(getLength, string14, byteLength2) {
      if (typeof string14 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string14.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i2 = 0; i2 < charLength; i2 += 1) {
        codePoint = string14.charCodeAt(i2);
        segment = string14[i2];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string14.charCodeAt(i2 + 1))) {
          i2 += 1;
          segment += string14[i2];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength2) {
          return string14.slice(0, i2 + 1);
        } else if (curByteLength > byteLength2) {
          return string14.slice(0, i2 - segment.length + 1);
        }
      }
      return string14;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser4 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string14) {
      if (typeof string14 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string14.length;
      var byteLength2 = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i2 = 0; i2 < charLength; i2++) {
        codePoint = string14.charCodeAt(i2);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength2 += 1;
          } else {
            byteLength2 += 3;
          }
        } else if (codePoint <= 127) {
          byteLength2 += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength2 += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength2 += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength2;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser5 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser4();
    module2.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports2, module2) {
    "use strict";
    var truncate = require_browser5();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge9.asn1;
    var p7v = module2.exports = forge9.pkcs7asn1 = forge9.pkcs7asn1 || {};
    forge9.pkcs7 = forge9.pkcs7 || {};
    forge9.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    forge9.mgf = forge9.mgf || {};
    var mgf1 = module2.exports = forge9.mgf.mgf1 = forge9.mgf1 = forge9.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed2, maskLen) {
          var t = new forge9.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c = new forge9.util.ByteBuffer();
            c.putInt32(i2);
            md.start();
            md.update(seed2 + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    var forge9 = require_forge();
    require_mgf1();
    module2.exports = forge9.mgf = forge9.mgf || {};
    forge9.mgf.mgf1 = forge9.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    var forge9 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge9.pss = forge9.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash3 = options.md;
      var mgf = options.mgf;
      var hLen = hash3.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge9.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge9.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge9.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h = hash3.digest().getBytes();
        var ps = new forge9.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge9.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h_ = hash3.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge9.asn1;
    var pki2 = module2.exports = forge9.pki = forge9.pki || {};
    var oids = pki2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge9.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set2 = rdn.value[si];
        for (var i2 = 0; i2 < set2.value.length; ++i2) {
          obj = {};
          attr = set2.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors2;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge9.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge9.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge9.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge9.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge9.md.sha512.create();
        case "RSASSA-PSS":
          return forge9.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash3, mgf;
          hash3 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash3 === void 0 || forge9.md[hash3] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge9.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge9.mgf[mgf].create(forge9.md[hash3].create());
          hash3 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash3 === void 0 || forge9.md[hash3] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          scheme = forge9.pss.create(
            forge9.md[hash3].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki2.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificateFromAsn1(obj, computeHash);
    };
    pki2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.publicKeyFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.publicKeyFromAsn1(obj);
    };
    pki2.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge9.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes2;
      switch (type) {
        case "RSAPublicKey":
          bytes2 = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes2 = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes2);
      var digest15 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest15.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest15.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest15;
    };
    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext = cert.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge9.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki2.getTBSCertificate(cert);
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
          var bytes2 = asn1.toDer(tbsCertificate);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i2 = cert.issuer;
        var s = parent2.subject;
        if (i2.hash && s.hash) {
          rval = i2.hash === s.hash;
        } else if (i2.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i2.attributes.length; ++n) {
            iattr = i2.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext = cert.extensions[i2];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge9.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors2)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge9.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge9.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge9.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
      }
      var imd = forge9.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge9.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki2.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value2 = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value2 = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value2 = ev.value[1].value;
          }
          if (value2 !== null) {
            e.pathLenConstraint = asn1.derToInteger(value2);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge9.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge9.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge9.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge9.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
      }
      var smd = forge9.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki2.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki2.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge9.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          var bytes2 = asn1.toDer(cri);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set2;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value2 = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value2 = forge9.util.encodeUtf8(value2);
          }
        }
        set2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value2)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki2.oids) {
            attr.name = pki2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki2.oids) {
            attr.type = pki2.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki2.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki2.oids) {
          e.name = pki2.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki2.oids) {
          e.id = pki2.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value2 = String.fromCharCode(unused);
        if (b3 !== 0) {
          value2 += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value2 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value2
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value2 = String.fromCharCode(unused);
        if (b2 !== 0) {
          value2 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value2
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value2 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value2 = forge9.util.bytesFromIP(altName.ip);
            if (value2 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value2 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value2 = asn1.oidToDer(value2);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value2
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge9.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value2 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value2 = forge9.util.bytesFromIP(altName.ip);
            if (value2 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value2 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value2 = asn1.oidToDer(value2);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value2
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts2 = [];
          if (params.hash.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts2);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value2 = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value2 = forge9.util.encodeUtf8(value2);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value2
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge9.util.hexToBytes(cert.serialNumber)
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        _dnToAsn1(cert.issuer),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki2.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        _dnToAsn1(csr.subject),
        pki2.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki2.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq.value.push(pki2.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki2.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value2 = ext.value;
      if (typeof ext.value !== "string") {
        value2 = asn1.toDer(value2).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value2
      ));
      return extseq;
    };
    pki2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        cri,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki2.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge9.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge9.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash3 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash3)) {
            var value2 = caStore.certs[hash3];
            if (!forge9.util.isArray(value2)) {
              certList.push(value2);
            } else {
              for (var i3 = 0; i3 < value2.length; ++i3) {
                certList.push(value2[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge9.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            result = match[i3];
            match.splice(i3, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge9.md.sha1.create();
          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki2.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first10 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge9.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki2.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki2.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
            var ext = cert.extensions[i2];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first10 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge9.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first10 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge9.asn1;
    var p7 = module2.exports = forge9.pkcs7 = forge9.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge9.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors2;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge9.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge9.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge9.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge9.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge9.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              signedData
            ]
          );
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge9.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge9.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge9.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge9.pki.oids.sha1:
            case forge9.pki.oids.sha256:
            case forge9.pki.oids.sha384:
            case forge9.pki.oids.sha512:
            case forge9.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge9.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge9.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge9.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge9.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge9.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge9.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge9.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge9.md[forge9.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge9.md[forge9.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes2 = asn1.toDer(content);
        bytes2.getByte();
        asn1.getBerValueLength(bytes2);
        bytes2 = bytes2.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes2);
        }
        var signingTime = new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge9.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge9.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge9.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes2 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes2);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge9.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge9.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r = msg.recipients[i2];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge9.pki.oids.rsaEncryption:
              case forge9.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge9.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge9.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge9.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge9.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge9.util.createBuffer(forge9.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge9.util.createBuffer(
              forge9.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge9.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors2;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge9.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge9.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge9.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge9.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value2;
      if (attr.type === forge9.pki.oids.contentType) {
        value2 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge9.pki.oids.messageDigest) {
        value2 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge9.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value2 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value2 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value2
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge9.pki.oids.data).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, validator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge9.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge9.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge9.util.createBuffer(capture.encParameter.value),
          content: forge9.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge9.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge9.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge9.pki.oids["aes128-CBC"]:
          case forge9.pki.oids["aes192-CBC"]:
          case forge9.pki.oids["aes256-CBC"]:
            ciph = forge9.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge9.pki.oids["desCBC"]:
          case forge9.pki.oids["des-EDE3-CBC"]:
            ciph = forge9.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/it-foreach/index.js
var require_it_foreach = __commonJS({
  "node_modules/it-foreach/index.js"(exports2, module2) {
    "use strict";
    var each3 = async function* (source, fn) {
      for await (const thing of source) {
        await fn(thing);
        yield thing;
      }
    };
    module2.exports = each3;
  }
});

// node_modules/mutable-proxy/build/index.js
var require_build = __commonJS({
  "node_modules/mutable-proxy/build/index.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module2.exports = function mutableProxyFactory(defaultTarget) {
      var mutableHandler = void 0;
      var mutableTarget = void 0;
      function setTarget(target) {
        if (!(target instanceof Object)) {
          throw new Error('Target "' + target + '" is not an object');
        }
        mutableTarget = target;
      }
      function setHandler(handler2) {
        Object.keys(handler2).forEach(function(key) {
          var value2 = handler2[key];
          if (typeof value2 !== "function") {
            throw new Error('Trap "' + key + ": " + value2 + '" is not a function');
          }
          if (!Reflect[key]) {
            throw new Error('Trap "' + key + ": " + value2 + '" is not a valid trap');
          }
        });
        mutableHandler = handler2;
      }
      setTarget(function() {
      });
      if (defaultTarget) {
        setTarget(defaultTarget);
      }
      setHandler(Reflect);
      var handler = new Proxy({}, {
        get: function get3(target, property) {
          return function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
          };
        }
      });
      return {
        setTarget,
        setHandler,
        getTarget: function getTarget() {
          return mutableTarget;
        },
        getHandler: function getHandler() {
          return mutableHandler;
        },
        proxy: new Proxy(mutableTarget, handler)
      };
    };
  }
});

// node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "node_modules/ip-regex/index.js"(exports2, module2) {
    "use strict";
    var word2 = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word2})|(?<=${word2})(?=\\s|$))` : "";
    var v42 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v62 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v42}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v42}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v42}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v42}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v42}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v42}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v42}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact2 = new RegExp(`(?:^${v42}$)|(?:^${v62}$)`);
    var v4exact2 = new RegExp(`^${v42}$`);
    var v6exact2 = new RegExp(`^${v62}$`);
    var ip = (options) => options && options.exact ? v46Exact2 : new RegExp(`(?:${b(options)}${v42}${b(options)})|(?:${b(options)}${v62}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact2 : new RegExp(`${b(options)}${v42}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact2 : new RegExp(`${b(options)}${v62}${b(options)}`, "g");
    module2.exports = ip;
  }
});

// node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "node_modules/is-ip/index.js"(exports2, module2) {
    "use strict";
    var ipRegex2 = require_ip_regex();
    var isIp = (string14) => ipRegex2({ exact: true }).test(string14);
    isIp.v4 = (string14) => ipRegex2.v4({ exact: true }).test(string14);
    isIp.v6 = (string14) => ipRegex2.v6({ exact: true }).test(string14);
    isIp.version = (string14) => isIp(string14) ? isIp.v4(string14) ? 4 : 6 : void 0;
    module2.exports = isIp;
  }
});

// node_modules/private-ip/lib/index.js
var require_lib = __commonJS({
  "node_modules/private-ip/lib/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var netmask_1 = require_netmask();
    var ip_regex_1 = __importDefault(require_ip_regex());
    var is_ip_1 = __importDefault(require_is_ip());
    var ipaddr_js_1 = require_ipaddr();
    var PRIVATE_IP_RANGES2 = [
      "0.0.0.0/8",
      "10.0.0.0/8",
      "100.64.0.0/10",
      "127.0.0.0/8",
      "169.254.0.0/16",
      "172.16.0.0/12",
      "192.0.0.0/24",
      "192.0.0.0/29",
      "192.0.0.8/32",
      "192.0.0.9/32",
      "192.0.0.10/32",
      "192.0.0.170/32",
      "192.0.0.171/32",
      "192.0.2.0/24",
      "192.31.196.0/24",
      "192.52.193.0/24",
      "192.88.99.0/24",
      "192.168.0.0/16",
      "192.175.48.0/24",
      "198.18.0.0/15",
      "198.51.100.0/24",
      "203.0.113.0/24",
      "240.0.0.0/4",
      "255.255.255.255/32"
    ];
    var NETMASK_RANGES2 = PRIVATE_IP_RANGES2.map((ip_range) => new netmask_1.Netmask(ip_range));
    function ipv4_check2(ip_addr) {
      for (let r of NETMASK_RANGES2) {
        if (r.contains(ip_addr))
          return true;
      }
      return false;
    }
    function ipv6_check2(ip_addr) {
      return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
    }
    exports2.default = (ip) => {
      if ((0, ipaddr_js_1.isValid)(ip)) {
        const parsed = (0, ipaddr_js_1.parse)(ip);
        if (parsed.kind() === "ipv4")
          return ipv4_check2(parsed.toNormalizedString());
        else if (parsed.kind() === "ipv6")
          return ipv6_check2(ip);
      } else if ((0, is_ip_1.default)(ip) && ip_regex_1.default.v6().test(ip))
        return ipv6_check2(ip);
      return void 0;
    };
  }
});

// node_modules/private-ip/index.js
var require_private_ip = __commonJS({
  "node_modules/private-ip/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib().default;
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Receptacle2;
    var toMS = require_ms();
    var cache19 = Receptacle2.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle2(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl2, i2 = this.items.length; i2--; ) {
        item = this.items[i2];
        ttl2 = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl2 > 0)
          this.expire(item.key, ttl2);
        else if (ttl2 <= 0)
          this.delete(item.key);
      }
    }
    cache19.has = function(key) {
      return key in this._lookup;
    };
    cache19.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache19.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache19.set = function(key, value2, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value: value2 };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache19.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache19.expire = function(key, ttl2) {
      var ms = ttl2 || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl2);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache19.clear = function() {
      for (var i2 = this.items.length; i2--; )
        this.delete(this.items[i2].key);
      return this;
    };
    cache19.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i2 = items.length; i2--; ) {
        item = this.items[i2];
        items[i2] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// node_modules/p-fifo/node_modules/p-defer/index.js
var require_p_defer2 = __commonJS({
  "node_modules/p-fifo/node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    var pDefer2 = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve7, reject) => {
        deferred.resolve = resolve7;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer2;
  }
});

// node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "node_modules/p-fifo/index.js"(exports2, module2) {
    var Fifo = require_fast_fifo();
    var defer = require_p_defer2();
    module2.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve7 } = defer();
        this._buffer.push({ chunk, resolve: resolve7 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve7 } = defer();
        this._waitingConsumers.push({ resolve: resolve7 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer2 = require_buffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src18, dst) {
      for (var key in src18) {
        dst[key] = src18[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length23) {
      return Buffer2(arg, encodingOrOffset, length23);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length23) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length23);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser6 = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto4 = global.crypto || global.msCrypto;
    if (crypto4 && crypto4.getRandomValues) {
      module2.exports = randomBytes3;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes3(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes2 = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto4.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto4.getRandomValues(bytes2);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes2);
        });
      }
      return bytes2;
    }
  }
});

// node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "node_modules/k-bucket/index.js"(exports2, module2) {
    "use strict";
    var randomBytes3 = require_browser6();
    var { EventEmitter: EventEmitter6 } = require_events();
    function arrayEquals2(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i2 = 0, length23 = array1.length; i2 < length23; ++i2) {
        if (array1[i2] !== array2[i2]) {
          return false;
        }
      }
      return true;
    }
    function createNode3() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name22, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name22 + " is not a Uint8Array");
      }
    }
    var KBucket = class extends EventEmitter6 {
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes3(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || KBucket.distance;
        this.arbiter = options.arbiter || KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode3();
      }
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      static distance(firstId, secondId) {
        let distance = 0;
        let i2 = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i2 < min; ++i2) {
          distance = distance * 256 + (firstId[i2] ^ secondId[i2]);
        }
        for (; i2 < max; ++i2)
          distance = distance * 256 + 255;
        return distance;
      }
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      _indexOf(node, id) {
        for (let i2 = 0; i2 < node.contacts.length; ++i2) {
          if (arrayEquals2(node.contacts[i2].id, id))
            return i2;
        }
        return -1;
      }
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      _split(node, bitIndex) {
        node.left = createNode3();
        node.right = createNode3();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      _update(node, index, contact) {
        if (!arrayEquals2(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module2.exports = KBucket;
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value2) {
        if (this.isStopped)
          return;
        const resolution = { value: value2, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value2) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve7, reject) => {
                this.pullQueue.push({ resolve: resolve7, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value2) => queue.push(value2),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports2.EventIterator = EventIterator2;
    exports2.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports2.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports2.subscribe = subscribe;
    exports2.default = event_iterator_1.EventIterator;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js
var require_RateLimiterAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js"(exports2, module2) {
    module2.exports = class RateLimiterAbstract {
      constructor(opts = {}) {
        this.points = opts.points;
        this.duration = opts.duration;
        this.blockDuration = opts.blockDuration;
        this.execEvenly = opts.execEvenly;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
        this.keyPrefix = opts.keyPrefix;
      }
      get points() {
        return this._points;
      }
      set points(value2) {
        this._points = value2 >= 0 ? value2 : 4;
      }
      get duration() {
        return this._duration;
      }
      set duration(value2) {
        this._duration = typeof value2 === "undefined" ? 1 : value2;
      }
      get msDuration() {
        return this.duration * 1e3;
      }
      get blockDuration() {
        return this._blockDuration;
      }
      set blockDuration(value2) {
        this._blockDuration = typeof value2 === "undefined" ? 0 : value2;
      }
      get msBlockDuration() {
        return this.blockDuration * 1e3;
      }
      get execEvenly() {
        return this._execEvenly;
      }
      set execEvenly(value2) {
        this._execEvenly = typeof value2 === "undefined" ? false : Boolean(value2);
      }
      get execEvenlyMinDelayMs() {
        return this._execEvenlyMinDelayMs;
      }
      set execEvenlyMinDelayMs(value2) {
        this._execEvenlyMinDelayMs = typeof value2 === "undefined" ? Math.ceil(this.msDuration / this.points) : value2;
      }
      get keyPrefix() {
        return this._keyPrefix;
      }
      set keyPrefix(value2) {
        if (typeof value2 === "undefined") {
          value2 = "rlflx";
        }
        if (typeof value2 !== "string") {
          throw new Error("keyPrefix must be string");
        }
        this._keyPrefix = value2;
      }
      _getKeySecDuration(options = {}) {
        return options && options.customDuration >= 0 ? options.customDuration : this.duration;
      }
      getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
      }
      parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
      }
      consume() {
        throw new Error("You have to implement the method 'consume'!");
      }
      penalty() {
        throw new Error("You have to implement the method 'penalty'!");
      }
      reward() {
        throw new Error("You have to implement the method 'reward'!");
      }
      get() {
        throw new Error("You have to implement the method 'get'!");
      }
      set() {
        throw new Error("You have to implement the method 'set'!");
      }
      block() {
        throw new Error("You have to implement the method 'block'!");
      }
      delete() {
        throw new Error("You have to implement the method 'delete'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js
var require_BlockedKeys = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js"(exports2, module2) {
    module2.exports = class BlockedKeys {
      constructor() {
        this._keys = {};
        this._addedKeysAmount = 0;
      }
      collectExpired() {
        const now = Date.now();
        Object.keys(this._keys).forEach((key) => {
          if (this._keys[key] <= now) {
            delete this._keys[key];
          }
        });
        this._addedKeysAmount = Object.keys(this._keys).length;
      }
      add(key, sec) {
        this.addMs(key, sec * 1e3);
      }
      addMs(key, ms) {
        this._keys[key] = Date.now() + ms;
        this._addedKeysAmount++;
        if (this._addedKeysAmount > 999) {
          this.collectExpired();
        }
      }
      msBeforeExpire(key) {
        const expire = this._keys[key];
        if (expire && expire >= Date.now()) {
          this.collectExpired();
          const now = Date.now();
          return expire >= now ? expire - now : 0;
        }
        return 0;
      }
      delete(key) {
        if (key) {
          delete this._keys[key];
        } else {
          Object.keys(this._keys).forEach((key2) => {
            delete this._keys[key2];
          });
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js
var require_BlockedKeys2 = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js"(exports2, module2) {
    var BlockedKeys = require_BlockedKeys();
    module2.exports = BlockedKeys;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRes.js
var require_RateLimiterRes = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRes.js"(exports2, module2) {
    module2.exports = class RateLimiterRes {
      constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
        this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
        this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
        this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
        this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
      }
      get msBeforeNext() {
        return this._msBeforeNext;
      }
      set msBeforeNext(ms) {
        this._msBeforeNext = ms;
        return this;
      }
      get remainingPoints() {
        return this._remainingPoints;
      }
      set remainingPoints(p) {
        this._remainingPoints = p;
        return this;
      }
      get consumedPoints() {
        return this._consumedPoints;
      }
      set consumedPoints(p) {
        this._consumedPoints = p;
        return this;
      }
      get isFirstInDuration() {
        return this._isFirstInDuration;
      }
      set isFirstInDuration(value2) {
        this._isFirstInDuration = Boolean(value2);
      }
      _getDecoratedProperties() {
        return {
          remainingPoints: this.remainingPoints,
          msBeforeNext: this.msBeforeNext,
          consumedPoints: this.consumedPoints,
          isFirstInDuration: this.isFirstInDuration
        };
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this._getDecoratedProperties();
      }
      toString() {
        return JSON.stringify(this._getDecoratedProperties());
      }
      toJSON() {
        return this._getDecoratedProperties();
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js
var require_RateLimiterStoreAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var BlockedKeys = require_BlockedKeys2();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
        this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
        this.insuranceLimiter = opts.insuranceLimiter;
        this._inMemoryBlockedKeys = new BlockedKeys();
      }
      get client() {
        return this._client;
      }
      set client(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("storeClient is not set");
        }
        this._client = value2;
      }
      _afterConsume(resolve7, reject, rlKey, changedPoints, storeResult, options = {}) {
        const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
        if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
          if (res.consumedPoints > this.points) {
            return reject(res);
          } else {
            return resolve7(res);
          }
        } else if (res.consumedPoints > this.points) {
          let blockPromise = Promise.resolve();
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
            res.msBeforeNext = this.msBlockDuration;
            blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
          }
          if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
            this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
            res.msBeforeNext = this.msInMemoryBlockDuration;
          }
          blockPromise.then(() => {
            reject(res);
          }).catch((err2) => {
            reject(err2);
          });
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay3 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay3 < this.execEvenlyMinDelayMs) {
            delay3 = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve7, delay3, res);
        } else {
          resolve7(res);
        }
      }
      _handleError(err2, funcName, resolve7, reject, key, data = false, options = {}) {
        if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {
          reject(err2);
        } else {
          this.insuranceLimiter[funcName](key, data, options).then((res) => {
            resolve7(res);
          }).catch((res) => {
            reject(res);
          });
        }
      }
      get _inmemoryBlockedKeys() {
        return this._inMemoryBlockedKeys;
      }
      getInmemoryBlockMsBeforeExpire(rlKey) {
        return this.getInMemoryBlockMsBeforeExpire(rlKey);
      }
      get inmemoryBlockOnConsumed() {
        return this.inMemoryBlockOnConsumed;
      }
      set inmemoryBlockOnConsumed(value2) {
        this.inMemoryBlockOnConsumed = value2;
      }
      get inmemoryBlockDuration() {
        return this.inMemoryBlockDuration;
      }
      set inmemoryBlockDuration(value2) {
        this.inMemoryBlockDuration = value2;
      }
      get msInmemoryBlockDuration() {
        return this.inMemoryBlockDuration * 1e3;
      }
      getInMemoryBlockMsBeforeExpire(rlKey) {
        if (this.inMemoryBlockOnConsumed > 0) {
          return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
        }
        return 0;
      }
      get inMemoryBlockOnConsumed() {
        return this._inMemoryBlockOnConsumed;
      }
      set inMemoryBlockOnConsumed(value2) {
        this._inMemoryBlockOnConsumed = value2 ? parseInt(value2) : 0;
        if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
          throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
        }
      }
      get inMemoryBlockDuration() {
        return this._inMemoryBlockDuration;
      }
      set inMemoryBlockDuration(value2) {
        this._inMemoryBlockDuration = value2 ? parseInt(value2) : 0;
        if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
          throw new Error("inMemoryBlockOnConsumed option must be set up");
        }
      }
      get msInMemoryBlockDuration() {
        return this._inMemoryBlockDuration * 1e3;
      }
      get insuranceLimiter() {
        return this._insuranceLimiter;
      }
      set insuranceLimiter(value2) {
        if (typeof value2 !== "undefined" && !(value2 instanceof RateLimiterAbstract)) {
          throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
        }
        this._insuranceLimiter = value2;
        if (this._insuranceLimiter) {
          this._insuranceLimiter.blockDuration = this.blockDuration;
          this._insuranceLimiter.execEvenly = this.execEvenly;
        }
      }
      block(key, secDuration, options = {}) {
        const msDuration = secDuration * 1e3;
        return this._block(this.getKey(key), this.points + 1, msDuration, options);
      }
      set(key, points, secDuration, options = {}) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        return this._block(this.getKey(key), points, msDuration, options);
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
          if (inMemoryBlockMsBeforeExpire > 0) {
            return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));
          }
          this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            this._afterConsume(resolve7, reject, rlKey, pointsToConsume, res);
          }).catch((err2) => {
            this._handleError(err2, "consume", resolve7, reject, key, pointsToConsume, options);
          });
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, points, res));
          }).catch((err2) => {
            this._handleError(err2, "penalty", resolve7, reject, key, points, options);
          });
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, -points, res));
          }).catch((err2) => {
            this._handleError(err2, "reward", resolve7, reject, key, points, options);
          });
        });
      }
      get(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._get(rlKey, options).then((res) => {
            if (res === null || typeof res === "undefined") {
              resolve7(null);
            } else {
              resolve7(this._getRateLimiterRes(rlKey, 0, res));
            }
          }).catch((err2) => {
            this._handleError(err2, "get", resolve7, reject, key, options);
          });
        });
      }
      delete(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._delete(rlKey, options).then((res) => {
            this._inMemoryBlockedKeys.delete(rlKey);
            resolve7(res);
          }).catch((err2) => {
            this._handleError(err2, "delete", resolve7, reject, key, options);
          });
        });
      }
      deleteInMemoryBlockedAll() {
        this._inMemoryBlockedKeys.delete();
      }
      _getRateLimiterRes(rlKey, changedPoints, storeResult) {
        throw new Error("You have to implement the method '_getRateLimiterRes'!");
      }
      _block(rlKey, initPoints, msDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
            resolve7(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));
          }).catch((err2) => {
            this._handleError(err2, "block", resolve7, reject, this.parseKey(rlKey), msDuration / 1e3, options);
          });
        });
      }
      _get(rlKey, options = {}) {
        throw new Error("You have to implement the method '_get'!");
      }
      _delete(rlKey, options = {}) {
        throw new Error("You have to implement the method '_delete'!");
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        throw new Error("You have to implement the method '_upsert'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js
var require_RateLimiterRedis = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
    var RateLimiterRedis = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        if (opts.redis) {
          this.client = opts.redis;
        } else {
          this.client = opts.storeClient;
        }
        this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
        if (typeof this.client.defineCommand === "function") {
          this.client.defineCommand("rlflxIncr", {
            numberOfKeys: 1,
            lua: incrTtlLuaScript
          });
        }
      }
      _isRedisReady() {
        if (!this._rejectIfRedisNotReady) {
          return true;
        }
        if (this.client.status && this.client.status !== "ready") {
          return false;
        }
        if (typeof this.client.isReady === "function" && !this.client.isReady()) {
          return false;
        }
        return true;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        let [consumed, resTtlMs] = result;
        if (Array.isArray(consumed)) {
          [, consumed] = consumed;
          [, resTtlMs] = resTtlMs;
        }
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(consumed);
        res.isFirstInDuration = res.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = resTtlMs;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false) {
        return new Promise((resolve7, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          const secDuration = Math.floor(msDuration / 1e3);
          const multi = this.client.multi();
          if (forceExpire) {
            if (secDuration > 0) {
              multi.set(rlKey, points, "EX", secDuration);
            } else {
              multi.set(rlKey, points);
            }
            multi.pttl(rlKey).exec((err2, res) => {
              if (err2) {
                return reject(err2);
              }
              return resolve7(res);
            });
          } else {
            if (secDuration > 0) {
              const incrCallback = function(err2, result) {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(result);
              };
              if (typeof this.client.rlflxIncr === "function") {
                this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
              } else {
                this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
              }
            } else {
              multi.incrby(rlKey, points).pttl(rlKey).exec((err2, res) => {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(res);
              });
            }
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          this.client.multi().get(rlKey).pttl(rlKey).exec((err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              const [points] = res;
              if (points === null) {
                return resolve7(null);
              }
              resolve7(res);
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              resolve7(res > 0);
            }
          });
        });
      }
    };
    module2.exports = RateLimiterRedis;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js
var require_RateLimiterMongo = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    function getDriverVersion(client) {
      try {
        const _client = client.client ? client.client : client;
        const { version: version4 } = _client.topology.s.options.metadata.driver;
        const _v = version4.split(".").map((v) => parseInt(v));
        return {
          major: _v[0],
          feature: _v[1],
          patch: _v[2]
        };
      } catch (err2) {
        return { major: 0, feature: 0, patch: 0 };
      }
    }
    var RateLimiterMongo = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.indexKeyPrefix = opts.indexKeyPrefix;
        if (opts.mongo) {
          this.client = opts.mongo;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.then === "function") {
          this.client.then((conn) => {
            this.client = conn;
            this._initCollection();
            this._driverVersion = getDriverVersion(this.client);
          });
        } else {
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        }
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value2) {
        this._dbName = typeof value2 === "undefined" ? RateLimiterMongo.getDbName() : value2;
      }
      static getDbName() {
        return "node-rate-limiter-flexible";
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get client() {
        return this._client;
      }
      set client(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("mongo is not set");
        }
        this._client = value2;
      }
      get indexKeyPrefix() {
        return this._indexKeyPrefix;
      }
      set indexKeyPrefix(obj) {
        this._indexKeyPrefix = obj || {};
      }
      _initCollection() {
        const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
        const collection = db.collection(this.tableName);
        collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
        collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
        this._collection = collection;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        let doc;
        if (typeof result.value === "undefined") {
          doc = result;
        } else {
          doc = result.value;
        }
        res.isFirstInDuration = doc.points === changedPoints;
        res.consumedPoints = doc.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
        return res;
      }
      _upsert(key, points, msDuration, forceExpire = false, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        let where;
        let upsertData;
        if (forceExpire) {
          where = { key };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $set: {
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }
          };
          upsertData.$set = Object.assign(upsertData.$set, docAttrs);
        } else {
          where = {
            $or: [
              { expire: { $gt: new Date() } },
              { expire: { $eq: null } }
            ],
            key
          };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $setOnInsert: {
              key,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            },
            $inc: { points }
          };
          upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
        }
        const upsertOptions = {
          upsert: true
        };
        if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
          upsertOptions.returnDocument = "after";
        } else {
          upsertOptions.returnOriginal = false;
        }
        return new Promise((resolve7, reject) => {
          this._collection.findOneAndUpdate(
            where,
            upsertData,
            upsertOptions
          ).then((res) => {
            resolve7(res);
          }).catch((errUpsert) => {
            if (errUpsert && errUpsert.code === 11e3) {
              const replaceWhere = Object.assign({
                $or: [
                  { expire: { $lte: new Date() } },
                  { expire: { $eq: null } }
                ],
                key
              }, docAttrs);
              const replaceTo = {
                $set: Object.assign({
                  key,
                  points,
                  expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
                }, docAttrs)
              };
              this._collection.findOneAndUpdate(
                replaceWhere,
                replaceTo,
                upsertOptions
              ).then((res) => {
                resolve7(res);
              }).catch((errReplace) => {
                if (errReplace && errReplace.code === 11e3) {
                  this._upsert(key, points, msDuration, forceExpire).then((res) => resolve7(res)).catch((err2) => reject(err2));
                } else {
                  reject(errReplace);
                }
              });
            } else {
              reject(errUpsert);
            }
          });
        });
      }
      _get(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({
          key: rlKey,
          $or: [
            { expire: { $gt: new Date() } },
            { expire: { $eq: null } }
          ]
        }, docAttrs);
        return this._collection.findOne(where);
      }
      _delete(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({ key: rlKey }, docAttrs);
        return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
      }
    };
    module2.exports = RateLimiterMongo;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js
var require_RateLimiterMySQL = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMySQL = class extends RateLimiterStoreAbstract {
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createDbAndTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          this._getConnection().then((conn) => {
            conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
              this._releaseConnection(conn);
              resolve7();
            });
          }).catch(() => {
            resolve7();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return new Promise((resolve7, reject) => {
              this.client.getConnection((errConn, conn) => {
                if (errConn) {
                  return reject(errConn);
                }
                resolve7(conn);
              });
            });
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return conn.release();
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          default:
            return true;
        }
      }
      _createDbAndTable() {
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
              if (errDb) {
                this._releaseConnection(conn);
                return reject(errDb);
              }
              conn.query(this._getCreateTableStmt(), (err2) => {
                if (err2) {
                  this._releaseConnection(conn);
                  return reject(err2);
                }
                this._releaseConnection(conn);
                resolve7();
              });
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value2) {
        if (typeof value2 === "undefined") {
          if (this.client.constructor.name === "Connection") {
            value2 = "connection";
          } else if (this.client.constructor.name === "Pool") {
            value2 = "pool";
          } else if (this.client.constructor.name === "Sequelize") {
            value2 = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value2.toLowerCase();
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value2) {
        this._dbName = typeof value2 === "undefined" ? "rtlmtrflx" : value2;
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value2) {
        this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value2) {
        this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const [row] = result;
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _upsertTransaction(conn, key, points, msDuration, forceExpire) {
        return new Promise((resolve7, reject) => {
          conn.query("BEGIN", (errBegin) => {
            if (errBegin) {
              conn.rollback();
              return reject(errBegin);
            }
            const dateNow = Date.now();
            const newExpire = msDuration > 0 ? dateNow + msDuration : null;
            let q;
            let values;
            if (forceExpire) {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                points,
                newExpire
              ];
            } else {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                dateNow,
                points,
                points,
                dateNow,
                newExpire
              ];
            }
            conn.query(q, values, (errUpsert) => {
              if (errUpsert) {
                conn.rollback();
                return reject(errUpsert);
              }
              conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
                if (errSelect) {
                  conn.rollback();
                  return reject(errSelect);
                }
                conn.query("COMMIT", (err2) => {
                  if (err2) {
                    conn.rollback();
                    return reject(err2);
                  }
                  resolve7(res);
                });
              });
            });
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
              [this.dbName, this.tableName, rlKey, Date.now()],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else if (res.length === 0) {
                  resolve7(null);
                } else {
                  resolve7(res);
                }
                this._releaseConnection(conn);
              }
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "DELETE FROM ??.?? WHERE `key` = ?",
              [this.dbName, this.tableName, rlKey],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve7(res.affectedRows > 0);
                }
                this._releaseConnection(conn);
              }
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
    };
    module2.exports = RateLimiterMySQL;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js
var require_RateLimiterPostgres = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterPostgres = class extends RateLimiterStoreAbstract {
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          const q = {
            name: "rlflx-clear-expired",
            text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
            values: [expire]
          };
          this._query(q).then(() => {
            resolve7();
          }).catch(() => {
            resolve7();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return Promise.resolve(this.client);
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          case "typeorm":
            return Promise.resolve(this.client.driver.master);
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return true;
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          case "typeorm":
            return true;
          default:
            return true;
        }
      }
      _createTable() {
        return new Promise((resolve7, reject) => {
          this._query({
            text: this._getCreateTableStmt()
          }).then(() => {
            resolve7();
          }).catch((err2) => {
            if (err2.code === "23505") {
              resolve7();
            } else {
              reject(err2);
            }
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value2) {
        const constructorName = this.client.constructor.name;
        if (typeof value2 === "undefined") {
          if (constructorName === "Client") {
            value2 = "client";
          } else if (constructorName === "Pool" || constructorName === "BoundPool") {
            value2 = "pool";
          } else if (constructorName === "Sequelize") {
            value2 = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value2.toLowerCase();
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value2) {
        this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value2) {
        this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const row = result.rows[0];
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _query(q) {
        const prefix = this.tableName.toLowerCase();
        const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(queryObj).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
        const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
        return this._query({
          name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
          text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
          values: [key, points, newExpire, Date.now()]
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._query({
            name: "rlflx-get",
            text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
            values: [rlKey, Date.now()]
          }).then((res) => {
            if (res.rowCount === 0) {
              res = null;
            }
            resolve7(res);
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return this._query({
          name: "rlflx-delete",
          text: `DELETE FROM ${this.tableName} WHERE key = $1`,
          values: [rlKey]
        }).then((res) => res.rowCount > 0);
      }
    };
    module2.exports = RateLimiterPostgres;
  }
});

// browser-external:cluster
var require_cluster = __commonJS({
  "browser-external:cluster"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "cluster" has been externalized for browser compatibility. Cannot access "cluster.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js
var require_Record = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js"(exports2, module2) {
    module2.exports = class Record {
      constructor(value2, expiresAt, timeoutId = null) {
        this.value = value2;
        this.expiresAt = expiresAt;
        this.timeoutId = timeoutId;
      }
      get value() {
        return this._value;
      }
      set value(value2) {
        this._value = parseInt(value2);
      }
      get expiresAt() {
        return this._expiresAt;
      }
      set expiresAt(value2) {
        if (!(value2 instanceof Date) && Number.isInteger(value2)) {
          value2 = new Date(value2);
        }
        this._expiresAt = value2;
      }
      get timeoutId() {
        return this._timeoutId;
      }
      set timeoutId(value2) {
        this._timeoutId = value2;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js
var require_MemoryStorage = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js"(exports2, module2) {
    var Record3 = require_Record();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class MemoryStorage {
      constructor() {
        this._storage = {};
      }
      incrby(key, value2, durationSec) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          if (msBeforeExpires !== 0) {
            this._storage[key].value = this._storage[key].value + value2;
            return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
          }
          return this.set(key, value2, durationSec);
        }
        return this.set(key, value2, durationSec);
      }
      set(key, value2, durationSec) {
        const durationMs = durationSec * 1e3;
        if (this._storage[key] && this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        this._storage[key] = new Record3(
          value2,
          durationMs > 0 ? new Date(Date.now() + durationMs) : null
        );
        if (durationMs > 0) {
          this._storage[key].timeoutId = setTimeout(() => {
            delete this._storage[key];
          }, durationMs);
          if (this._storage[key].timeoutId.unref) {
            this._storage[key].timeoutId.unref();
          }
        }
        return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
      }
      get(key) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
        }
        return null;
      }
      delete(key) {
        if (this._storage[key]) {
          if (this._storage[key].timeoutId) {
            clearTimeout(this._storage[key].timeoutId);
          }
          delete this._storage[key];
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js
var require_RateLimiterMemory = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var MemoryStorage = require_MemoryStorage();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemory2 = class extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this._memoryStorage = new MemoryStorage();
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const secDuration = this._getKeySecDuration(options);
          let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          if (res.consumedPoints > this.points) {
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
              res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            }
            reject(res);
          } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            let delay3 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delay3 < this.execEvenlyMinDelayMs) {
              delay3 = res.consumedPoints * this.execEvenlyMinDelayMs;
            }
            setTimeout(resolve7, delay3, res);
          } else {
            resolve7(res);
          }
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      block(key, secDuration) {
        const msDuration = secDuration * 1e3;
        const initPoints = this.points + 1;
        this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)
        );
      }
      set(key, points, secDuration) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        this._memoryStorage.set(this.getKey(key), points, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)
        );
      }
      get(key) {
        const res = this._memoryStorage.get(this.getKey(key));
        if (res !== null) {
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        }
        return Promise.resolve(res);
      }
      delete(key) {
        return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
      }
    };
    module2.exports = RateLimiterMemory2;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js
var require_RateLimiterCluster = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"(exports2, module2) {
    var cluster = require_cluster();
    var crypto4 = require_crypto();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var RateLimiterMemory2 = require_RateLimiterMemory();
    var RateLimiterRes = require_RateLimiterRes();
    var channel = "rate_limiter_flexible";
    var masterInstance = null;
    var masterSendToWorker = function(worker, msg, type, res) {
      let data;
      if (res === null || res === true || res === false) {
        data = res;
      } else {
        data = {
          remainingPoints: res.remainingPoints,
          msBeforeNext: res.msBeforeNext,
          consumedPoints: res.consumedPoints,
          isFirstInDuration: res.isFirstInDuration
        };
      }
      worker.send({
        channel,
        keyPrefix: msg.keyPrefix,
        promiseId: msg.promiseId,
        type,
        data
      });
    };
    var workerWaitInit = function(payload) {
      setTimeout(() => {
        if (this._initiated) {
          process.send(payload);
        } else if (typeof this._promises[payload.promiseId] !== "undefined") {
          workerWaitInit.call(this, payload);
        }
      }, 30);
    };
    var workerSendToMaster = function(func, promiseId, key, arg, opts) {
      const payload = {
        channel,
        keyPrefix: this.keyPrefix,
        func,
        promiseId,
        data: {
          key,
          arg,
          opts
        }
      };
      if (!this._initiated) {
        workerWaitInit.call(this, payload);
      } else {
        process.send(payload);
      }
    };
    var masterProcessMsg = function(worker, msg) {
      if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
        return false;
      }
      let promise;
      switch (msg.func) {
        case "consume":
          promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "penalty":
          promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "reward":
          promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "block":
          promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "get":
          promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
          break;
        case "delete":
          promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
          break;
        default:
          return false;
      }
      if (promise) {
        promise.then((res) => {
          masterSendToWorker(worker, msg, "resolve", res);
        }).catch((rejRes) => {
          masterSendToWorker(worker, msg, "reject", rejRes);
        });
      }
    };
    var workerProcessMsg = function(msg) {
      if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
        return false;
      }
      if (this._promises[msg.promiseId]) {
        clearTimeout(this._promises[msg.promiseId].timeoutId);
        let res;
        if (msg.data === null || msg.data === true || msg.data === false) {
          res = msg.data;
        } else {
          res = new RateLimiterRes(
            msg.data.remainingPoints,
            msg.data.msBeforeNext,
            msg.data.consumedPoints,
            msg.data.isFirstInDuration
          );
        }
        switch (msg.type) {
          case "resolve":
            this._promises[msg.promiseId].resolve(res);
            break;
          case "reject":
            this._promises[msg.promiseId].reject(res);
            break;
          default:
            throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
        }
        delete this._promises[msg.promiseId];
      }
    };
    var getOpts = function() {
      return {
        points: this.points,
        duration: this.duration,
        blockDuration: this.blockDuration,
        execEvenly: this.execEvenly,
        execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
        keyPrefix: this.keyPrefix
      };
    };
    var savePromise = function(resolve7, reject) {
      const hrtime = process.hrtime();
      let promiseId = hrtime[0].toString() + hrtime[1].toString();
      if (typeof this._promises[promiseId] !== "undefined") {
        promiseId += crypto4.randomBytes(12).toString("base64");
      }
      this._promises[promiseId] = {
        resolve: resolve7,
        reject,
        timeoutId: setTimeout(() => {
          delete this._promises[promiseId];
          reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
        }, this.timeoutMs)
      };
      return promiseId;
    };
    var RateLimiterClusterMaster = class {
      constructor() {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        cluster.setMaxListeners(0);
        cluster.on("message", (worker, msg) => {
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory2(msg.opts);
            }
            worker.send({
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            });
          } else {
            masterProcessMsg.call(this, worker, msg);
          }
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterMasterPM2 = class {
      constructor(pm2) {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        pm2.launchBus((err2, pm2Bus) => {
          pm2Bus.on("process:msg", (packet) => {
            const msg = packet.raw;
            if (msg && msg.channel === channel && msg.type === "init") {
              if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
                this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory2(msg.opts);
              }
              pm2.sendDataToProcessId(packet.process.pm_id, {
                data: {},
                topic: channel,
                channel,
                type: "init",
                keyPrefix: msg.opts.keyPrefix
              }, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            } else {
              const worker = {
                send: (msgData) => {
                  const pm2Message = msgData;
                  pm2Message.topic = channel;
                  if (typeof pm2Message.data === "undefined") {
                    pm2Message.data = {};
                  }
                  pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                    if (sendErr) {
                      console.log(sendErr, res);
                    }
                  });
                }
              };
              masterProcessMsg.call(this, worker, msg);
            }
          });
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterWorker = class extends RateLimiterAbstract {
      get timeoutMs() {
        return this._timeoutMs;
      }
      set timeoutMs(value2) {
        this._timeoutMs = typeof value2 === "undefined" ? 5e3 : Math.abs(parseInt(value2));
      }
      constructor(opts = {}) {
        super(opts);
        process.setMaxListeners(0);
        this.timeoutMs = opts.timeoutMs;
        this._initiated = false;
        process.on("message", (msg) => {
          if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
            this._initiated = true;
          } else {
            workerProcessMsg.call(this, msg);
          }
        });
        process.send({
          channel,
          type: "init",
          opts: getOpts.call(this)
        });
        this._promises = {};
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
        });
      }
      penalty(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
        });
      }
      reward(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "reward", promiseId, key, points, options);
        });
      }
      block(key, secDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
        });
      }
      get(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "get", promiseId, key, options);
        });
      }
      delete(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "delete", promiseId, key, options);
        });
      }
    };
    module2.exports = {
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster: RateLimiterClusterWorker
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js
var require_RateLimiterMemcache = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemcache = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(result.consumedPoints);
        res.isFirstInDuration = result.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = result.msBeforeNext;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          const secDuration = Math.floor(msDuration / 1e3);
          if (forceExpire) {
            this.client.set(rlKey, points, secDuration, (err2) => {
              if (!err2) {
                this.client.set(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve7(res);
                  }
                );
              } else {
                reject(err2);
              }
            });
          } else {
            this.client.incr(rlKey, points, (err2, consumedPoints) => {
              if (err2 || consumedPoints === false) {
                this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                  if (errAddKey || !createdNew) {
                    if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                      const nextOptions = Object.assign({}, options);
                      nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                      this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve7(resUpsert)).catch((errUpsert) => reject(errUpsert));
                    } else {
                      reject(new Error("Can not add key"));
                    }
                  } else {
                    this.client.add(
                      `${rlKey}_expire`,
                      secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                      secDuration,
                      () => {
                        const res = {
                          consumedPoints: points,
                          msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                        };
                        resolve7(res);
                      }
                    );
                  }
                });
              } else {
                this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                  if (errGetExpire) {
                    reject(errGetExpire);
                  } else {
                    const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                    const res = {
                      consumedPoints,
                      msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                    };
                    resolve7(res);
                  }
                });
              }
            });
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          this.client.get(rlKey, (err2, consumedPoints) => {
            if (!consumedPoints) {
              resolve7(null);
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve7(res);
                }
              });
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else if (res === false) {
              resolve7(res);
            } else {
              this.client.del(`${rlKey}_expire`, (errDelExpire) => {
                if (errDelExpire) {
                  reject(errDelExpire);
                } else {
                  resolve7(res);
                }
              });
            }
          });
        });
      }
    };
    module2.exports = RateLimiterMemcache;
  }
});

// node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js
var require_RLWrapperBlackAndWhite = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RLWrapperBlackAndWhite {
      constructor(opts = {}) {
        this.limiter = opts.limiter;
        this.blackList = opts.blackList;
        this.whiteList = opts.whiteList;
        this.isBlackListed = opts.isBlackListed;
        this.isWhiteListed = opts.isWhiteListed;
        this.runActionAnyway = opts.runActionAnyway;
      }
      get limiter() {
        return this._limiter;
      }
      set limiter(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("limiter is not set");
        }
        this._limiter = value2;
      }
      get runActionAnyway() {
        return this._runActionAnyway;
      }
      set runActionAnyway(value2) {
        this._runActionAnyway = typeof value2 === "undefined" ? false : value2;
      }
      get blackList() {
        return this._blackList;
      }
      set blackList(value2) {
        this._blackList = Array.isArray(value2) ? value2 : [];
      }
      get isBlackListed() {
        return this._isBlackListed;
      }
      set isBlackListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isBlackListed must be function");
        }
        this._isBlackListed = func;
      }
      get whiteList() {
        return this._whiteList;
      }
      set whiteList(value2) {
        this._whiteList = Array.isArray(value2) ? value2 : [];
      }
      get isWhiteListed() {
        return this._isWhiteListed;
      }
      set isWhiteListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isWhiteListed must be function");
        }
        this._isWhiteListed = func;
      }
      isBlackListedSomewhere(key) {
        return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
      }
      isWhiteListedSomewhere(key) {
        return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
      }
      getBlackRes() {
        return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);
      }
      getWhiteRes() {
        return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);
      }
      rejectBlack() {
        return Promise.reject(this.getBlackRes());
      }
      resolveBlack() {
        return Promise.resolve(this.getBlackRes());
      }
      resolveWhite() {
        return Promise.resolve(this.getWhiteRes());
      }
      consume(key, pointsToConsume = 1) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.rejectBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.consume(key, pointsToConsume);
        }
        if (this.runActionAnyway) {
          this.limiter.consume(key, pointsToConsume).catch(() => {
          });
        }
        return res;
      }
      block(key, secDuration) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.block(key, secDuration);
        }
        if (this.runActionAnyway) {
          this.limiter.block(key, secDuration).catch(() => {
          });
        }
        return res;
      }
      penalty(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.penalty(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.penalty(key, points).catch(() => {
          });
        }
        return res;
      }
      reward(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.reward(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.reward(key, points).catch(() => {
          });
        }
        return res;
      }
      get(key) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined" || this.runActionAnyway) {
          return this.limiter.get(key);
        }
        return res;
      }
      delete(key) {
        return this.limiter.delete(key);
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js
var require_RateLimiterUnion = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    module2.exports = class RateLimiterUnion {
      constructor(...limiters) {
        if (limiters.length < 1) {
          throw new Error("RateLimiterUnion: at least one limiter have to be passed");
        }
        limiters.forEach((limiter) => {
          if (!(limiter instanceof RateLimiterAbstract)) {
            throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
          }
        });
        this._limiters = limiters;
      }
      consume(key, points = 1) {
        return new Promise((resolve7, reject) => {
          const promises = [];
          this._limiters.forEach((limiter) => {
            promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
          });
          Promise.all(promises).then((res) => {
            const resObj = {};
            let rejected = false;
            res.forEach((item) => {
              if (item.rejected === true) {
                rejected = true;
              }
            });
            for (let i2 = 0; i2 < res.length; i2++) {
              if (rejected && res[i2].rejected === true) {
                resObj[this._limiters[i2].keyPrefix] = res[i2].rej;
              } else if (!rejected) {
                resObj[this._limiters[i2].keyPrefix] = res[i2];
              }
            }
            if (rejected) {
              reject(resObj);
            } else {
              resolve7(resObj);
            }
          });
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js
var require_RateLimiterQueueError = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js"(exports2, module2) {
    module2.exports = class RateLimiterQueueError extends Error {
      constructor(message6, extra) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "CustomError";
        this.message = message6;
        if (extra) {
          this.extra = extra;
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js
var require_RateLimiterQueue = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js"(exports2, module2) {
    var RateLimiterQueueError = require_RateLimiterQueueError();
    var MAX_QUEUE_SIZE = 4294967295;
    var KEY_DEFAULT = "limiter";
    module2.exports = class RateLimiterQueue {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE
      }) {
        this._queueLimiters = {
          KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
        };
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining(key = KEY_DEFAULT) {
        if (this._queueLimiters[key]) {
          return this._queueLimiters[key].getTokensRemaining();
        } else {
          return Promise.resolve(this._limiterFlexible.points);
        }
      }
      removeTokens(tokens, key = KEY_DEFAULT) {
        if (!this._queueLimiters[key]) {
          this._queueLimiters[key] = new RateLimiterQueueInternal(
            this._limiterFlexible,
            {
              key,
              maxQueueSize: this._maxQueueSize
            }
          );
        }
        return this._queueLimiters[key].removeTokens(tokens);
      }
    };
    var RateLimiterQueueInternal = class {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE,
        key: KEY_DEFAULT
      }) {
        this._key = opts.key;
        this._waitTimeout = null;
        this._queue = [];
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining() {
        return this._limiterFlexible.get(this._key).then((rlRes) => {
          return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
        });
      }
      removeTokens(tokens) {
        const _this = this;
        return new Promise((resolve7, reject) => {
          if (tokens > _this._limiterFlexible.points) {
            reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
            return;
          }
          if (_this._queue.length > 0) {
            _this._queueRequest.call(_this, resolve7, reject, tokens);
          } else {
            _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
              resolve7(res.remainingPoints);
            }).catch((rej) => {
              if (rej instanceof Error) {
                reject(rej);
              } else {
                _this._queueRequest.call(_this, resolve7, reject, tokens);
                if (_this._waitTimeout === null) {
                  _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
                }
              }
            });
          }
        });
      }
      _queueRequest(resolve7, reject, tokens) {
        const _this = this;
        if (_this._queue.length < _this._maxQueueSize) {
          _this._queue.push({ resolve: resolve7, reject, tokens });
        } else {
          reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
        }
      }
      _processFIFO() {
        const _this = this;
        if (_this._waitTimeout !== null) {
          clearTimeout(_this._waitTimeout);
          _this._waitTimeout = null;
        }
        if (_this._queue.length === 0) {
          return;
        }
        const item = _this._queue.shift();
        _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
          item.resolve(res.remainingPoints);
          _this._processFIFO.call(_this);
        }).catch((rej) => {
          if (rej instanceof Error) {
            item.reject(rej);
            _this._processFIFO.call(_this);
          } else {
            _this._queue.unshift(item);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js
var require_BurstyRateLimiter = __commonJS({
  "node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class BurstyRateLimiter {
      constructor(rateLimiter, burstLimiter) {
        this._rateLimiter = rateLimiter;
        this._burstLimiter = burstLimiter;
      }
      _combineRes(rlRes, blRes) {
        return new RateLimiterRes(
          rlRes.remainingPoints,
          Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),
          rlRes.consumedPoints,
          rlRes.isFirstInDuration
        );
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
          if (rlRej instanceof RateLimiterRes) {
            return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
              return Promise.resolve(this._combineRes(rlRej, blRes));
            }).catch(
              (blRej) => {
                if (blRej instanceof RateLimiterRes) {
                  return Promise.reject(this._combineRes(rlRej, blRej));
                } else {
                  return Promise.reject(blRej);
                }
              }
            );
          } else {
            return Promise.reject(rlRej);
          }
        });
      }
      get(key) {
        return Promise.all([
          this._rateLimiter.get(key),
          this._burstLimiter.get(key)
        ]).then(([rlRes, blRes]) => {
          return this._combineRes(rlRes, blRes);
        });
      }
      get points() {
        return this._rateLimiter.points;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/index.js
var require_rate_limiter_flexible = __commonJS({
  "node_modules/rate-limiter-flexible/index.js"(exports2, module2) {
    var RateLimiterRedis = require_RateLimiterRedis();
    var RateLimiterMongo = require_RateLimiterMongo();
    var RateLimiterMySQL = require_RateLimiterMySQL();
    var RateLimiterPostgres = require_RateLimiterPostgres();
    var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = require_RateLimiterCluster();
    var RateLimiterMemory2 = require_RateLimiterMemory();
    var RateLimiterMemcache = require_RateLimiterMemcache();
    var RLWrapperBlackAndWhite = require_RLWrapperBlackAndWhite();
    var RateLimiterUnion = require_RateLimiterUnion();
    var RateLimiterQueue = require_RateLimiterQueue();
    var BurstyRateLimiter = require_BurstyRateLimiter();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = {
      RateLimiterRedis,
      RateLimiterMongo,
      RateLimiterMySQL,
      RateLimiterPostgres,
      RateLimiterMemory: RateLimiterMemory2,
      RateLimiterMemcache,
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster,
      RLWrapperBlackAndWhite,
      RateLimiterUnion,
      RateLimiterQueue,
      BurstyRateLimiter,
      RateLimiterRes
    };
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isSerializableHash(h) {
      return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
    }
    exports2.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function select2(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports2.select = select2;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    exports2.lessOrEqual = lessOrEqual;
    function compare4(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i2 = 0; i2 < a.length; i2++) {
        result |= a[i2] ^ b[i2];
      }
      return 1 & result - 1 >>> 8;
    }
    exports2.compare = compare4;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare4(a, b) !== 0;
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports2.wipe = wipe;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = function() {
      function HMAC2(hash3, key) {
        this._finished = false;
        this._inner = new hash3();
        this._outer = new hash3();
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          this._inner.update(key).finish(pad).clean();
        } else {
          pad.set(key);
        }
        for (var i2 = 0; i2 < pad.length; i2++) {
          pad[i2] ^= 54;
        }
        this._inner.update(pad);
        for (var i2 = 0; i2 < pad.length; i2++) {
          pad[i2] ^= 54 ^ 92;
        }
        this._outer.update(pad);
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
          this._innerKeyedState = this._inner.saveState();
          this._outerKeyedState = this._outer.saveState();
        }
        wipe_1.wipe(pad);
      }
      HMAC2.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
          this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
          this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this._inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this._finished) {
          this._outer.finish(out);
          return this;
        }
        this._inner.finish(out);
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      HMAC2.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
      };
      HMAC2.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
      };
      return HMAC2;
    }();
    exports2.HMAC = HMAC;
    function hmac(hash3, key, data) {
      var h = new HMAC(hash3, key);
      h.update(data);
      var digest15 = h.digest();
      h.clean();
      return digest15;
    }
    exports2.hmac = hmac;
    exports2.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hmac_1 = require_hmac2();
    var wipe_1 = require_wipe();
    var HKDF2 = function() {
      function HKDF3(hash3, key, salt, info) {
        if (salt === void 0) {
          salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1);
        this._hash = hash3;
        this._info = info;
        var okm = hmac_1.hmac(this._hash, salt, key);
        this._hmac = new hmac_1.HMAC(hash3, okm);
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
      }
      HKDF3.prototype._fillBuffer = function() {
        this._counter[0]++;
        var ctr = this._counter[0];
        if (ctr === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        this._hmac.reset();
        if (ctr > 1) {
          this._hmac.update(this._buffer);
        }
        if (this._info) {
          this._hmac.update(this._info);
        }
        this._hmac.update(this._counter);
        this._hmac.finish(this._buffer);
        this._bufpos = 0;
      };
      HKDF3.prototype.expand = function(length23) {
        var out = new Uint8Array(length23);
        for (var i2 = 0; i2 < out.length; i2++) {
          if (this._bufpos === this._buffer.length) {
            this._fillBuffer();
          }
          out[i2] = this._buffer[this._bufpos++];
        }
        return out;
      };
      HKDF3.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
      };
      return HKDF3;
    }();
    exports2.HKDF = HKDF2;
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser7 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length23) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length23);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto3 = require_crypto();
          if (nodeCrypto3 && nodeCrypto3.randomBytes) {
            this._crypto = nodeCrypto3;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length23) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length23);
        if (buffer2.length !== length23) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length23);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer2[i2];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    };
    exports2.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemRandomSource = void 0;
    var browser_1 = require_browser7();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length23) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length23);
      }
    };
    exports2.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports2.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports2.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports2.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports2.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n) {
      return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 8;
      out[offset + 1] = value2 >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 0;
      out[offset + 1] = value2 >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 24;
      out[offset + 1] = value2 >>> 16;
      out[offset + 2] = value2 >>> 8;
      out[offset + 3] = value2 >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE;
    exports2.writeInt32BE = writeUint32BE;
    function writeUint32LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 0;
      out[offset + 1] = value2 >>> 8;
      out[offset + 2] = value2 >>> 16;
      out[offset + 3] = value2 >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value2 / 4294967296 >>> 0, out, offset);
      writeUint32BE(value2 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value2 >>> 0, out, offset);
      writeUint32LE(value2 / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value2)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value2 / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value2)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value2 / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value2);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value2, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value2);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value2, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes3(length23, prng = exports2.defaultRandomSource) {
      return prng.randomBytes(length23);
    }
    exports2.randomBytes = randomBytes3;
    function randomUint32(prng = exports2.defaultRandomSource) {
      const buf2 = randomBytes3(4, prng);
      const result = (0, binary_1.readUint32LE)(buf2);
      (0, wipe_1.wipe)(buf2);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length23, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length23 > 0) {
        const buf2 = randomBytes3(Math.ceil(length23 * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf2.length && length23 > 0; i2++) {
          const randomByte = buf2[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length23--;
          }
        }
        (0, wipe_1.wipe)(buf2);
      }
      return out;
    }
    exports2.randomString = randomString;
    function randomStringForEntropy(bits2, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      const length23 = Math.ceil(bits2 / (Math.log(charset.length) / Math.LN2));
      return randomString(length23, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sharedKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.scalarMultBase = exports2.scalarMult = exports2.SHARED_KEY_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random2();
    var wipe_1 = require_wipe();
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 32;
    exports2.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      let c = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v = o[i2] + c + 65535;
        c = Math.floor(v / 65536);
        o[i2] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c & (p[i2] ^ q[i2]);
        p[i2] ^= t;
        q[i2] ^= t;
      }
    }
    function pack25519(o, n) {
      const m = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
          m[i2 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        const b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpack25519(o, n) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a[i2] + b[i2];
      }
    }
    function sub(o, a, b) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a[i2] - b[i2];
      }
    }
    function mul(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, inp) {
      const c = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        c[i2] = inp[i2];
      }
      for (let i2 = 253; i2 >= 0; i2--) {
        square(c, c);
        if (i2 !== 2 && i2 !== 4) {
          mul(c, c, inp);
        }
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = c[i2];
      }
    }
    function scalarMult(n, p) {
      const z = new Uint8Array(32);
      const x = new Float64Array(80);
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (let i2 = 0; i2 < 31; i2++) {
        z[i2] = n[i2];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (let i2 = 0; i2 < 16; i2++) {
        b[i2] = x[i2];
      }
      a[0] = d[0] = 1;
      for (let i2 = 254; i2 >= 0; --i2) {
        const r = z[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        x[i2 + 16] = a[i2];
        x[i2 + 32] = c[i2];
        x[i2 + 48] = b[i2];
        x[i2 + 64] = d[i2];
      }
      const x32 = x.subarray(32);
      const x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports2.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    exports2.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed4(seed2) {
      if (seed2.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports2.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed2);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed4;
    function generateKeyPair6(prng) {
      const seed2 = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed4(seed2);
      (0, wipe_1.wipe)(seed2);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair6;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i2 = 0; i2 < result.length; i2++) {
          zeros |= result[i2];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports2.sharedKey = sharedKey2;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 32;
    exports2.BLOCK_SIZE = 64;
    var SHA2562 = function() {
      function SHA2563() {
        this.digestLength = exports2.DIGEST_LENGTH;
        this.blockSize = exports2.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2563.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2563.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2563.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2563.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i2 = left + 1; i2 < padLength - 8; i2++) {
            this._buffer[i2] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
          binary_1.writeUint32BE(this._state[i2], out, i2 * 4);
        }
        return this;
      };
      SHA2563.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2563.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2563.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2563;
    }();
    exports2.SHA256 = SHA2562;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i2 = 0; i2 < 16; i2++) {
          var j = pos + i2 * 4;
          w[i2] = binary_1.readUint32BE(p, j);
        }
        for (var i2 = 16; i2 < 64; i2++) {
          var u = w[i2 - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i2 - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0);
        }
        for (var i2 = 0; i2 < 64; i2++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K2[i2] + w[i2] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash3(data) {
      var h = new SHA2562();
      h.update(data);
      var digest15 = h.digest();
      h.clean();
      return digest15;
    }
    exports2.hash = hash3;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src18, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src18.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i2 = 0; i2 < src18.length; i2 += 64) {
        core(block, nc, key);
        for (var j = i2; j < i2 + 64 && j < src18.length; j++) {
          dst[j] = src18[j] ^ block[j - i2];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports2.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports2.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key) {
        this.digestLength = exports2.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i2;
        if (this._leftover) {
          i2 = this._leftover;
          this._buffer[i2++] = 1;
          for (; i2 < 16; i2++) {
            this._buffer[i2] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this._h[i2] += c;
          c = this._h[i2] >>> 13;
          this._h[i2] &= 8191;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g[i2] = this._h[i2] + c;
          c = g[i2] >>> 13;
          g[i2] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) {
          g[i2] &= mask;
        }
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) {
          this._h[i2] = this._h[i2] & mask | g[i2];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this._h[i2] + this._pad[i2] | 0) + (f >>> 16) | 0;
          this._h[i2] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m) {
        var mpos = 0;
        var bytes2 = m.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i2 = 0; i2 < want; i2++) {
            this._buffer[this._leftover + i2] = m[mpos + i2];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i2 = 0; i2 < bytes2; i2++) {
            this._buffer[this._leftover + i2] = m[mpos + i2];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports2.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest15 = h.digest();
      h.clean();
      return digest15;
    }
    exports2.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports2.KEY_LENGTH = 32;
    exports2.NONCE_LENGTH = 12;
    exports2.TAG_LENGTH = 16;
    var ZEROS2 = new Uint8Array(16);
    var ChaCha20Poly13052 = function() {
      function ChaCha20Poly13053(key) {
        this.nonceLength = exports2.NONCE_LENGTH;
        this.tagLength = exports2.TAG_LENGTH;
        if (key.length !== exports2.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13053.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13053.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13053.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13053.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h.update(ZEROS2.subarray(associatedData.length % 16));
          }
        }
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS2.subarray(ciphertext.length % 16));
        }
        var length23 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length23);
        }
        h.update(length23);
        binary_1.writeUint64LE(ciphertext.length, length23);
        h.update(length23);
        var tag = h.digest();
        for (var i2 = 0; i2 < tag.length; i2++) {
          tagOut[i2] = tag[i2];
        }
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length23);
      };
      return ChaCha20Poly13053;
    }();
    exports2.ChaCha20Poly1305 = ChaCha20Poly13052;
  }
});

// node_modules/varint-decoder/node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode81;
    var MSB19 = 128;
    var REST19 = 127;
    var MSBALL18 = ~REST19;
    var INT18 = Math.pow(2, 31);
    function encode81(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT18) {
        out[offset++] = num & 255 | MSB19;
        num /= 128;
      }
      while (num & MSBALL18) {
        out[offset++] = num & 255 | MSB19;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode81.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read19;
    var MSB19 = 128;
    var REST19 = 127;
    function read19(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read19.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST19) << shift : (b & REST19) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB19);
      read19.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/length.js"(exports2, module2) {
    var N119 = Math.pow(2, 7);
    var N219 = Math.pow(2, 14);
    var N319 = Math.pow(2, 21);
    var N419 = Math.pow(2, 28);
    var N519 = Math.pow(2, 35);
    var N619 = Math.pow(2, 42);
    var N719 = Math.pow(2, 49);
    var N819 = Math.pow(2, 56);
    var N919 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N119 ? 1 : value2 < N219 ? 2 : value2 < N319 ? 3 : value2 < N419 ? 4 : value2 < N519 ? 5 : value2 < N619 ? 6 : value2 < N719 ? 7 : value2 < N819 ? 8 : value2 < N919 ? 9 : 10;
    };
  }
});

// node_modules/varint-decoder/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/varint-decoder/src/index.js
var require_src5 = __commonJS({
  "node_modules/varint-decoder/src/index.js"(exports2, module2) {
    "use strict";
    var varint27 = require_varint2();
    module2.exports = (buf2) => {
      if (!(buf2 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf2.length > 0) {
        const num = varint27.decode(buf2);
        result.push(num);
        buf2 = buf2.slice(varint27.decode.bytes);
      }
      return result;
    };
  }
});

// node_modules/@vascosantos/moving-average/index.js
var require_moving_average = __commonJS({
  "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
    "use strict";
    var exp = Math.exp;
    exports2 = module2.exports = function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      ret.push = function push(time, value2) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value2 - ma;
          const incr = a * diff;
          ma = a * value2 + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value2;
        }
        previousTime = time;
      };
      ret.movingAverage = function movingAverage() {
        return ma;
      };
      ret.variance = function variance() {
        return v;
      };
      ret.deviation = function deviation() {
        return d;
      };
      ret.forecast = function forecast() {
        return f;
      };
      return ret;
    };
  }
});

// node_modules/merge-options/index.mjs
var import_index = __toESM(require_merge_options(), 1);
var merge_options_default = import_index.default;

// node_modules/ipfs-core/src/components/index.js
var import_env2 = __toESM(require_env(), 1);

// node_modules/@libp2p/logger/dist/src/index.js
var import_debug = __toESM(require_browser());

// node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js
var Encoder = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name22, prefix, baseEncode);
    this.decoder = new Decoder(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec(name22, prefix, encode81, decode97);
var baseX = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default(alphabet16, name22);
  return from({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce(decode97(text))
  });
};
var decode = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from({
    prefix,
    name: name22,
    encode(input) {
      return encode(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/logger/dist/src/index.js
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function logger(name22) {
  return Object.assign((0, import_debug.default)(name22), {
    error: (0, import_debug.default)(`${name22}:error`),
    trace: (0, import_debug.default)(`${name22}:trace`)
  });
}

// node_modules/ipfs-core/src/components/index.js
var import_err_code138 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs/src/index.js
var import_err_code = __toESM(require_err_code());

// node_modules/ipfs-unixfs/src/unixfs.js
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode81(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i2 = 0; i2 < m.blocksizes.length; ++i2)
        w.uint32(32).uint64(m.blocksizes[i2]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode97(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i2 = 0; i2 < d.blocksizes.length; ++i2) {
        if ($util.Long)
          (m.blocksizes[i2] = $util.Long.fromValue(d.blocksizes[i2])).unsigned = true;
        else if (typeof d.blocksizes[i2] === "string")
          m.blocksizes[i2] = parseInt(d.blocksizes[i2], 10);
        else if (typeof d.blocksizes[i2] === "number")
          m.blocksizes[i2] = d.blocksizes[i2];
        else if (typeof d.blocksizes[i2] === "object")
          m.blocksizes[i2] = new $util.LongBits(d.blocksizes[i2].low >>> 0, d.blocksizes[i2].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode81(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode97(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata4.prototype.MimeType = "";
  Metadata4.encode = function encode81(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata4.decode = function decode97(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// node_modules/ipfs-unixfs/src/index.js
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class {
  static unmarshal(marshaled) {
    const message6 = PBData.decode(marshaled);
    const decoded = PBData.toObject(message6, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = {
    type: "file"
  }) {
    const {
      type,
      data,
      blockSizes,
      hashType,
      fanout,
      mtime,
      mode
    } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode6,
  encode: () => encode4,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});

// node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode2;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode2.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value2) {
  return value2 < N1 ? 1 : value2 < N2 ? 2 : value2 < N3 ? 3 : value2 < N4 ? 4 : value2 < N5 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/multiformats/esm/src/varint.js
var decode3 = (data, offset = 0) => {
  const code22 = varint_default.decode(data, offset);
  return [
    code22,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce2,
  empty: () => empty2,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty2 = new Uint8Array(0);
var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes3 = hex.match(/../g);
  return hexes3 ? new Uint8Array(hexes3.map((b) => parseInt(b, 16))) : empty2;
};
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// node_modules/multiformats/esm/src/hashes/digest.js
var create = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength(code22);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo(code22, bytes2, 0);
  encodeTo(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest(code22, size, digest15, bytes2);
};
var decode4 = (multihash) => {
  const bytes2 = coerce2(multihash);
  const [code22, sizeOffset] = decode3(bytes2);
  const [size, digestOffset] = decode3(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code22, size, digest15, bytes2);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});

// node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/multiformats/esm/src/bases/base.js
var Encoder2 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec2 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name22, prefix, baseEncode);
    this.decoder = new Decoder2(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from2 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec2(name22, prefix, encode81, decode97);
var baseX2 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default2(alphabet16, name22);
  return from2({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce2(decode97(text))
  });
};
var decode5 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode3 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from2({
    prefix,
    name: name22,
    encode(input) {
      return encode3(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode5(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/multiformats/esm/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/esm/src/cid.js
var CID = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create(code22, digest15);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base30) {
    const { bytes: bytes2, version: version4, _baseCache } = this;
    switch (version4) {
      case 0:
        return toStringV0(bytes2, _baseCache, base30 || base58btc2.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base30 || base322.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value2) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value2 && (value2[cidSymbol] || value2.asCID === value2));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value2) {
    if (value2 instanceof CID) {
      return value2;
    } else if (value2 != null && value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID(version4, code22, multihash, bytes2 || encodeCID(version4, code22, multihash.bytes));
    } else if (value2 != null && value2[cidSymbol] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode4(multihash);
      return CID.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version4, code22, digest15.bytes);
        return new CID(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID.create(0, DAG_PB_CODE, digest15);
  }
  static createV1(code22, digest15) {
    return CID.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest15 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest15) : CID.createV1(specs.codec, digest15);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode3(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else if (version4 === 1) {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base30);
    const cid = CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base30 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base30 || base322;
      return [
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base30 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base30.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version4, code22, multihash) => {
  const codeOffset = encodingLength(version4);
  const hashOffset = codeOffset + encodingLength(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version4, bytes2, 0);
  encodeTo(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message6) => {
  if (range.test(version)) {
    console.warn(message6);
  } else {
    throw new Error(message6);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/@ipld/dag-pb/esm/src/pb-decode.js
var textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint(bytes2, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes(bytes2, index);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}

// node_modules/@ipld/dag-pb/esm/src/pb-encode.js
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i2 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes2, i2, link.Tsize) - 1;
    bytes2[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i2 -= nameBytes.length;
    bytes2.set(nameBytes, i2);
    i2 = encodeVarint(bytes2, i2, nameBytes.length) - 1;
    bytes2[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes2.set(link.Hash, i2);
    i2 = encodeVarint(bytes2, i2, link.Hash.length) - 1;
    bytes2[i2] = 10;
  }
  return bytes2.length - i2;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i2 = size;
  if (node.Data) {
    i2 -= node.Data.length;
    bytes2.set(node.Data, i2);
    i2 = encodeVarint(bytes2, i2, node.Data.length) - 1;
    bytes2[i2] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes2.subarray(0, i2));
      i2 -= size2;
      i2 = encodeVarint(bytes2, i2, size2) - 1;
      bytes2[i2] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base30 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base30;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// node_modules/@ipld/dag-pb/esm/src/util.js
var pbNodeProperties = [
  "Data",
  "Links"
];
var pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x = abuf[i2];
      y = bbuf[i2];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const link = node.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare({
    Data: data,
    Links: links3
  });
}
function createLink(name22, size, cid) {
  return asLink({
    Hash: cid,
    Name: name22,
    Tsize: size
  });
}

// node_modules/@ipld/dag-pb/esm/src/index.js
var name = "dag-pb";
var code = 112;
function encode4(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode6(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode8,
  encode: () => encode6,
  name: () => name2
});

// node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value2) {
  if (value2 === null) {
    return "null";
  }
  if (value2 === void 0) {
    return "undefined";
  }
  if (value2 === true || value2 === false) {
    return "boolean";
  }
  const typeOf2 = typeof value2;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value2)) {
    return "Array";
  }
  if (isBuffer(value2)) {
    return "Buffer";
  }
  const objectType = getObjectType(value2);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value2) {
  return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
}
function getObjectType(value2) {
  const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name22, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name22;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value2, encodedLength) {
    this.type = type;
    this.value = value2;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder3 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (bytes2, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
} : (bytes2, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
};
var fromString2 = useBuffer ? (string14) => {
  return string14.length > 64 ? globalThis.Buffer.from(string14) : utf8ToBytes(string14);
} : (string14) => {
  return string14.length > 64 ? textEncoder3.encode(string14) : utf8ToBytes(string14);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes2, start, end) => {
  if (isBuffer2(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end));
  }
  return bytes2.slice(start, end);
} : (bytes2, start, end) => {
  return bytes2.slice(start, end);
};
var concat = useBuffer ? (chunks, length23) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length23));
} : (chunks, length23) => {
  const out = new Uint8Array(length23);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string14, units = Infinity) {
  let codePoint;
  const length23 = string14.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i2 = 0; i2 < length23; ++i2) {
    codePoint = string14.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length23) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value2 = data[offset];
  if (options.strict === true && value2 < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value2 = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value2 < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value2 < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value2 < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value2 <= Number.MAX_SAFE_INTEGER) {
    return Number(value2);
  }
  if (options.allowBigInt === true) {
    return value2;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value2 = -1 - int;
    if (value2 >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value2, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned2);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned2 < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned2 < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned2 < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned2 < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length23) {
  assertEnoughData(data, pos, prefix + length23);
  const buf2 = slice(data, pos + prefix, pos + prefix + length23);
  return new Token(Type.bytes, buf2, prefix + length23);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length23, options) {
  const totLength = prefix + length23;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length23) {
  return new Token(Type.array, length23, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length23) {
  return new Token(Type.map, length23, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value2, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value2)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value2, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent2) {
    this.obj = obj;
    this.parent = parent2;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e of obj) {
      entries[i2++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length23 = isMap ? obj.size : keys.length;
    if (!length23) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length23),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length23),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode5(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value2;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value2);
    } else {
      obj[key] = value2;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode7(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code2 = 113;
var encode6 = (node) => encode5(node, encodeOptions);
var decode8 = (data) => decode7(data, decodeOptions);

// node_modules/@ipld/dag-json/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  code: () => code3,
  decode: () => decode10,
  encode: () => encode8,
  name: () => name3
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from3 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher(name22, code22, encode81);
var Hasher = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest15) => create(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/cborg/esm/lib/json/encode.js
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
    }
    buf2.push(isa);
  }
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString2(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf2.push([91]);
  }
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf2.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
      if (!dp && (isa[i2] === 46 || isa[i2] === 101 || isa[i2] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = {
  addBreakTokens: true,
  mapSorter: mapSorter2
};
function encode7(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}

// node_modules/cborg/esm/lib/json/decode.js
var Tokenizer = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i2 = 0; i2 < str.length; i2++) {
      if (this.data[this.pos++] !== str[i2]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float = false;
    const swallow = (chars2) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars2.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i2 = this.pos, l = 0; i2 < this.data.length && l < 65536; i2++, l++) {
      const ch = this.data[i2];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i2));
        this.pos = i2 + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars2 = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars2.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars2.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars2.push(ch1);
              break;
            case 98:
              chars2.push(8);
              break;
            case 116:
              chars2.push(9);
              break;
            case 110:
              chars2.push(10);
              break;
            case 102:
              chars2.push(12);
              break;
            case 114:
              chars2.push(13);
              break;
            case 117:
              chars2.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars2), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars2.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
};
function decode9(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode7(data, options);
}

// node_modules/@ipld/dag-json/esm/index.js
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base642.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Uint8Array: bytesEncoder,
    Buffer: bytesEncoder,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i2 = 0; i2 < 2; i2++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base642.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[42] = CID.parse;
var name3 = "dag-json";
var code3 = 297;
var encode8 = (node) => encode7(node, encodeOptions2);
var decode10 = (data) => {
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(data, decodeOptions2) });
  return decode9(data, options);
};

// node_modules/dag-jose/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  code: () => code4,
  decode: () => decode13,
  encode: () => encode11,
  name: () => name4,
  toGeneral: () => toGeneral
});

// node_modules/dag-jose/lib/utils.js
function toBase64url(b) {
  return base64url2.encode(b).slice(1);
}
function fromBase64url(s) {
  return base64url2.decode(`u${s}`);
}

// node_modules/dag-jose/lib/signing.js
function fromSplit(split) {
  const [protectedHeader, payload, signature] = split;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode9(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign5 = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign5.header = encoded.header;
  if (encoded.protected)
    sign5.protected = toBase64url(encoded.protected);
  return sign5;
}
function decode11(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID.decode(new Uint8Array(encoded.payload));
  return decoded;
}

// node_modules/dag-jose/lib/encryption.js
function fromSplit2(split) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode10(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode12(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}

// node_modules/dag-jose/lib/index.js
var name4 = "dag-jose";
var code4 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split = jose.split(".");
    if (split.length === 3) {
      return fromSplit(split);
    } else if (split.length === 5) {
      return fromSplit2(split);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode11(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode9(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode10(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode6(encodedJose));
}
function decode13(data) {
  let encoded;
  try {
    encoded = decode8(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode11(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode12(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var code5 = 0;
var name5 = "identity";
var encode12 = coerce2;
var digest = (input) => create(code5, encode12(input));
var identity = {
  code: code5,
  name: name5,
  encode: encode12,
  digest
};

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2 = from2({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode13(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode14(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from2({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode13,
  decode: decode14
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var sha = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha256 = from3({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from3({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code6,
  decode: () => decode15,
  encode: () => encode14,
  name: () => name6
});
var name6 = "raw";
var code6 = 85;
var encode14 = (node) => coerce2(node);
var decode15 = (data) => coerce2(data);

// node_modules/multiformats/esm/src/codecs/json.js
var json_exports2 = {};
__export(json_exports2, {
  code: () => code7,
  decode: () => decode16,
  encode: () => encode15,
  name: () => name7
});
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var name7 = "json";
var code7 = 512;
var encode15 = (node) => textEncoder4.encode(JSON.stringify(node));
var decode16 = (data) => JSON.parse(textDecoder3.decode(data));

// node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports2,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports
};
var codecs = {
  raw: raw_exports,
  json: json_exports2
};

// node_modules/ipfs-core-config/src/init-assets.browser.js
function initAssets() {
}

// node_modules/ipfs-core/src/errors.js
var NotInitializedError = class extends Error {
  constructor(message6 = "not initialized") {
    super(message6);
    this.name = "NotInitializedError";
    this.code = NotInitializedError.code;
  }
};
NotInitializedError.code = "ERR_NOT_INITIALIZED";
var AlreadyInitializingError = class extends Error {
  constructor(message6 = "cannot initialize an initializing node") {
    super(message6);
    this.name = "AlreadyInitializingError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
var AlreadyInitializedError = class extends Error {
  constructor(message6 = "cannot re-initialize an initialized node") {
    super(message6);
    this.name = "AlreadyInitializedError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
var NotStartedError = class extends Error {
  constructor(message6 = "not started") {
    super(message6);
    this.name = "NotStartedError";
    this.code = NotStartedError.code;
  }
};
NotStartedError.code = "ERR_NOT_STARTED";
var AlreadyStartingError = class extends Error {
  constructor(message6 = "cannot start, already startin") {
    super(message6);
    this.name = "AlreadyStartingError";
    this.code = AlreadyStartingError.code;
  }
};
AlreadyStartingError.code = "ERR_ALREADY_STARTING";
var AlreadyStartedError = class extends Error {
  constructor(message6 = "cannot start, already started") {
    super(message6);
    this.name = "AlreadyStartedError";
    this.code = AlreadyStartedError.code;
  }
};
AlreadyStartedError.code = "ERR_ALREADY_STARTED";
var NotEnabledError = class extends Error {
  constructor(message6 = "not enabled") {
    super(message6);
    this.name = "NotEnabledError";
    this.code = NotEnabledError.code;
  }
};
NotEnabledError.code = "ERR_NOT_ENABLED";

// node_modules/uint8arrays/esm/src/util/bases.js
init_alloc();
function createCodec(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: { decode: decode97 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/uint8arrays/esm/src/from-string.js
init_as_uint8array();
function fromString3(string14, encoding = "utf8") {
  const base30 = bases_default[encoding];
  if (!base30) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/ipfs-core/src/components/index.js
var import_timeout_abort_controller19 = __toESM(require_timeout_abort_controller(), 1);

// node_modules/is-ipfs/node_modules/multiformats/vendor/base-x.js
function base3(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/is-ipfs/node_modules/multiformats/src/bytes.js
var empty3 = new Uint8Array(0);
var equals3 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce3 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/is-ipfs/node_modules/multiformats/src/bases/base.js
var Encoder3 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder3({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec3 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name22, prefix, baseEncode);
    this.decoder = new Decoder3(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from4 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec3(name22, prefix, encode81, decode97);
var baseX3 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default3(alphabet16, name22);
  return from4({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce3(decode97(text))
  });
};
var decode17 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode16 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46483 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from4({
    prefix,
    name: name22,
    encode(input) {
      return encode16(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode17(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/is-ipfs/node_modules/multiformats/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/is-ipfs/node_modules/multiformats/src/bases/base32.js
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/is-ipfs/node_modules/multiformats/vendor/varint.js
var encode_12 = encode17;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode17(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode17.bytes = offset - oldOffset + 1;
  return out;
}
var decode18 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value2) {
  return value2 < N12 ? 1 : value2 < N22 ? 2 : value2 < N32 ? 3 : value2 < N42 ? 4 : value2 < N52 ? 5 : value2 < N62 ? 6 : value2 < N72 ? 7 : value2 < N82 ? 8 : value2 < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode18,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/is-ipfs/node_modules/multiformats/src/varint.js
var decode19 = (data, offset = 0) => {
  const code22 = varint_default2.decode(data, offset);
  return [code22, varint_default2.decode.bytes];
};
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength2 = (int) => {
  return varint_default2.encodingLength(int);
};

// node_modules/is-ipfs/node_modules/multiformats/src/hashes/digest.js
var create2 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength2(code22);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo2(code22, bytes2, 0);
  encodeTo2(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest2(code22, size, digest15, bytes2);
};
var decode20 = (multihash) => {
  const bytes2 = coerce3(multihash);
  const [code22, sizeOffset] = decode19(bytes2);
  const [size, digestOffset] = decode19(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code22, size, digest15, bytes2);
};
var equals4 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
  }
};
var Digest2 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js
function base4(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src4 = base4;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js
var empty4 = new Uint8Array(0);
var equals5 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce4 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString4 = (str) => new TextEncoder().encode(str);
var toString3 = (b) => new TextDecoder().decode(b);

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js
var Encoder4 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or4 = (left, right) => new ComposedDecoder4({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec4 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name22, prefix, baseEncode);
    this.decoder = new Decoder4(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from5 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec4(name22, prefix, encode81, decode97);
var baseX4 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default4(alphabet16, name22);
  return from5({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce4(decode97(text))
  });
};
var decode21 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode18 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46484 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from5({
    prefix,
    name: name22,
    encode(input) {
      return encode18(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode21(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js
var identity3 = from5({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString3(buf2),
  decode: (str) => fromString4(str)
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base23
});
var base23 = rfc46484({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46484({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102 = baseX4({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46484({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46484({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base324,
  base32hex: () => base32hex4,
  base32hexpad: () => base32hexpad4,
  base32hexpadupper: () => base32hexpadupper4,
  base32hexupper: () => base32hexupper4,
  base32pad: () => base32pad4,
  base32padupper: () => base32padupper4,
  base32upper: () => base32upper4,
  base32z: () => base32z4
});
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX4({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX4({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc4,
  base58flickr: () => base58flickr4
});
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643 = rfc46484({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46484({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46484({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46484({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = alphabet2.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode19(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode22(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from5({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode19,
  decode: decode22
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2562,
  sha512: () => sha5122
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js
var encode_13 = encode20;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode20(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode20.bytes = offset - oldOffset + 1;
  return out;
}
var decode23 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value2) {
  return value2 < N13 ? 1 : value2 < N23 ? 2 : value2 < N33 ? 3 : value2 < N43 ? 4 : value2 < N53 ? 5 : value2 < N63 ? 6 : value2 < N73 ? 7 : value2 < N83 ? 8 : value2 < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode23,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js
var decode24 = (data, offset = 0) => {
  const code22 = varint_default3.decode(data, offset);
  return [code22, varint_default3.decode.bytes];
};
var encodeTo3 = (int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
};
var encodingLength3 = (int) => {
  return varint_default3.encodingLength(int);
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js
var create3 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength3(code22);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo3(code22, bytes2, 0);
  encodeTo3(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest3(code22, size, digest15, bytes2);
};
var decode25 = (multihash) => {
  const bytes2 = coerce4(multihash);
  const [code22, sizeOffset] = decode24(bytes2);
  const [size, digestOffset] = decode24(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code22, size, digest15, bytes2);
};
var equals6 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals5(a.bytes, data.bytes);
  }
};
var Digest3 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js
var from6 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher2(name22, code22, encode81);
var Hasher2 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest15) => create3(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2562 = from6({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5122 = from6({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});
var code8 = 0;
var name8 = "identity";
var encode21 = coerce4;
var digest2 = (input) => create3(code8, encode21(input));
var identity4 = { code: code8, name: name8, encode: encode21, digest: digest2 };

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js
var textEncoder5 = new TextEncoder();
var textDecoder4 = new TextDecoder();

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js
var format = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV02(
        bytes2,
        baseCache(link),
        base30 || base58btc4.encoder
      );
    default:
      return toStringV12(
        bytes2,
        baseCache(link),
        base30 || base324.encoder
      );
  }
};
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache16 = cache.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID2 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID2.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create3(code22, digest15);
        return CID2.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID2.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals6(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format(this, base30);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID2) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID2(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID2(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol2] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode25(multihash);
      return CID2.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE2) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`
          );
        } else {
          return new CID2(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID2(version4, code22, digest15.bytes);
        return new CID2(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID2.create(0, DAG_PB_CODE2, digest15);
  }
  static createV1(code22, digest15) {
    return CID2.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID2.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID2.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest3(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID2.createV0(digest15) : CID2.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode24(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE2;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes2(source, base30);
    const cid = CID2.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc4;
      return [
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base30 || base58btc4;
      return [base58btc4.prefix, decoder.decode(source)];
    }
    case base324.prefix: {
      const decoder = base30 || base324;
      return [base324.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV02 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID2 = (version4, code22, multihash) => {
  const codeOffset = encodingLength3(version4);
  const hashOffset = codeOffset + encodingLength3(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version4, bytes2, 0);
  encodeTo3(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string2 = createCodec2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe2(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases2.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases2
};
var bases_default2 = BASES2;

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js
function toString4(array, encoding = "utf8") {
  const base30 = bases_default2[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isV4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i2]);
        sections[i2] = toString4(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString4(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
        ;
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      const word2 = parseInt(sections[i2], 16);
      bytes2[offset++] = word2 >> 8 & 255;
      bytes2[offset++] = word2 & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
var toString5 = function(buf2, offset = 0, length23) {
  offset = ~~offset;
  length23 = length23 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length23 === 4) {
    const result = [];
    for (let i2 = 0; i2 < length23; i2++) {
      result.push(buf2[offset + i2]);
    }
    return result.join(".");
  }
  if (length23 === 16) {
    const result = [];
    for (let i2 = 0; i2 < length23; i2 += 2) {
      result.push(view.getUint16(offset + i2).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [281, 0, "webrtc-w3c"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  [421, V, "ipfs"],
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code22, size, name22, resolvable, path2) {
  return {
    code: code22,
    size,
    name: name22,
    resolvable: Boolean(resolvable),
    path: Boolean(path2)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/@multiformats/multiaddr/dist/src/convert.js
var import_varint4 = __toESM(require_varint(), 1);

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js
function fromString5(string14, encoding = "utf8") {
  const base30 = bases_default2[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array2(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length23) {
  if (length23 == null) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToString(proto, buf2) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString4(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString5(str, "base16");
  }
}
var decoders = Object.values(bases2).map((c) => c.decoder);
var anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString5(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString5(str);
  const size = Uint8Array.from(import_varint4.default.encode(buf2.length));
  return concat2([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = import_varint4.default.decode(buf2);
  buf2 = buf2.slice(import_varint4.default.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString4(buf2);
}
function mh2bytes(hash3) {
  let mh;
  if (hash3[0] === "Q" || hash3[0] === "1") {
    mh = decode25(base58btc4.decode(`z${hash3}`)).bytes;
  } else {
    mh = CID2.parse(hash3).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint4.default.encode(mh.length));
  return concat2([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint4.default.encode(mb.length));
  return concat2([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = import_varint4.default.decode(buf2);
  const hash3 = buf2.slice(import_varint4.default.decode.bytes);
  if (hash3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString4(hash3, "base64url");
}
function bytes2mh(buf2) {
  const size = import_varint4.default.decode(buf2);
  const address = buf2.slice(import_varint4.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString4(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base324.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base324.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString4(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// node_modules/@multiformats/multiaddr/dist/src/codec.js
var import_varint5 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts2 = str.split("/").slice(1);
  if (parts2.length === 1 && parts2[0] === "") {
    return [];
  }
  for (let p = 0; p < parts2.length; p++) {
    const part = parts2[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts2.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        cleanPath(parts2.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts2[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts2 = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts2.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts2.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts2.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat2(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(import_varint5.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat2([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint5.default.decode(addr);
    return size + (import_varint5.default.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i2 = 0;
  while (i2 < buf2.length) {
    const code22 = import_varint5.default.decode(buf2, i2);
    const n = import_varint5.default.decode.bytes ?? 0;
    const p = getProtocol(code22);
    const size = sizeForAddr(p, buf2.slice(i2 + n));
    if (size === 0) {
      tuples.push([code22]);
      i2 += n;
      continue;
    }
    const addr = buf2.slice(i2 + n, i2 + n + size);
    i2 += size + n;
    if (i2 > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString4(buf2, "base16"));
    }
    tuples.push([code22, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString6(str) {
  return stringToBytes(str);
}
function fromBytes(buf2) {
  const err2 = validateBytes(buf2);
  if (err2 != null) {
    throw err2;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err2) {
    return err2;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint6 = __toESM(require_varint());
var import_err_code2 = __toESM(require_err_code());

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js
function equals7(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _DefaultMultiaddr_string;
var _DefaultMultiaddr_tuples;
var _DefaultMultiaddr_stringTuples;
var _a;
var inspect = Symbol.for("nodejs.util.inspect.custom");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function fromNodeAddress(addr, transport) {
  if (addr == null) {
    throw new Error("requires node address object");
  }
  if (transport == null) {
    throw new Error("requires transport protocol");
  }
  let ip;
  let host = addr.address;
  switch (addr.family) {
    case 4:
      ip = "ip4";
      break;
    case 6:
      ip = "ip6";
      if (host.includes("%")) {
        const parts2 = host.split("%");
        if (parts2.length !== 2) {
          throw Error("Multiple ip6 zones in multiaddr");
        }
        host = parts2[0];
        const zone = parts2[1];
        ip = `/ip6zone/${zone}/ip6`;
      }
      break;
    default:
      throw Error("Invalid addr family, should be 4 or 6.");
  }
  return new DefaultMultiaddr("/" + [ip, host, transport, addr.port].join("/"));
}
function isName(addr) {
  if (!isMultiaddr(addr)) {
    return false;
  }
  return addr.protos().some((proto) => proto.resolvable);
}
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol]);
}
var DefaultMultiaddr = class {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString6(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code22, value2] of this.stringTuples()) {
      if (code22 === ip6zone.code) {
        zone = `%${value2 ?? ""}`;
      }
      if (DNS_CODES.includes(code22)) {
        transport = tcp.name;
        port = 443;
        host = `${value2 ?? ""}${zone}`;
        family = code22 === dns6.code ? 6 : 4;
      }
      if (code22 === tcp.code || code22 === udp.code) {
        transport = getProtocol(code22).name;
        port = parseInt(value2 ?? "");
      }
      if (code22 === ip4.code || code22 === ip6.code) {
        transport = getProtocol(code22).name;
        host = `${value2 ?? ""}${zone}`;
        family = code22 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code22) => Object.assign({}, getProtocol(code22)));
  }
  protoCodes() {
    const codes6 = [];
    const buf2 = this.bytes;
    let i2 = 0;
    while (i2 < buf2.length) {
      const code22 = import_varint6.default.decode(buf2, i2);
      const n = import_varint6.default.decode.bytes ?? 0;
      const p = getProtocol(code22);
      const size = sizeForAddr(p, buf2.slice(i2 + n));
      i2 += size + n;
      codes6.push(code22);
    }
    return codes6;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new DefaultMultiaddr(addr);
    return new DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i2 = s.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new DefaultMultiaddr(s.slice(0, i2));
  }
  decapsulateCode(code22) {
    const tuples = this.tuples();
    for (let i2 = tuples.length - 1; i2 >= 0; i2--) {
      if (tuples[i2][0] === code22) {
        return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i2)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString4(base58btc4.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString4(CID2.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path2 = null;
    try {
      path2 = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path2 == null) {
        path2 = null;
      }
    } catch {
      path2 = null;
    }
    return path2;
  }
  equals(addr) {
    return equals7(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code2.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
};
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS4 = base5("dns4");
var DNS6 = base5("dns6");
var DNSADDR = base5("dnsaddr");
var DNS = or5(base5("dns"), DNSADDR, DNS4, DNS6);
var IP = or5(base5("ip4"), base5("ip6"));
var TCP = or5(and(IP, base5("tcp")), and(DNS, base5("tcp")));
var UDP = and(IP, base5("udp"));
var UTP = and(UDP, base5("utp"));
var QUIC = and(UDP, base5("quic"));
var WebSockets = or5(and(TCP, base5("ws")), and(DNS, base5("ws")));
var WebSocketsSecure = or5(and(TCP, base5("wss")), and(DNS, base5("wss")), and(TCP, base5("tls"), base5("ws")), and(DNS, base5("tls"), base5("ws")));
var HTTP = or5(and(TCP, base5("http")), and(IP, base5("http")), and(DNS, base5("http")));
var HTTPS = or5(and(TCP, base5("https")), and(IP, base5("https")), and(DNS, base5("https")));
var _WebRTC = and(UDP, base5("webrtc"), base5("certhash"));
var WebRTC = or5(and(_WebRTC, base5("p2p")), _WebRTC);
var WebRTCStar = or5(and(WebSockets, base5("p2p-webrtc-star"), base5("p2p")), and(WebSocketsSecure, base5("p2p-webrtc-star"), base5("p2p")), and(WebSockets, base5("p2p-webrtc-star")), and(WebSocketsSecure, base5("p2p-webrtc-star")));
var WebSocketStar = or5(and(WebSockets, base5("p2p-websocket-star"), base5("p2p")), and(WebSocketsSecure, base5("p2p-websocket-star"), base5("p2p")), and(WebSockets, base5("p2p-websocket-star")), and(WebSocketsSecure, base5("p2p-websocket-star")));
var WebRTCDirect = or5(and(HTTP, base5("p2p-webrtc-direct"), base5("p2p")), and(HTTPS, base5("p2p-webrtc-direct"), base5("p2p")), and(HTTP, base5("p2p-webrtc-direct")), and(HTTPS, base5("p2p-webrtc-direct")));
var Reliable = or5(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS, WebRTC);
var Stardust = or5(and(Reliable, base5("p2p-stardust"), base5("p2p")), and(Reliable, base5("p2p-stardust")));
var _P2P = or5(and(Reliable, base5("p2p")), WebRTCStar, WebRTCDirect, WebRTC, base5("p2p"));
var _Circuit = or5(and(_P2P, base5("p2p-circuit"), _P2P), and(_P2P, base5("p2p-circuit")), and(base5("p2p-circuit"), _P2P), and(Reliable, base5("p2p-circuit")), and(base5("p2p-circuit"), Reliable), base5("p2p-circuit"));
var CircuitRecursive = () => or5(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or5(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var IPFS = P2P;
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or5(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base5(n) {
  const name22 = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name22) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name22) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name22;
    },
    matches,
    partialMatch
  };
}

// node_modules/is-ipfs/node_modules/multiformats/src/cid.js
var format2 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV03(
        bytes2,
        baseCache2(link),
        base30 || base58btc3.encoder
      );
    default:
      return toStringV13(
        bytes2,
        baseCache2(link),
        base30 || base323.encoder
      );
  }
};
var cache2 = /* @__PURE__ */ new WeakMap();
var baseCache2 = (cid) => {
  const baseCache16 = cache2.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID3 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID3.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create2(code22, digest15);
        return CID3.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID3.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format2(this, base30);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID3) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID3(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID3(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol3] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode20(multihash);
      return CID3.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE3) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`
          );
        } else {
          return new CID3(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID3(version4, code22, digest15.bytes);
        return new CID3(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID3.create(0, DAG_PB_CODE3, digest15);
  }
  static createV1(code22, digest15) {
    return CID3.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID3.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID3.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest2(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID3.createV0(digest15) : CID3.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode19(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE3;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes3(source, base30);
    const cid = CID3.decode(bytes2);
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes3 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base30 || base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base30 || base323;
      return [base323.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV03 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV13 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
var encodeCID3 = (version4, code22, multihash) => {
  const codeOffset = encodingLength2(version4);
  const hashOffset = codeOffset + encodingLength2(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version4, bytes2, 0);
  encodeTo2(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/is-ipfs/dist/src/index.js
var import_iso_url = __toESM(require_iso_url());

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/vendor/base-x.js
function base6(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src5 = base6;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default5 = _brrp__multiformats_scope_baseX5;

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bytes.js
var empty5 = new Uint8Array(0);
var equals8 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce5 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString7 = (str) => new TextEncoder().encode(str);
var toString6 = (b) => new TextDecoder().decode(b);

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base.js
var Encoder5 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder5 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or6(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or6 = (left, right) => new ComposedDecoder5({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec5 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name22, prefix, baseEncode);
    this.decoder = new Decoder5(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from7 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec5(name22, prefix, encode81, decode97);
var baseX5 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default5(alphabet16, name22);
  return from7({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce5(decode97(text))
  });
};
var decode26 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode22 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46485 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from7({
    prefix,
    name: name22,
    encode(input) {
      return encode22(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode26(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity5 = from7({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString6(buf2),
  decode: (str) => fromString7(str)
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base24
});
var base24 = rfc46485({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
var base83 = rfc46485({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});
var base103 = baseX5({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
var base163 = rfc46485({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc46485({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base325,
  base32hex: () => base32hex5,
  base32hexpad: () => base32hexpad5,
  base32hexpadupper: () => base32hexpadupper5,
  base32hexupper: () => base32hexupper5,
  base32pad: () => base32pad5,
  base32padupper: () => base32padupper5,
  base32upper: () => base32upper5,
  base32z: () => base32z5
});
var base325 = rfc46485({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46485({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46485({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46485({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46485({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46485({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46485({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46485({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46485({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base363,
  base36upper: () => base36upper3
});
var base363 = baseX5({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX5({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc5,
  base58flickr: () => base58flickr5
});
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base644,
  base64pad: () => base64pad4,
  base64url: () => base64url4,
  base64urlpad: () => base64urlpad4
});
var base644 = rfc46485({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad4 = rfc46485({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url4 = rfc46485({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad4 = rfc46485({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = alphabet3.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes3 = alphabet3.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode23(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
function decode27(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes3[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji3 = from7({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode23,
  decode: decode27
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2563,
  sha512: () => sha5123
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/vendor/varint.js
var encode_14 = encode24;
var MSB4 = 128;
var REST4 = 127;
var MSBALL4 = ~REST4;
var INT4 = Math.pow(2, 31);
function encode24(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode24.bytes = offset - oldOffset + 1;
  return out;
}
var decode28 = read4;
var MSB$14 = 128;
var REST$14 = 127;
function read4(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length4 = function(value2) {
  return value2 < N14 ? 1 : value2 < N24 ? 2 : value2 < N34 ? 3 : value2 < N44 ? 4 : value2 < N54 ? 5 : value2 < N64 ? 6 : value2 < N74 ? 7 : value2 < N84 ? 8 : value2 < N94 ? 9 : 10;
};
var varint7 = {
  encode: encode_14,
  decode: decode28,
  encodingLength: length4
};
var _brrp_varint4 = varint7;
var varint_default4 = _brrp_varint4;

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/varint.js
var decode29 = (data, offset = 0) => {
  const code22 = varint_default4.decode(data, offset);
  return [code22, varint_default4.decode.bytes];
};
var encodeTo4 = (int, target, offset = 0) => {
  varint_default4.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default4.encodingLength(int);
};

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/hashes/digest.js
var create4 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength4(code22);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo4(code22, bytes2, 0);
  encodeTo4(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest4(code22, size, digest15, bytes2);
};
var decode30 = (multihash) => {
  const bytes2 = coerce5(multihash);
  const [code22, sizeOffset] = decode29(bytes2);
  const [size, digestOffset] = decode29(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code22, size, digest15, bytes2);
};
var equals9 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals8(a.bytes, data.bytes);
  }
};
var Digest4 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/hashes/hasher.js
var from8 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher3(name22, code22, encode81);
var Hasher3 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest15) => create4(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha3 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2563 = from8({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5123 = from8({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});
var code9 = 0;
var name9 = "identity";
var encode25 = coerce5;
var digest3 = (input) => create4(code9, encode25(input));
var identity6 = { code: code9, name: name9, encode: encode25, digest: digest3 };

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/codecs/json.js
var textEncoder6 = new TextEncoder();
var textDecoder5 = new TextDecoder();

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/cid.js
var format3 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV04(
        bytes2,
        baseCache3(link),
        base30 || base58btc5.encoder
      );
    default:
      return toStringV14(
        bytes2,
        baseCache3(link),
        base30 || base325.encoder
      );
  }
};
var cache3 = /* @__PURE__ */ new WeakMap();
var baseCache3 = (cid) => {
  const baseCache16 = cache3.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID4 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID4.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create4(code22, digest15);
        return CID4.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID4.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals9(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format3(this, base30);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID4) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID4(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID4(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol4] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode30(multihash);
      return CID4.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE4) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`
          );
        } else {
          return new CID4(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID4(version4, code22, digest15.bytes);
        return new CID4(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID4.create(0, DAG_PB_CODE4, digest15);
  }
  static createV1(code22, digest15) {
    return CID4.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID4.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID4.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce5(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest4(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID4.createV0(digest15) : CID4.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode29(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE4;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes4(source, base30);
    const cid = CID4.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes4 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc5;
      return [
        base58btc5.prefix,
        decoder.decode(`${base58btc5.prefix}${source}`)
      ];
    }
    case base58btc5.prefix: {
      const decoder = base30 || base58btc5;
      return [base58btc5.prefix, decoder.decode(source)];
    }
    case base325.prefix: {
      const decoder = base30 || base325;
      return [base325.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV04 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc5.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV14 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
var encodeCID4 = (version4, code22, multihash) => {
  const codeOffset = encodingLength4(version4);
  const hashOffset = codeOffset + encodingLength4(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version4, bytes2, 0);
  encodeTo4(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/is-ipfs/node_modules/uint8arrays/node_modules/multiformats/src/basics.js
var bases3 = { ...identity_exports5, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports6 };

// node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array3(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/is-ipfs/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe3(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array3(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec3(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string3 = createCodec3("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii3 = createCodec3("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe3(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases3.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases3
};
var bases_default3 = BASES3;

// node_modules/is-ipfs/node_modules/uint8arrays/dist/src/to-string.js
function toString7(array, encoding = "utf8") {
  const base30 = bases_default3[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/is-ipfs/dist/src/index.js
var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
var defaultProtocolMatch = 1;
var defaultHashMath = 2;
var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isCID(hash3) {
  try {
    if (isString(hash3)) {
      return Boolean(CID3.parse(hash3));
    }
    if (hash3 instanceof Uint8Array) {
      return Boolean(CID3.decode(hash3));
    }
    return Boolean(CID3.asCID(hash3));
  } catch {
    return false;
  }
}
function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString2(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipfs") {
    return false;
  }
  let hash3 = match[hashMatch];
  if (hash3 != null && pattern === subdomainGatewayPattern) {
    hash3 = hash3.toLowerCase();
  }
  return isCID(hash3);
}
function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString2(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipns") {
    return false;
  }
  let ipnsId = match[hashMatch];
  if (ipnsId != null && pattern === subdomainGatewayPattern) {
    ipnsId = ipnsId.toLowerCase();
    if (isCID(ipnsId))
      return true;
    try {
      if (!ipnsId.includes(".") && ipnsId.includes("-")) {
        ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
      }
      const { hostname } = new import_iso_url.URL(`http://${ipnsId}`);
      return fqdnWithTld.test(hostname);
    } catch (e) {
      return false;
    }
  }
  return true;
}
function isString(input) {
  return typeof input === "string";
}
function convertToString2(input) {
  if (input instanceof Uint8Array) {
    return toString7(input, "base58btc");
  }
  if (isString(input)) {
    return input;
  }
  return false;
}
var path = (path2) => isIpfs(path2, pathPattern) || isIpns(path2, pathPattern);
var ipfsPath = (path2) => isIpfs(path2, pathPattern);
var ipnsPath = (path2) => isIpns(path2, pathPattern);

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/interface-datastore/node_modules/multiformats/src/bases/identity.js
var identity_exports7 = {};
__export(identity_exports7, {
  identity: () => identity7
});

// node_modules/interface-datastore/node_modules/multiformats/vendor/base-x.js
function base7(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src6 = base7;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default6 = _brrp__multiformats_scope_baseX6;

// node_modules/interface-datastore/node_modules/multiformats/src/bytes.js
var empty6 = new Uint8Array(0);
var equals10 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce6 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString8 = (str) => new TextEncoder().encode(str);
var toString8 = (b) => new TextDecoder().decode(b);

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base.js
var Encoder6 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or7(this, decoder);
  }
};
var ComposedDecoder6 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or7(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or7 = (left, right) => new ComposedDecoder6({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec6 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name22, prefix, baseEncode);
    this.decoder = new Decoder6(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from9 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec6(name22, prefix, encode81, decode97);
var baseX6 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default6(alphabet16, name22);
  return from9({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce6(decode97(text))
  });
};
var decode31 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode26 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46486 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from9({
    prefix,
    name: name22,
    encode(input) {
      return encode26(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode31(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/interface-datastore/node_modules/multiformats/src/bases/identity.js
var identity7 = from9({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString8(buf2),
  decode: (str) => fromString8(str)
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base2.js
var base2_exports4 = {};
__export(base2_exports4, {
  base2: () => base25
});
var base25 = rfc46486({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base8.js
var base8_exports4 = {};
__export(base8_exports4, {
  base8: () => base84
});
var base84 = rfc46486({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base10.js
var base10_exports4 = {};
__export(base10_exports4, {
  base10: () => base104
});
var base104 = baseX6({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base16.js
var base16_exports4 = {};
__export(base16_exports4, {
  base16: () => base164,
  base16upper: () => base16upper4
});
var base164 = rfc46486({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper4 = rfc46486({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base32.js
var base32_exports4 = {};
__export(base32_exports4, {
  base32: () => base326,
  base32hex: () => base32hex6,
  base32hexpad: () => base32hexpad6,
  base32hexpadupper: () => base32hexpadupper6,
  base32hexupper: () => base32hexupper6,
  base32pad: () => base32pad6,
  base32padupper: () => base32padupper6,
  base32upper: () => base32upper6,
  base32z: () => base32z6
});
var base326 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base36.js
var base36_exports4 = {};
__export(base36_exports4, {
  base36: () => base364,
  base36upper: () => base36upper4
});
var base364 = baseX6({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper4 = baseX6({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base58.js
var base58_exports4 = {};
__export(base58_exports4, {
  base58btc: () => base58btc6,
  base58flickr: () => base58flickr6
});
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base64.js
var base64_exports4 = {};
__export(base64_exports4, {
  base64: () => base645,
  base64pad: () => base64pad5,
  base64url: () => base64url5,
  base64urlpad: () => base64urlpad5
});
var base645 = rfc46486({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad5 = rfc46486({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url5 = rfc46486({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad5 = rfc46486({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/interface-datastore/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports4 = {};
__export(base256emoji_exports4, {
  base256emoji: () => base256emoji4
});
var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars4 = alphabet4.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes4 = alphabet4.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode27(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars4[c];
    return p;
  }, "");
}
function decode32(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes4[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji4 = from9({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode27,
  decode: decode32
});

// node_modules/interface-datastore/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports4 = {};
__export(sha2_browser_exports4, {
  sha256: () => sha2564,
  sha512: () => sha5124
});

// node_modules/interface-datastore/node_modules/multiformats/vendor/varint.js
var encode_15 = encode28;
var MSB5 = 128;
var REST5 = 127;
var MSBALL5 = ~REST5;
var INT5 = Math.pow(2, 31);
function encode28(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode28.bytes = offset - oldOffset + 1;
  return out;
}
var decode33 = read5;
var MSB$15 = 128;
var REST$15 = 127;
function read5(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read5.bytes = counter - offset;
  return res;
}
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length5 = function(value2) {
  return value2 < N15 ? 1 : value2 < N25 ? 2 : value2 < N35 ? 3 : value2 < N45 ? 4 : value2 < N55 ? 5 : value2 < N65 ? 6 : value2 < N75 ? 7 : value2 < N85 ? 8 : value2 < N95 ? 9 : 10;
};
var varint8 = {
  encode: encode_15,
  decode: decode33,
  encodingLength: length5
};
var _brrp_varint5 = varint8;
var varint_default5 = _brrp_varint5;

// node_modules/interface-datastore/node_modules/multiformats/src/varint.js
var decode34 = (data, offset = 0) => {
  const code22 = varint_default5.decode(data, offset);
  return [code22, varint_default5.decode.bytes];
};
var encodeTo5 = (int, target, offset = 0) => {
  varint_default5.encode(int, target, offset);
  return target;
};
var encodingLength5 = (int) => {
  return varint_default5.encodingLength(int);
};

// node_modules/interface-datastore/node_modules/multiformats/src/hashes/digest.js
var create5 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength5(code22);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo5(code22, bytes2, 0);
  encodeTo5(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest5(code22, size, digest15, bytes2);
};
var decode35 = (multihash) => {
  const bytes2 = coerce6(multihash);
  const [code22, sizeOffset] = decode34(bytes2);
  const [size, digestOffset] = decode34(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code22, size, digest15, bytes2);
};
var equals11 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals10(a.bytes, data.bytes);
  }
};
var Digest5 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/interface-datastore/node_modules/multiformats/src/hashes/hasher.js
var from10 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher4(name22, code22, encode81);
var Hasher4 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest15) => create5(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/interface-datastore/node_modules/multiformats/src/hashes/sha2-browser.js
var sha4 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2564 = from10({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5124 = from10({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/interface-datastore/node_modules/multiformats/src/hashes/identity.js
var identity_exports8 = {};
__export(identity_exports8, {
  identity: () => identity8
});
var code10 = 0;
var name10 = "identity";
var encode29 = coerce6;
var digest4 = (input) => create5(code10, encode29(input));
var identity8 = { code: code10, name: name10, encode: encode29, digest: digest4 };

// node_modules/interface-datastore/node_modules/multiformats/src/codecs/json.js
var textEncoder7 = new TextEncoder();
var textDecoder6 = new TextDecoder();

// node_modules/interface-datastore/node_modules/multiformats/src/cid.js
var format4 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV05(
        bytes2,
        baseCache4(link),
        base30 || base58btc6.encoder
      );
    default:
      return toStringV15(
        bytes2,
        baseCache4(link),
        base30 || base326.encoder
      );
  }
};
var cache4 = /* @__PURE__ */ new WeakMap();
var baseCache4 = (cid) => {
  const baseCache16 = cache4.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID5 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID5.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create5(code22, digest15);
        return CID5.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID5.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals11(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format4(this, base30);
  }
  toJSON() {
    return { "/": format4(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID5) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID5(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID5(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol5] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode35(multihash);
      return CID5.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE5) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`
          );
        } else {
          return new CID5(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID5(version4, code22, digest15.bytes);
        return new CID5(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID5.create(0, DAG_PB_CODE5, digest15);
  }
  static createV1(code22, digest15) {
    return CID5.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID5.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID5.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce6(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest5(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID5.createV0(digest15) : CID5.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode34(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE5;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes5(source, base30);
    const cid = CID5.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes5 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc6;
      return [
        base58btc6.prefix,
        decoder.decode(`${base58btc6.prefix}${source}`)
      ];
    }
    case base58btc6.prefix: {
      const decoder = base30 || base58btc6;
      return [base58btc6.prefix, decoder.decode(source)];
    }
    case base326.prefix: {
      const decoder = base30 || base326;
      return [base326.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV05 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc6.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV15 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
var encodeCID5 = (version4, code22, multihash) => {
  const codeOffset = encodingLength5(version4);
  const hashOffset = codeOffset + encodingLength5(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version4, bytes2, 0);
  encodeTo5(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/interface-datastore/node_modules/multiformats/src/basics.js
var bases4 = { ...identity_exports7, ...base2_exports4, ...base8_exports4, ...base10_exports4, ...base16_exports4, ...base32_exports4, ...base36_exports4, ...base58_exports4, ...base64_exports4, ...base256emoji_exports4 };
var hashes4 = { ...sha2_browser_exports4, ...identity_exports8 };

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array4(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe4(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array4(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec4(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string4 = createCodec4("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii4 = createCodec4("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe4(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES4 = {
  utf8: string4,
  "utf-8": string4,
  hex: bases4.base16,
  latin1: ascii4,
  ascii: ascii4,
  binary: ascii4,
  ...bases4
};
var bases_default4 = BASES4;

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/to-string.js
function toString9(array, encoding = "utf8") {
  const base30 = bases_default4[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/from-string.js
function fromString9(string14, encoding = "utf8") {
  const base30 = bases_default4[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array4(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class {
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString9(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  toString(encoding = "utf8") {
    return toString9(this._buf, encoding);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(s) {
    return new Key(this.toString() + ":" + s);
  }
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts2 = ns.split(":");
  if (parts2.length < 2) {
    return "";
  }
  return parts2.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts2 = ns.split(":");
  return parts2[parts2.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/ipfs-core/src/utils.js
var import_err_code4 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core-utils/src/with-timeout-option.js
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller());
var import_any_signal = __toESM(require_any_signal());

// node_modules/parse-duration/index.mjs
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse.nanosecond = parse.ns = 1 / 1e6;
parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
parse.millisecond = parse.ms = parse[""] = 1;
parse.second = parse.sec = parse.s = parse.ms * 1e3;
parse.minute = parse.min = parse.m = parse.s * 60;
parse.hour = parse.hr = parse.h = parse.m * 60;
parse.day = parse.d = parse.h * 24;
parse.week = parse.wk = parse.w = parse.d * 7;
parse.month = parse.b = parse.d * (365.25 / 12);
parse.year = parse.yr = parse.y = parse.d * 365.25;
function parse(str = "", format16 = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format16) || 1);
}
function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, "")];
}
var parse_duration_default = parse;

// node_modules/ipfs-core-utils/src/errors.js
var TimeoutError = class extends Error {
  constructor(message6 = "request timed out") {
    super(message6);
    this.name = "TimeoutError";
    this.code = TimeoutError.code;
  }
};
TimeoutError.code = "ERR_TIMEOUT";

// node_modules/ipfs-core-utils/src/with-timeout-option.js
function withTimeoutOption(fn, optionsArgIndex) {
  return (...args) => {
    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
    if (!options || !options.timeout)
      return fn(...args);
    const timeout = typeof options.timeout === "string" ? parse_duration_default(options.timeout) : options.timeout;
    const controller = new import_timeout_abort_controller.TimeoutController(timeout);
    options.signal = (0, import_any_signal.anySignal)([options.signal, controller.signal]);
    const fnRes = fn(...args);
    const timeoutPromise = new Promise((_resolve, reject) => {
      controller.signal.addEventListener("abort", () => {
        reject(new TimeoutError());
      });
    });
    const start = Date.now();
    const maybeThrowTimeoutError = () => {
      if (controller.signal.aborted) {
        throw new TimeoutError();
      }
      const timeTaken = Date.now() - start;
      if (timeTaken > timeout) {
        controller.abort();
        throw new TimeoutError();
      }
    };
    if (fnRes[Symbol.asyncIterator]) {
      return async function* () {
        const it = fnRes[Symbol.asyncIterator]();
        try {
          while (true) {
            const { value: value2, done } = await Promise.race([it.next(), timeoutPromise]);
            if (done) {
              break;
            }
            maybeThrowTimeoutError();
            yield value2;
          }
        } catch (err2) {
          maybeThrowTimeoutError();
          throw err2;
        } finally {
          controller.clear();
          if (it.return) {
            it.return();
          }
        }
      }();
    }
    return (async () => {
      try {
        const res = await Promise.race([fnRes, timeoutPromise]);
        maybeThrowTimeoutError();
        return res;
      } catch (err2) {
        maybeThrowTimeoutError();
        throw err2;
      } finally {
        controller.clear();
      }
    })();
  };
}

// node_modules/ipfs-core-utils/src/to-cid-and-path.js
var import_err_code3 = __toESM(require_err_code());
var IPFS_PREFIX = "/ipfs/";
function toCidAndPath(string14) {
  if (string14 instanceof Uint8Array) {
    try {
      string14 = CID.decode(string14);
    } catch (err2) {
      throw (0, import_err_code3.default)(err2, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string14);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string14 = string14.toString();
  if (string14.startsWith(IPFS_PREFIX)) {
    string14 = string14.substring(IPFS_PREFIX.length);
  }
  const parts2 = string14.split("/");
  let path2;
  try {
    cid = CID.parse(parts2.shift() || "");
  } catch (err2) {
    throw (0, import_err_code3.default)(err2, "ERR_INVALID_CID");
  }
  if (parts2.length) {
    path2 = `/${parts2.join("/")}`;
  }
  return {
    cid,
    path: path2
  };
}

// node_modules/ipfs-core/src/utils.js
var ERR_BAD_PATH = "ERR_BAD_PATH";
var OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
var MFS_ROOT_KEY = new Key("/local/filesroot");
var MFS_MAX_CHUNK_SIZE = 262144;
var normalizePath = (pathStr) => {
  const cid = CID.asCID(pathStr);
  if (cid) {
    return `/ipfs/${pathStr}`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${CID.parse(str)}`;
  } catch {
  }
  if (path(str)) {
    return str;
  } else {
    throw (0, import_err_code4.default)(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
  }
};
var normalizeCidPath = (path2) => {
  if (path2 instanceof Uint8Array) {
    return CID.decode(path2).toString();
  }
  path2 = path2.toString();
  if (path2.indexOf("/ipfs/") === 0) {
    path2 = path2.substring("/ipfs/".length);
  }
  if (path2.charAt(path2.length - 1) === "/") {
    path2 = path2.substring(0, path2.length - 1);
  }
  return path2;
};
var resolvePath = async function(repo, codecs2, ipfsPath3, options = {}) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath3);
  if (path2) {
    options.path = path2;
  }
  let lastCid = cid;
  let lastRemainderPath = options.path || "";
  if (lastRemainderPath.startsWith("/")) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const { value: value2, remainderPath } of resolve(cid, options.path, codecs2, repo, {
        signal: options.signal
      })) {
        if (!CID.asCID(value2)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value2;
      }
    } catch (err2) {
      if (err2.message.startsWith("Object has no property")) {
        err2.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
        err2.code = "ERR_NO_LINK";
      }
      throw err2;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ""
  };
};
var mapFile = (file) => {
  if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
    throw new Error(`Unknown node type '${file.type}'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: "file"
  };
  if (file.type === "directory") {
    output.type = "dir";
  }
  if (file.type === "file") {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === "file" || file.type === "directory") {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== void 0) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
var withTimeout = withTimeoutOption(
  async (promise, _options) => await promise
);
var resolve = async function* (cid, path2, codecs2, repo, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await repo.blocks.get(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw (0, import_err_code4.default)(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (cid.code === code && Array.isArray(value2.Links)) {
      const link = value2.Links.find((l) => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts2.join("/")
        };
        value2 = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw (0, import_err_code4.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    if (CID.asCID(value2)) {
      lastCid = value2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
};

// node_modules/ipfs-core/src/utils/service.js
var Service = class {
  static create({ start, stop: stop2 }) {
    return new Service(start, stop2);
  }
  static async start(service, options) {
    const { state, activate } = service;
    switch (state.status) {
      case "stopped": {
        try {
          const promise = activate(options);
          service.state = { status: "starting", ready: promise };
          const result = await promise;
          service.state = { status: "started", value: result };
          return result;
        } catch (error) {
          service.state = { status: "stopped" };
          throw error;
        }
      }
      case "starting": {
        throw new AlreadyStartingError();
      }
      case "started": {
        throw new AlreadyStartedError();
      }
      case "stopping": {
        await state.ready;
        return await Service.start(service, options);
      }
      default: {
        return Service.panic(service);
      }
    }
  }
  static async stop(service) {
    const { state, deactivate } = service;
    switch (state.status) {
      case "stopped": {
        break;
      }
      case "starting": {
        try {
          await state.ready;
        } catch (_) {
        }
        return await Service.stop(service);
      }
      case "stopping": {
        return await state.ready;
      }
      case "started": {
        if (deactivate) {
          await deactivate(state.value);
        }
        service.state = { status: "stopped" };
        break;
      }
      default: {
        Service.panic(state);
      }
    }
  }
  static try({ state }) {
    switch (state.status) {
      case "started":
        return state.value;
      default:
        return null;
    }
  }
  static async use({ state }, options) {
    switch (state.status) {
      case "started":
        return state.value;
      case "starting":
        return await withTimeout(state.ready, options);
      default:
        throw new NotStartedError();
    }
  }
  static panic({ state }) {
    const status = JSON.stringify({ status: state.status });
    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
  }
  constructor(activate, deactivate) {
    this.activate = activate;
    this.deactivate = deactivate;
    this.state = { status: "stopped" };
  }
  async use(options) {
    return await Service.use(this, options);
  }
  try() {
    return Service.try(this);
  }
};

// node_modules/ipfs-core/src/components/start.js
function createStart({ network, preload: preload2, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {
  const start = async () => {
    const { libp2p } = await Service.start(network, {
      peerId,
      repo,
      print,
      hashers,
      options
    });
    await Promise.all([
      ipns.startOnline({ keychain, libp2p, peerId, repo }),
      preload2.start(),
      mfsPreload.start()
    ]);
  };
  return start;
}

// node_modules/ipfs-core/src/components/stop.js
function createStop({ network, preload: preload2, ipns, repo, mfsPreload }) {
  const stop2 = async () => {
    await Promise.all([
      preload2.stop(),
      ipns.stop(),
      mfsPreload.stop()
    ]);
    await Service.stop(network);
    await repo.close();
  };
  return stop2;
}

// node_modules/ipfs-core-config/src/utils/tlru.js
var import_hashlru = __toESM(require_hashlru(), 1);
var TLRU = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// node_modules/p-queue/dist/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/p-queue/node_modules/p-timeout/index.js
var TimeoutError2 = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message6) {
    super();
    this.name = "AbortError";
    this.message = message6;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message6 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message6);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value2, comparator) {
  let first10 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first10 + step;
    if (comparator(array[it], value2) <= 0) {
      first10 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first10;
}

// node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet2(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet2(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();

// node_modules/p-queue/dist/index.js
var __classPrivateFieldSet2 = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pending;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_throwOnAbort;
var _PQueue_onEvent;
var AbortError2 = class extends Error {
};
var PQueue = class extends import_eventemitter3.default {
  constructor(options) {
    var _a3, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pending.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a3 = options.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet2(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet2(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet2(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet2(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet2(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet2(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet2(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet2(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet3(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet2(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet3(this, _PQueue_throwOnTimeout, "f"),
      ...options
    };
    return new Promise((resolve7, reject) => {
      __classPrivateFieldGet3(this, _PQueue_queue, "f").enqueue(async () => {
        var _a3;
        var _b, _c;
        __classPrivateFieldSet2(this, _PQueue_pending, (_b = __classPrivateFieldGet3(this, _PQueue_pending, "f"), _b++, _b), "f");
        __classPrivateFieldSet2(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet3(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a3 = options.signal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
            throw new AbortError2("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
          }
          const result = await operation;
          resolve7(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
            resolve7();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  start() {
    if (!__classPrivateFieldGet3(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet2(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  pause() {
    __classPrivateFieldSet2(this, _PQueue_isPaused, true, "f");
  }
  clear() {
    __classPrivateFieldSet2(this, _PQueue_queue, new (__classPrivateFieldGet3(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet3(this, _PQueue_queue, "f").size < limit);
  }
  async onIdle() {
    if (__classPrivateFieldGet3(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet3(this, _PQueue_queue, "f").size;
  }
  sizeBy(options) {
    return __classPrivateFieldGet3(this, _PQueue_queue, "f").filter(options).length;
  }
  get pending() {
    return __classPrivateFieldGet3(this, _PQueue_pending, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet3(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet3(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet3(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet3(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet3(this, _PQueue_pending, "f") < __classPrivateFieldGet3(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a3;
  __classPrivateFieldSet2(this, _PQueue_pending, (_a3 = __classPrivateFieldGet3(this, _PQueue_pending, "f"), _a3--, _a3), "f");
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet2(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet3(this, _PQueue_intervalId, "f") === void 0) {
    const delay3 = __classPrivateFieldGet3(this, _PQueue_intervalEnd, "f") - now;
    if (delay3 < 0) {
      __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet3(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet3(this, _PQueue_pending, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet3(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet2(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay3), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet3(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet3(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet2(this, _PQueue_intervalId, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet3(this, _PQueue_pending, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet3(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet3(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet3(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet3(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet2(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet3(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet2(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet3(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet3(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet3(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet2(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet3(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet3(this, _PQueue_pending, "f") : 0, "f");
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort2(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError2("The task was aborted."));
    }, { once: true });
  });
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter14) {
  return new Promise((resolve7) => {
    const listener = () => {
      if (filter14 && !filter14()) {
        return;
      }
      this.off(event, listener);
      resolve7();
    };
    this.on(event, listener);
  });
};

// node_modules/ipfs-core-config/src/dns.browser.js
var import_http = __toESM(require_http());
var cache5 = new TLRU(1e3);
var ttl = 60 * 1e3;
var Queue = PQueue.default ? PQueue.default : PQueue;
var httpQueue = new Queue({ concurrency: 4 });
var ipfsPath2 = (response) => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve7 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache5.has(query)) {
      const response2 = cache5.get(query);
      return ipfsPath2(response2);
    }
    const response = await httpQueue.add(async () => {
      const res = await import_http.default.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache5.set(query2, json, ttl);
      return json;
    });
    return ipfsPath2(response);
  };
  return resolve7(fqdn, opts);
}

// node_modules/ipfs-core/src/components/dns.js
function fqdnFixups(domain) {
  if (domain.endsWith(".eth")) {
    domain = domain.replace(/.eth$/, ".eth.link");
  }
  return domain;
}
function createDns() {
  const resolveDNS = async (domain, options = { recursive: true }) => {
    if (typeof domain !== "string") {
      throw new Error("Invalid arguments, domain must be a string");
    }
    domain = fqdnFixups(domain);
    return resolveDnslink(domain, options);
  };
  return withTimeoutOption(resolveDNS);
}

// node_modules/ipfs-core/src/components/is-online.js
function createIsOnline({ network }) {
  return () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js
var encode_16 = encode30;
var MSB6 = 128;
var REST6 = 127;
var MSBALL6 = ~REST6;
var INT6 = Math.pow(2, 31);
function encode30(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode30.bytes = offset - oldOffset + 1;
  return out;
}
var decode36 = read6;
var MSB$16 = 128;
var REST$16 = 127;
function read6(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read6.bytes = counter - offset;
  return res;
}
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length6 = function(value2) {
  return value2 < N16 ? 1 : value2 < N26 ? 2 : value2 < N36 ? 3 : value2 < N46 ? 4 : value2 < N56 ? 5 : value2 < N66 ? 6 : value2 < N76 ? 7 : value2 < N86 ? 8 : value2 < N96 ? 9 : 10;
};
var varint9 = {
  encode: encode_16,
  decode: decode36,
  encodingLength: length6
};
var _brrp_varint6 = varint9;
var varint_default6 = _brrp_varint6;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js
var decode37 = (data, offset = 0) => {
  const code22 = varint_default6.decode(data, offset);
  return [code22, varint_default6.decode.bytes];
};
var encodeTo6 = (int, target, offset = 0) => {
  varint_default6.encode(int, target, offset);
  return target;
};
var encodingLength6 = (int) => {
  return varint_default6.encodingLength(int);
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js
var empty7 = new Uint8Array(0);
var equals12 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce7 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString10 = (str) => new TextEncoder().encode(str);
var toString10 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js
var create6 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength6(code22);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo6(code22, bytes2, 0);
  encodeTo6(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest6(code22, size, digest15, bytes2);
};
var decode38 = (multihash) => {
  const bytes2 = coerce7(multihash);
  const [code22, sizeOffset] = decode37(bytes2);
  const [size, digestOffset] = decode37(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code22, size, digest15, bytes2);
};
var equals13 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals12(a.bytes, data.bytes);
  }
};
var Digest6 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58_exports5 = {};
__export(base58_exports5, {
  base58btc: () => base58btc7,
  base58flickr: () => base58flickr7
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js
function base9(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src7 = base9;
var _brrp__multiformats_scope_baseX7 = src7;
var base_x_default7 = _brrp__multiformats_scope_baseX7;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js
var Encoder7 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder7 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or8(this, decoder);
  }
};
var ComposedDecoder7 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or8(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or8 = (left, right) => new ComposedDecoder7({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec7 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder7(name22, prefix, baseEncode);
    this.decoder = new Decoder7(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from11 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec7(name22, prefix, encode81, decode97);
var baseX7 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default7(alphabet16, name22);
  return from11({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce7(decode97(text))
  });
};
var decode39 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode31 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46487 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from11({
    prefix,
    name: name22,
    encode(input) {
      return encode31(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode39(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58btc7 = baseX7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr7 = baseX7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js
var base32_exports5 = {};
__export(base32_exports5, {
  base32: () => base327,
  base32hex: () => base32hex7,
  base32hexpad: () => base32hexpad7,
  base32hexpadupper: () => base32hexpadupper7,
  base32hexupper: () => base32hexupper7,
  base32pad: () => base32pad7,
  base32padupper: () => base32padupper7,
  base32upper: () => base32upper7,
  base32z: () => base32z7
});
var base327 = rfc46487({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper7 = rfc46487({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad7 = rfc46487({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper7 = rfc46487({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex7 = rfc46487({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper7 = rfc46487({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad7 = rfc46487({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper7 = rfc46487({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z7 = rfc46487({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js
var format5 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV06(
        bytes2,
        baseCache5(link),
        base30 || base58btc7.encoder
      );
    default:
      return toStringV16(
        bytes2,
        baseCache5(link),
        base30 || base327.encoder
      );
  }
};
var cache6 = /* @__PURE__ */ new WeakMap();
var baseCache5 = (cid) => {
  const baseCache16 = cache6.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache6.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID6 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID6.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create6(code22, digest15);
        return CID6.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID6.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals13(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format5(this, base30);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID6) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID6(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID6(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol6] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode38(multihash);
      return CID6.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE6) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`
          );
        } else {
          return new CID6(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID6(version4, code22, digest15.bytes);
        return new CID6(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID6.create(0, DAG_PB_CODE6, digest15);
  }
  static createV1(code22, digest15) {
    return CID6.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID6.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID6.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest6(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID6.createV0(digest15) : CID6.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode37(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE6;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes6(source, base30);
    const cid = CID6.decode(bytes2);
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes6 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc7;
      return [
        base58btc7.prefix,
        decoder.decode(`${base58btc7.prefix}${source}`)
      ];
    }
    case base58btc7.prefix: {
      const decoder = base30 || base58btc7;
      return [base58btc7.prefix, decoder.decode(source)];
    }
    case base327.prefix: {
      const decoder = base30 || base327;
      return [base327.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV06 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc7.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV16 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
var encodeCID6 = (version4, code22, multihash) => {
  const codeOffset = encodingLength6(version4);
  const hashOffset = codeOffset + encodingLength6(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version4, bytes2, 0);
  encodeTo6(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js
var identity_exports9 = {};
__export(identity_exports9, {
  identity: () => identity9
});
var identity9 = from11({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString10(buf2),
  decode: (str) => fromString10(str)
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js
var base2_exports5 = {};
__export(base2_exports5, {
  base2: () => base26
});
var base26 = rfc46487({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js
var base8_exports5 = {};
__export(base8_exports5, {
  base8: () => base85
});
var base85 = rfc46487({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js
var base10_exports5 = {};
__export(base10_exports5, {
  base10: () => base105
});
var base105 = baseX7({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js
var base16_exports5 = {};
__export(base16_exports5, {
  base16: () => base165,
  base16upper: () => base16upper5
});
var base165 = rfc46487({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper5 = rfc46487({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js
var base36_exports5 = {};
__export(base36_exports5, {
  base36: () => base365,
  base36upper: () => base36upper5
});
var base365 = baseX7({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper5 = baseX7({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js
var base64_exports5 = {};
__export(base64_exports5, {
  base64: () => base646,
  base64pad: () => base64pad6,
  base64url: () => base64url6,
  base64urlpad: () => base64urlpad6
});
var base646 = rfc46487({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad6 = rfc46487({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url6 = rfc46487({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad6 = rfc46487({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports5 = {};
__export(base256emoji_exports5, {
  base256emoji: () => base256emoji5
});
var alphabet5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars5 = alphabet5.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes5 = alphabet5.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode32(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars5[c];
    return p;
  }, "");
}
function decode40(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes5[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji5 = from11({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode32,
  decode: decode40
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports5 = {};
__export(sha2_browser_exports5, {
  sha256: () => sha2565,
  sha512: () => sha5125
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js
var from12 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher5(name22, code22, encode81);
var Hasher5 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest15) => create6(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha5 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2565 = from12({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5125 = from12({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js
var identity_exports10 = {};
__export(identity_exports10, {
  identity: () => identity10
});
var code11 = 0;
var name11 = "identity";
var encode33 = coerce7;
var digest5 = (input) => create6(code11, encode33(input));
var identity10 = { code: code11, name: name11, encode: encode33, digest: digest5 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js
var textEncoder8 = new TextEncoder();
var textDecoder7 = new TextDecoder();

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js
var bases5 = { ...identity_exports9, ...base2_exports5, ...base8_exports5, ...base10_exports5, ...base16_exports5, ...base32_exports5, ...base36_exports5, ...base58_exports5, ...base64_exports5, ...base256emoji_exports5 };
var hashes5 = { ...sha2_browser_exports5, ...identity_exports10 };

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js
function equals14(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-id/dist/src/index.js
var import_err_code5 = __toESM(require_err_code());

// node_modules/@libp2p/interface-peer-id/dist/src/index.js
var symbol2 = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[symbol2]);
}

// node_modules/@libp2p/peer-id/dist/src/index.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases5).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases5.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  get [symbol2]() {
    return true;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc7.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toCID() {
    return CID6.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  toJSON() {
    return this.toString();
  }
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals14(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals14(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  [inspect2]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.type = "RSA";
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.type = "Ed25519";
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.type = "secp256k1";
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromPeerId(other) {
  if (other.type === "RSA") {
    return new RSAPeerIdImpl(other);
  }
  if (other.type === "Ed25519") {
    return new Ed25519PeerIdImpl(other);
  }
  if (other.type === "secp256k1") {
    return new Secp256k1PeerIdImpl(other);
  }
  throw (0, import_err_code5.default)(new Error("Not a PeerId"), "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode38(base58btc7.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode38(buf2);
    if (multihash.code === identity10.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2565.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID6.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2565.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity10.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create6(identity10.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create6(identity10.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha2565.digest(publicKey), publicKey, privateKey });
}

// node_modules/ipfs-core/src/components/resolve.js
function createResolve({ repo, codecs: codecs2, bases: bases15, name: name22 }) {
  async function resolve7(path2, opts = {}) {
    if (!path(path2)) {
      throw new Error("invalid argument " + path2);
    }
    if (ipnsPath(path2)) {
      for await (const resolvedPath of name22.resolve(path2, opts)) {
        path2 = resolvedPath;
      }
    }
    const [, schema, hash3, ...rest] = path2.split("/");
    const base30 = opts.cidBase ? await bases15.getBase(opts.cidBase) : void 0;
    const bytes2 = parseBytes(hash3);
    if (rest.length === 0) {
      const str = base30 ? base30.encoder.encode(bytes2) : hash3;
      return `/${schema}/${str}`;
    }
    const cid = CID.decode(bytes2);
    path2 = rest.join("/");
    const results = resolve(cid, path2, codecs2, repo, opts);
    let value2 = cid;
    let remainderPath = path2;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value2 = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${value2.toString(base30 && base30.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
  }
  return withTimeoutOption(resolve7);
}
function parseBytes(str) {
  try {
    return peerIdFromString(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}

// node_modules/ipfs-core/src/components/pin/add.js
var import_it_last = __toESM(require_it_last(), 1);
function createAdd({ addAll }) {
  return (path2, options = {}) => {
    let iter;
    const cid = CID.asCID(path2);
    if (cid) {
      iter = addAll([{
        cid,
        ...options
      }], options);
    } else {
      iter = addAll([{
        path: path2.toString(),
        ...options
      }], options);
    }
    return (0, import_it_last.default)(iter);
  };
}

// node_modules/ipfs-core-utils/src/pins/normalise-input.js
var import_err_code6 = __toESM(require_err_code());
async function* normaliseInput(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code6.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (Symbol.iterator in input) {
    const iterator = input[Symbol.iterator]();
    const first10 = iterator.next();
    if (first10.done)
      return iterator;
    if (CID.asCID(first10.value) || first10.value instanceof String || typeof first10.value === "string") {
      yield toPin({ cid: first10.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first10.value.cid != null || first10.value.path != null) {
      yield toPin(first10.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code6.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input) {
    const iterator = input[Symbol.asyncIterator]();
    const first10 = await iterator.next();
    if (first10.done)
      return iterator;
    if (CID.asCID(first10.value) || first10.value instanceof String || typeof first10.value === "string") {
      yield toPin({ cid: first10.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first10.value.cid != null || first10.value.path != null) {
      yield toPin(first10.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code6.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code6.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path2 = input.cid || `${input.path}`;
  if (!path2) {
    throw (0, import_err_code6.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path: path2,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

// node_modules/ipfs-repo/src/pin-types.js
var PinTypes = {
  direct: "direct",
  recursive: "recursive",
  indirect: "indirect",
  all: "all"
};

// node_modules/ipfs-core/src/components/pin/add-all.js
function createAddAll({ repo, codecs: codecs2 }) {
  async function* addAll(source, options = {}) {
    const pinAdd = async function* () {
      for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);
        if (reason === "recursive" && !recursive2) {
          throw new Error(`${cid} already pinned recursively`);
        }
        if (recursive2) {
          await repo.pins.pinRecursively(cid, { metadata });
        } else {
          await repo.pins.pinDirectly(cid, { metadata });
        }
        yield cid;
      }
    };
    const lock3 = Boolean(options.lock);
    if (!lock3) {
      yield* pinAdd();
      return;
    }
    const release = await repo.gcLock.readLock();
    try {
      yield* pinAdd();
    } finally {
      release();
    }
  }
  return withTimeoutOption(addAll);
}

// node_modules/ipfs-core/src/components/pin/ls.js
var import_err_code7 = __toESM(require_err_code(), 1);
function toPin2(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs({ repo, codecs: codecs2 }) {
  async function* ls(options = {}) {
    let type = PinTypes.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(PinTypes).includes(type)) {
        throw (0, import_err_code7.default)(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const { path: path2 } of normaliseInput(options.paths)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw (0, import_err_code7.default)(new Error(`path '${path2}' is not pinned`), "ERR_NOT_PINNED");
        }
        switch (reason) {
          case PinTypes.direct:
          case PinTypes.recursive:
            matched = true;
            yield toPin2(reason, cid, metadata);
            break;
          default:
            matched = true;
            yield toPin2(`${PinTypes.indirect} through ${parent2}`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error("No match found");
      }
      return;
    }
    if (type === PinTypes.recursive || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
        yield toPin2(PinTypes.recursive, cid, metadata);
      }
    }
    if (type === PinTypes.indirect || type === PinTypes.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin2(PinTypes.indirect, cid);
      }
    }
    if (type === PinTypes.direct || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.directKeys()) {
        yield toPin2(PinTypes.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption(ls);
}

// node_modules/ipfs-core/src/components/pin/rm.js
var import_it_last2 = __toESM(require_it_last(), 1);
function createRm({ rmAll }) {
  async function rm(path2, options = {}) {
    const cid = await (0, import_it_last2.default)(rmAll([{ path: path2, ...options }], options));
    if (!cid) {
      throw new Error("CID expected");
    }
    return cid;
  }
  return rm;
}

// node_modules/ipfs-core/src/components/pin/rm-all.js
function createRmAll({ repo, codecs: codecs2 }) {
  async function* rmAll(source, _options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      for await (const { path: path2, recursive: recursive2 } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes.all);
        if (!pinned) {
          throw new Error(`${cid} is not pinned`);
        }
        switch (reason) {
          case PinTypes.recursive:
            if (!recursive2) {
              throw new Error(`${cid} is pinned recursively`);
            }
            await repo.pins.unpin(cid);
            yield cid;
            break;
          case PinTypes.direct:
            await repo.pins.unpin(cid);
            yield cid;
            break;
          default:
            throw new Error(`${cid} is pinned indirectly under ${reason}`);
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(rmAll);
}

// node_modules/ipfs-core/src/components/pin/index.js
var PinAPI = class {
  constructor({ codecs: codecs2, repo }) {
    const addAll = createAddAll({ codecs: codecs2, repo });
    this.addAll = addAll;
    this.add = createAdd({ addAll });
    const rmAll = createRmAll({ codecs: codecs2, repo });
    this.rmAll = rmAll;
    this.rm = createRm({ rmAll });
    this.ls = createLs({ codecs: codecs2, repo });
    this.remote = {
      add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
      ls: async function* (query, options = {}) {
        return Promise.reject(new Error("Not implemented"));
      },
      rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      service: {
        add: (name22, credentials) => Promise.reject(new Error("Not implemented")),
        rm: (name22, options = {}) => Promise.reject(new Error("Not implemented")),
        ls: (options = {}) => Promise.reject(new Error("Not implemented"))
      }
    };
  }
};

// node_modules/ipfs-core/src/ipns/index.js
var import_err_code15 = __toESM(require_err_code(), 1);

// node_modules/datastore-core/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
var import_err_code8 = __toESM(require_err_code());
function dbOpenFailedError(err2) {
  err2 = err2 || new Error("Cannot open database");
  return (0, import_err_code8.default)(err2, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err2) {
  err2 = err2 || new Error("Delete failed");
  return (0, import_err_code8.default)(err2, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err2) {
  err2 = err2 || new Error("Write failed");
  return (0, import_err_code8.default)(err2, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code8.default)(err2, "ERR_NOT_FOUND");
}
function abortedError(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code8.default)(err2, "ERR_ABORTED");
}

// node_modules/ipfs-core/src/ipns/publisher.js
var import_err_code11 = __toESM(require_err_code(), 1);

// node_modules/uint8arrays/esm/src/to-string.js
function toString11(array, encoding = "utf8") {
  const base30 = bases_default[encoding];
  if (!base30) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/uint8arrays/esm/src/equals.js
function equals15(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/ipns/dist/src/index.js
var import_timestamp_nano = __toESM(require_timestamp_min());

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var keys_exports2 = {};
__export(keys_exports2, {
  generateEphemeralKeyPair: () => ephemeral_keys_default,
  generateKeyPair: () => generateKeyPair4,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed2,
  importKey: () => importKey,
  keyStretcher: () => keyStretcher,
  keysPBM: () => keys_exports,
  marshalPrivateKey: () => marshalPrivateKey,
  marshalPublicKey: () => marshalPublicKey2,
  supportedKeys: () => supportedKeys,
  unmarshalPrivateKey: () => unmarshalPrivateKey3,
  unmarshalPublicKey: () => unmarshalPublicKey2
});

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var keys_exports = {};
__export(keys_exports, {
  KeyType: () => KeyType,
  PrivateKey: () => PrivateKey,
  PublicKey: () => PublicKey
});

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/utils.js
var import_reader = __toESM(require_reader(), 1);
var import_reader_buffer = __toESM(require_reader_buffer(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_writer_buffer = __toESM(require_writer_buffer(), 1);
var import_minimal2 = __toESM(require_minimal(), 1);
function configure() {
  import_minimal2.default._configure();
  import_reader.default._configure(import_reader_buffer.default);
  import_writer.default._configure(import_writer_buffer.default);
}
configure();
var methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader(buf2) {
  return patchReader(new import_reader.default(buf2));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer() {
  return patchWriter(import_writer.default.create());
}

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf2, codec) {
  const r = reader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message6, codec) {
  const w = writer();
  codec.encode(message6, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES6) {
  CODEC_TYPES6[CODEC_TYPES6["VARINT"] = 0] = "VARINT";
  CODEC_TYPES6[CODEC_TYPES6["BIT64"] = 1] = "BIT64";
  CODEC_TYPES6[CODEC_TYPES6["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES6[CODEC_TYPES6["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec5(name22, type, encode81, decode97) {
  return {
    name: name22,
    type,
    encode: encode81,
    decode: decode97
  };
}

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode81 = function enumEncode(val, writer5) {
    const enumValue = findValue(val);
    writer5.int32(enumValue);
  };
  const decode97 = function enumDecode(reader6) {
    const val = reader6.int32();
    return findValue(val);
  };
  return createCodec5("enum", CODEC_TYPES.VARINT, encode81, decode97);
}

// node_modules/@libp2p/crypto/node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode81, decode97) {
  return createCodec5("message", CODEC_TYPES.LENGTH_DELIMITED, encode81, decode97);
}

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader6);
              break;
            case 2:
              obj.Data = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf2) => {
    return decodeMessage(buf2, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader6);
              break;
            case 2:
              obj.Data = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf2) => {
    return decodeMessage(buf2, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var import_asn12 = __toESM(require_asn1());
var import_pbe = __toESM(require_pbe());
var import_forge5 = __toESM(require_forge());

// node_modules/@libp2p/interfaces/dist/src/errors.js
var AbortError3 = class extends Error {
  constructor(message6 = "The operation was aborted") {
    super(message6);
    this.code = AbortError3.code;
    this.type = AbortError3.type;
  }
  static get code() {
    return "ABORT_ERR";
  }
  static get type() {
    return "aborted";
  }
};
var CodeError = class extends Error {
  constructor(message6, code22, props) {
    super(message6);
    this.code = code22;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/identity.js
var identity_exports11 = {};
__export(identity_exports11, {
  identity: () => identity11
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/base-x.js
function base11(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src8 = base11;
var _brrp__multiformats_scope_baseX8 = src8;
var base_x_default8 = _brrp__multiformats_scope_baseX8;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bytes.js
var empty8 = new Uint8Array(0);
var equals16 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce8 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString11 = (str) => new TextEncoder().encode(str);
var toString12 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base.js
var Encoder8 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder8 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or9(this, decoder);
  }
};
var ComposedDecoder8 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or9(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or9 = (left, right) => new ComposedDecoder8({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec8 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder8(name22, prefix, baseEncode);
    this.decoder = new Decoder8(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from13 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec8(name22, prefix, encode81, decode97);
var baseX8 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default8(alphabet16, name22);
  return from13({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce8(decode97(text))
  });
};
var decode41 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode34 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46488 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from13({
    prefix,
    name: name22,
    encode(input) {
      return encode34(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode41(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/identity.js
var identity11 = from13({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString12(buf2),
  decode: (str) => fromString11(str)
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base2.js
var base2_exports6 = {};
__export(base2_exports6, {
  base2: () => base27
});
var base27 = rfc46488({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base8.js
var base8_exports6 = {};
__export(base8_exports6, {
  base8: () => base86
});
var base86 = rfc46488({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base10.js
var base10_exports6 = {};
__export(base10_exports6, {
  base10: () => base106
});
var base106 = baseX8({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base16.js
var base16_exports6 = {};
__export(base16_exports6, {
  base16: () => base166,
  base16upper: () => base16upper6
});
var base166 = rfc46488({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper6 = rfc46488({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base32.js
var base32_exports6 = {};
__export(base32_exports6, {
  base32: () => base328,
  base32hex: () => base32hex8,
  base32hexpad: () => base32hexpad8,
  base32hexpadupper: () => base32hexpadupper8,
  base32hexupper: () => base32hexupper8,
  base32pad: () => base32pad8,
  base32padupper: () => base32padupper8,
  base32upper: () => base32upper8,
  base32z: () => base32z8
});
var base328 = rfc46488({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper8 = rfc46488({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad8 = rfc46488({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper8 = rfc46488({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex8 = rfc46488({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper8 = rfc46488({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad8 = rfc46488({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper8 = rfc46488({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z8 = rfc46488({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base36.js
var base36_exports6 = {};
__export(base36_exports6, {
  base36: () => base366,
  base36upper: () => base36upper6
});
var base366 = baseX8({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper6 = baseX8({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base58.js
var base58_exports6 = {};
__export(base58_exports6, {
  base58btc: () => base58btc8,
  base58flickr: () => base58flickr8
});
var base58btc8 = baseX8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr8 = baseX8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base64.js
var base64_exports6 = {};
__export(base64_exports6, {
  base64: () => base647,
  base64pad: () => base64pad7,
  base64url: () => base64url7,
  base64urlpad: () => base64urlpad7
});
var base647 = rfc46488({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad7 = rfc46488({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url7 = rfc46488({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad7 = rfc46488({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports6 = {};
__export(base256emoji_exports6, {
  base256emoji: () => base256emoji6
});
var alphabet6 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars6 = alphabet6.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes6 = alphabet6.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode35(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars6[c];
    return p;
  }, "");
}
function decode42(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes6[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji6 = from13({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode35,
  decode: decode42
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports6 = {};
__export(sha2_browser_exports6, {
  sha256: () => sha2566,
  sha512: () => sha5126
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/varint.js
var encode_17 = encode36;
var MSB7 = 128;
var REST7 = 127;
var MSBALL7 = ~REST7;
var INT7 = Math.pow(2, 31);
function encode36(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT7) {
    out[offset++] = num & 255 | MSB7;
    num /= 128;
  }
  while (num & MSBALL7) {
    out[offset++] = num & 255 | MSB7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode36.bytes = offset - oldOffset + 1;
  return out;
}
var decode43 = read7;
var MSB$17 = 128;
var REST$17 = 127;
function read7(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$17);
  read7.bytes = counter - offset;
  return res;
}
var N17 = Math.pow(2, 7);
var N27 = Math.pow(2, 14);
var N37 = Math.pow(2, 21);
var N47 = Math.pow(2, 28);
var N57 = Math.pow(2, 35);
var N67 = Math.pow(2, 42);
var N77 = Math.pow(2, 49);
var N87 = Math.pow(2, 56);
var N97 = Math.pow(2, 63);
var length7 = function(value2) {
  return value2 < N17 ? 1 : value2 < N27 ? 2 : value2 < N37 ? 3 : value2 < N47 ? 4 : value2 < N57 ? 5 : value2 < N67 ? 6 : value2 < N77 ? 7 : value2 < N87 ? 8 : value2 < N97 ? 9 : 10;
};
var varint10 = {
  encode: encode_17,
  decode: decode43,
  encodingLength: length7
};
var _brrp_varint7 = varint10;
var varint_default7 = _brrp_varint7;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/varint.js
var decode44 = (data, offset = 0) => {
  const code22 = varint_default7.decode(data, offset);
  return [code22, varint_default7.decode.bytes];
};
var encodeTo7 = (int, target, offset = 0) => {
  varint_default7.encode(int, target, offset);
  return target;
};
var encodingLength7 = (int) => {
  return varint_default7.encodingLength(int);
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/digest.js
var create7 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength7(code22);
  const digestOffset = sizeOffset + encodingLength7(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo7(code22, bytes2, 0);
  encodeTo7(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest7(code22, size, digest15, bytes2);
};
var decode45 = (multihash) => {
  const bytes2 = coerce8(multihash);
  const [code22, sizeOffset] = decode44(bytes2);
  const [size, digestOffset] = decode44(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest7(code22, size, digest15, bytes2);
};
var equals17 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals16(a.bytes, data.bytes);
  }
};
var Digest7 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/hasher.js
var from14 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher6(name22, code22, encode81);
var Hasher6 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest15) => create7(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/sha2-browser.js
var sha6 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2566 = from14({
  name: "sha2-256",
  code: 18,
  encode: sha6("SHA-256")
});
var sha5126 = from14({
  name: "sha2-512",
  code: 19,
  encode: sha6("SHA-512")
});

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/identity.js
var identity_exports12 = {};
__export(identity_exports12, {
  identity: () => identity12
});
var code12 = 0;
var name12 = "identity";
var encode37 = coerce8;
var digest6 = (input) => create7(code12, encode37(input));
var identity12 = { code: code12, name: name12, encode: encode37, digest: digest6 };

// node_modules/@libp2p/crypto/node_modules/multiformats/src/codecs/json.js
var textEncoder9 = new TextEncoder();
var textDecoder8 = new TextDecoder();

// node_modules/@libp2p/crypto/node_modules/multiformats/src/cid.js
var format6 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV07(
        bytes2,
        baseCache6(link),
        base30 || base58btc8.encoder
      );
    default:
      return toStringV17(
        bytes2,
        baseCache6(link),
        base30 || base328.encoder
      );
  }
};
var cache7 = /* @__PURE__ */ new WeakMap();
var baseCache6 = (cid) => {
  const baseCache16 = cache7.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache7.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID7 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID7.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create7(code22, digest15);
        return CID7.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID7.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals17(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format6(this, base30);
  }
  toJSON() {
    return { "/": format6(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID7) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID7(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID7(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol7] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode45(multihash);
      return CID7.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE7) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`
          );
        } else {
          return new CID7(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID7(version4, code22, digest15.bytes);
        return new CID7(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID7.create(0, DAG_PB_CODE7, digest15);
  }
  static createV1(code22, digest15) {
    return CID7.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID7.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID7.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce8(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest7(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID7.createV0(digest15) : CID7.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode44(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE7;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes7(source, base30);
    const cid = CID7.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache6(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes7 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc8;
      return [
        base58btc8.prefix,
        decoder.decode(`${base58btc8.prefix}${source}`)
      ];
    }
    case base58btc8.prefix: {
      const decoder = base30 || base58btc8;
      return [base58btc8.prefix, decoder.decode(source)];
    }
    case base328.prefix: {
      const decoder = base30 || base328;
      return [base328.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV07 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc8.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV17 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE7 = 112;
var SHA_256_CODE7 = 18;
var encodeCID7 = (version4, code22, multihash) => {
  const codeOffset = encodingLength7(version4);
  const hashOffset = codeOffset + encodingLength7(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo7(version4, bytes2, 0);
  encodeTo7(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/crypto/node_modules/multiformats/src/basics.js
var bases6 = { ...identity_exports11, ...base2_exports6, ...base8_exports6, ...base10_exports6, ...base16_exports6, ...base32_exports6, ...base36_exports6, ...base58_exports6, ...base64_exports6, ...base256emoji_exports6 };
var hashes6 = { ...sha2_browser_exports6, ...identity_exports12 };

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array5(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe5(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array5(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec6(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string5 = createCodec6("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii5 = createCodec6("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe5(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES5 = {
  utf8: string5,
  "utf-8": string5,
  hex: bases6.base16,
  latin1: ascii5,
  ascii: ascii5,
  binary: ascii5,
  ...bases6
};
var bases_default5 = BASES5;

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/from-string.js
function fromString12(string14, encoding = "utf8") {
  const base30 = bases_default5[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array5(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/concat.js
function concat3(arrays, length23) {
  if (length23 == null) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe5(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array5(output);
}

// node_modules/@libp2p/crypto/dist/src/webcrypto.js
var webcrypto_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};

// node_modules/@libp2p/crypto/dist/src/hmac/lengths.js
var lengths_default = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};

// node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js
var hashTypes = {
  SHA1: "SHA-1",
  SHA256: "SHA-256",
  SHA512: "SHA-512"
};
var sign = async (key, data) => {
  const buf2 = await webcrypto_default.get().subtle.sign({ name: "HMAC" }, key, data);
  return new Uint8Array(buf2, 0, buf2.byteLength);
};
async function create8(hashType, secret) {
  const hash3 = hashTypes[hashType];
  const key = await webcrypto_default.get().subtle.importKey("raw", secret, {
    name: "HMAC",
    hash: { name: hash3 }
  }, false, ["sign"]);
  return {
    async digest(data) {
      return await sign(key, data);
    },
    length: lengths_default[hashType]
  };
}

// node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js
var cipherMap = {
  "AES-128": {
    ivSize: 16,
    keySize: 16
  },
  "AES-256": {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    keySize: 32
  }
};
async function keyStretcher(cipherType, hash3, secret) {
  const cipher = cipherMap[cipherType];
  if (cipher == null) {
    const allowed = Object.keys(cipherMap).join(" / ");
    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, "ERR_INVALID_CIPHER_TYPE");
  }
  if (hash3 == null) {
    throw new CodeError("missing hash type", "ERR_MISSING_HASH_TYPE");
  }
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed2 = fromString12("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m = await create8(hash3, secret);
  let a = await m.digest(seed2);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m.digest(concat3([a, seed2]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a = await m.digest(a);
  }
  const half = resultLength / 2;
  const resultBuffer = concat3(result);
  const r1 = resultBuffer.subarray(0, half);
  const r2 = resultBuffer.subarray(half, resultLength);
  const createKey2 = (res) => ({
    iv: res.subarray(0, ivSize),
    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),
    macKey: res.subarray(ivSize + cipherKeySize)
  });
  return {
    k1: createKey2(r1),
    k2: createKey2(r2)
  };
}

// node_modules/@libp2p/crypto/dist/src/util.js
var import_util2 = __toESM(require_util(), 1);
var import_jsbn = __toESM(require_jsbn(), 1);
var import_forge = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/to-string.js
function toString13(array, encoding = "utf8") {
  const base30 = bases_default5[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/crypto/dist/src/util.js
function bigIntegerToUintBase64url(num, len) {
  let buf2 = Uint8Array.from(num.abs().toByteArray());
  buf2 = buf2[0] === 0 ? buf2.subarray(1) : buf2;
  if (len != null) {
    if (buf2.length > len)
      throw new Error("byte array longer than desired length");
    buf2 = concat3([new Uint8Array(len - buf2.length), buf2]);
  }
  return toString13(buf2, "base64url");
}
function base64urlToBigInteger(str) {
  const buf2 = base64urlToBuffer(str);
  return new import_forge.default.jsbn.BigInteger(toString13(buf2, "base16"), 16);
}
function base64urlToBuffer(str, len) {
  let buf2 = fromString12(str, "base64urlpad");
  if (len != null) {
    if (buf2.length > len)
      throw new Error("byte array longer than desired length");
    buf2 = concat3([new Uint8Array(len - buf2.length), buf2]);
  }
  return buf2;
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/equals.js
function equals18(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js
var bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes = Object.keys(bits);
var names2 = curveTypes.join(" / ");
async function generateEphmeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names2}`, "ERR_INVALID_CURVE");
  }
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "ECDH",
    namedCurve: curve
  }, true, ["deriveBits"]);
  const genSharedKey = async (theirPub, forcePrivate) => {
    let privateKey;
    if (forcePrivate != null) {
      privateKey = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
        name: "ECDH",
        namedCurve: curve
      }, false, ["deriveBits"]);
    } else {
      privateKey = pair2.privateKey;
    }
    const key = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
      name: "ECDH",
      namedCurve: curve
    }, false, []);
    const buffer2 = await webcrypto_default.get().subtle.deriveBits({
      name: "ECDH",
      namedCurve: curve,
      public: key
    }, privateKey, bits[curve]);
    return new Uint8Array(buffer2, 0, buffer2.byteLength);
  };
  const publicKey = await webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey);
  const ecdhKey = {
    key: marshalPublicKey(publicKey),
    genSharedKey
  };
  return ecdhKey;
}
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
function marshalPublicKey(jwk) {
  if (jwk.crv == null || jwk.x == null || jwk.y == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  if (jwk.crv !== "P-256" && jwk.crv !== "P-384" && jwk.crv !== "P-521") {
    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names2}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[jwk.crv];
  return concat3([
    Uint8Array.from([4]),
    base64urlToBuffer(jwk.x, byteLen),
    base64urlToBuffer(jwk.y, byteLen)
  ], 1 + byteLen * 2);
}
function unmarshalPublicKey(curve, key) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names2}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[curve];
  if (!equals18(key.subarray(0, 1), Uint8Array.from([4]))) {
    throw new CodeError("Cannot unmarshal public key - invalid key format", "ERR_INVALID_KEY_FORMAT");
  }
  return {
    kty: "EC",
    crv: curve,
    x: toString13(key.subarray(1, byteLen + 1), "base64url"),
    y: toString13(key.subarray(1 + byteLen), "base64url"),
    ext: true
  };
}
var unmarshalPrivateKey = (curve, key) => ({
  ...unmarshalPublicKey(curve, key.public),
  d: toString13(key.private, "base64url")
});

// node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js
var ephemeral_keys_default = generateEphmeralKeyPair;

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
function create9(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest15 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto4 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt2(data, password) {
    const salt = crypto4.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto4.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString12(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest15 } };
    const rawKey = await crypto4.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto4.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    const ciphertext = await crypto4.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat3([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt2(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString12(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest15 } };
    const rawKey = await crypto4.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto4.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    const plaintext = await crypto4.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt: encrypt2,
    decrypt: decrypt2
  };
  return cipher;
}

// node_modules/@libp2p/crypto/dist/src/keys/importer.js
async function importer(privateKey, password) {
  const encryptedKey = base647.decode(privateKey);
  const cipher = create9();
  return await cipher.decrypt(encryptedKey, password);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports = {};
__export(rsa_class_exports, {
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});
var import_sha512 = __toESM(require_sha512(), 1);
var import_forge4 = __toESM(require_forge(), 1);

// node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto = __toESM(require_crypto());
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = (a, b) => (a + b / _2n) / b;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod2(k - c1 * a1 - c2 * a2, n);
    let k2 = mod2(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n - k1;
    if (k2neg)
      k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  const { a, b } = CURVE;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n;
var ShaError = class extends Error {
  constructor(message6) {
    super(message6);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return JacobianPoint.ZERO;
    return new JacobianPoint(p.x, p.y, _1n);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod2(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(B * B);
    const x1b = X1 + B;
    const D = mod2(_2n * (mod2(x1b * x1b) - A - C));
    const E = mod2(_3n * A);
    const F = mod2(E * E);
    const X3 = mod2(F - _2n * D);
    const Y3 = mod2(E * (D - X3) - _8n * C);
    const Z3 = mod2(_2n * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n || Y2 === _0n)
      return this;
    if (X1 === _0n || Y1 === _0n)
      return other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    const H = mod2(U2 - U1);
    const r = mod2(S2 - S1);
    if (H === _0n) {
      if (r === _0n) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod2(H * H);
    const HHH = mod2(H * HH);
    const V2 = mod2(U1 * HH);
    const X3 = mod2(r * r - HHH - _2n * V2);
    const Y3 = mod2(r * (V2 - X3) - S1 * HHH);
    const Z3 = mod2(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n) {
        if (n & _1n)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n || k2 > _0n) {
      if (k1 & _1n)
        k1p = k1p.add(d);
      if (k2 & _1n)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n;
      k2 >>= _1n;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base30 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base30 = p;
      points.push(base30);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base30 = base30.add(p);
        points.push(base30);
      }
      p = base30.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f = JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y, z } = this;
    const is0 = this.equals(JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z);
    const iz1 = invZ;
    const iz2 = mod2(iz1 * iz1);
    const iz3 = mod2(iz2 * iz1);
    const ax = mod2(x * iz2);
    const ay = mod2(y * iz3);
    const zz = mod2(z * iz1);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n;
  }
  static fromCompressedHex(bytes2) {
    const isShort = bytes2.length === 32;
    const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass(x);
    let y = sqrtMod(y2);
    const isYOdd = (y & _1n) === _1n;
    if (isShort) {
      if (isYOdd)
        y = mod2(-y);
    } else {
      const isFirstByteOdd = (bytes2[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod2(-y);
    }
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes2) {
    const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
    const y = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes(hex);
    const len = bytes2.length;
    const header = bytes2[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes2);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes2);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r, s } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h = truncateHash(ensureBytes(msgHash));
    const { n } = CURVE;
    const radj = recovery === 2 || recovery === 3 ? r + n : r;
    const rinv = invert(radj, n);
    const u1 = mod2(-h * rinv, n);
    const u2 = mod2(s * rinv, n);
    const prefix = recovery & 1 ? "03" : "02";
    const R = Point.fromHex(prefix + numTo32bStr(radj));
    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod2(y * y);
    const right = weierstrass(x);
    if (mod2(left - right) !== _0n)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(this.x, mod2(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
  }
  return { r, s };
}
var Signature = class {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name22 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name22}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name22}: Expected 64-byte hex`);
    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
    return new Signature(r, s);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, mod2(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length23 = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length23}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length23 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length23);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes[uint8a[i2]];
  }
  return hex;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= num && num < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2(b3, _3n) * b3 % P;
  const b9 = pow2(b6, _3n) * b3 % P;
  const b11 = pow2(b9, _2n) * b2 % P;
  const b22 = pow2(b11, _11n) * b11 % P;
  const b44 = pow2(b22, _22n) * b22 % P;
  const b88 = pow2(b44, _44n) * b44 % P;
  const b176 = pow2(b88, _88n) * b88 % P;
  const b220 = pow2(b176, _44n) * b44 % P;
  const b223 = pow2(b220, _3n) * b3 % P;
  const t1 = pow2(b223, _23n) * b22 % P;
  const t2 = pow2(t1, _6n) * b2 % P;
  const rt = pow2(t2, _2n);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod2(number, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n)
      return acc;
    scratch[i2] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n)
      return acc;
    scratch[i2] = mod2(acc * scratch[i2], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes2) {
  const delta = bytes2.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes2);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash3, truncateOnly = false) {
  const h = bits2int_2(hash3);
  if (truncateOnly)
    return h;
  const { n } = CURVE;
  return h >= n ? h - n : h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed2);
    this.v = await this.hmac(this.v);
    if (seed2.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed2);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed2 = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed2);
    this.v = this.hmacSync(this.v);
    if (seed2.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed2);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes(...out);
  }
};
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
  const { n } = CURVE;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert(k, n);
  const q = Point.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n)
    return;
  const s = mod2(kinv * mod2(m + d * r, n), n);
  if (s === _0n)
    return;
  let sig = new Signature(r, s);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice2 = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
  return bytesToNumber(slice2);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z2 = mod2(z1, CURVE.n);
  return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(fieldLen);
    const e = ensureBytes(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed2 = concatBytes(...seedArgs);
  const m = bits2int(h1);
  return { seed: seed2, m, d };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign2(msgHash, privKey, opts = {}) {
  const { seed: seed2, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  await drbg.reseed(seed2);
  let sig;
  while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
var vopts = { strict: true };
function verify(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes(msgHash);
  } catch (error) {
    return false;
  }
  const { r, s } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n } = CURVE;
  const sinv = invert(s, n);
  const u1 = mod2(h * sinv, n);
  const u2 = mod2(r * sinv, n);
  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R)
    return false;
  const v = mod2(R.x, n);
  return v === r;
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod: mod2,
  invert,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash3) => {
    hash3 = ensureBytes(hash3);
    const minLen = groupLen + 8;
    if (hash3.length < minLen || hash3.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod2(bytesToNumber(hash3), CURVE.n - _1n) + _1n;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes: randomBytes3 } = crypto2.node;
      return Uint8Array.from(randomBytes3(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: async (...messages3) => {
    if (crypto2.web) {
      const buffer2 = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages3));
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHash } = crypto2.node;
      const hash3 = createHash("sha256");
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages3) => {
    if (crypto2.web) {
      const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message6 = concatBytes(...messages3);
      const buffer2 = await crypto2.web.subtle.sign("HMAC", ckey, message6);
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHmac } = crypto2.node;
      const hash3 = createHmac("sha256", key);
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages3) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages3);
  },
  taggedHashSync: (tag, ...messages3) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages3);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes(length23) {
  if (isNaN(length23) || length23 <= 0) {
    throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return utils.randomBytes(length23);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});
var import_asn1 = __toESM(require_asn1(), 1);
var import_rsa = __toESM(require_rsa(), 1);
var import_forge2 = __toESM(require_forge(), 1);
function pkcs1ToJwk(bytes2) {
  const asn1 = import_forge2.default.asn1.fromDer(toString13(bytes2, "ascii"));
  const privateKey = import_forge2.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString12(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}
function pkixToJwk(bytes2) {
  const asn1 = import_forge2.default.asn1.fromDer(toString13(bytes2, "ascii"));
  const publicKey = import_forge2.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString12(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}

// node_modules/@libp2p/crypto/dist/src/keys/jwk2pem.js
var import_rsa2 = __toESM(require_rsa(), 1);
var import_forge3 = __toESM(require_forge(), 1);
function convert(key, types2) {
  return types2.map((t) => base64urlToBigInteger(key[t]));
}
function jwk2priv(key) {
  return import_forge3.default.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
function jwk2pub(key) {
  return import_forge3.default.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js
async function generateKey(bits2) {
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits2,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey2(key) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return await Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return await webcrypto_default.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function convertKey(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub(key) : jwk2priv(key);
  const fmsg = toString13(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString12(fomsg, "ascii");
}
function encrypt(key, msg) {
  return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
function decrypt(key, msg) {
  return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}

// node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter(privateKey, password) {
  const cipher = create9();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base647.encode(encryptedKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var RsaPublicKey = class {
  constructor(key) {
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes2) {
    return encrypt(this._key, bytes2);
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
};
var RsaPrivateKey = class {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes(16);
  }
  async sign(message6) {
    return await hashAndSign(this._key, message6);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(bytes2) {
    return decrypt(this._key, bytes2);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const hash3 = await this.public.hash();
    return toString13(hash3, "base58btc");
  }
  async export(password, format16 = "pkcs-8") {
    if (format16 === "pkcs-8") {
      const buffer2 = new import_forge4.default.util.ByteBuffer(this.marshal());
      const asn1 = import_forge4.default.asn1.fromDer(buffer2);
      const privateKey = import_forge4.default.pki.privateKeyFromAsn1(asn1);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return import_forge4.default.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format16 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format16}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey(bytes2) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes2);
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes2) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes2);
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair(bits2) {
  const keys = await generateKey(bits2);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair2,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});

// node_modules/@noble/ed25519/lib/esm/index.js
var nodeCrypto2 = __toESM(require_crypto());
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE2 = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class {
  constructor(x, y, z, t) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point2)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point2.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p.x, p.y, _1n2, mod3(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch2(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod3(X1 * Z2);
    const X2Z1 = mod3(X2 * Z1);
    const Y1Z2 = mod3(Y1 * Z2);
    const Y2Z1 = mod3(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod3(-this.x), this.y, this.z, mod3(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE2;
    const A = mod3(X1 * X1);
    const B = mod3(Y1 * Y1);
    const C = mod3(_2n2 * mod3(Z1 * Z1));
    const D = mod3(a * A);
    const x1y1 = X1 + Y1;
    const E = mod3(mod3(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod3(E * F);
    const Y3 = mod3(G * H);
    const T3 = mod3(E * H);
    const Z3 = mod3(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod3((Y1 - X1) * (Y2 + X2));
    const B = mod3((Y1 + X1) * (Y2 - X2));
    const F = mod3(B - A);
    if (F === _0n2)
      return this.double();
    const C = mod3(Z1 * _2n2 * T2);
    const D = mod3(T1 * _2n2 * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod3(E * F);
    const Y3 = mod3(G * H);
    const T3 = mod3(E * H);
    const Z3 = mod3(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base30 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base30 = p;
      points.push(base30);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base30 = base30.add(p);
        points.push(base30);
      }
      p = base30.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point2.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p = ExtendedPoint.ZERO;
    let f = ExtendedPoint.BASE;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n2;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
      }
    }
    return ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar2(scalar, CURVE2.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar2(scalar, CURVE2.l, false);
    const G = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n === _0n2)
      return P0;
    if (this.equals(P0) || n === _1n2)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d = this;
    while (n > _0n2) {
      if (n & _1n2)
        p = p.add(d);
      d = d.double();
      n >>= _1n2;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let p = this.multiplyUnsafe(CURVE2.l / _2n2).double();
    if (CURVE2.l % _2n2)
      p = p.add(this);
    return p.equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ) {
    const { x, y, z } = this;
    const is0 = this.equals(ExtendedPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n2 : invert2(z);
    const ax = mod3(x * invZ);
    const ay = mod3(y * invZ);
    const zz = mod3(z * invZ);
    if (is0)
      return Point2.ZERO;
    if (zz !== _1n2)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE2.Gx, CURVE2.Gy, _1n2, mod3(CURVE2.Gx * CURVE2.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n2, _1n2, _1n2, _0n2);
function constTimeNegate2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var RistrettoPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d } = CURVE2;
    const r = mod3(SQRT_M1 * r0 * r0);
    const Ns = mod3((r + _1n2) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod3((c - d * r) * mod3(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod3(s * r0);
    if (!edIsNegative(s_))
      s_ = mod3(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod3(c * (r - _1n2) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod3((s + s) * D);
    const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod3(_1n2 - s2);
    const W3 = mod3(_1n2 + s2);
    return new ExtendedPoint(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes2(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes2(hex, 32);
    const { a, d } = CURVE2;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
      throw new Error(emsg);
    const s2 = mod3(s * s);
    const u1 = mod3(_1n2 + a * s2);
    const u2 = mod3(_1n2 - a * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (edIsNegative(x))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t = mod3(x * y);
    if (!isValid || edIsNegative(t) || y === _0n2)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x, y, _1n2, t));
  }
  toRawBytes() {
    let { x, y, z, t } = this.ep;
    const u1 = mod3(mod3(z + y) * mod3(z - y));
    const u2 = mod3(x * y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod3(y * SQRT_M1);
      let _y = mod3(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y = mod3(-y);
    let s = mod3((z - y) * D);
    if (edIsNegative(s))
      s = mod3(-s);
    return numberTo32BytesLE(s);
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b = other.ep;
    const one = mod3(a.x * b.y) === mod3(a.y * b.x);
    const two = mod3(a.y * b.y) === mod3(a.x * b.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point2 = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d, P } = CURVE2;
    hex = ensureBytes2(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = bytesToNumberLE(normed);
    if (strict && y >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y >= POW_2_2562)
      throw new Error("Expected 0 < hex < 2**256");
    const y2 = mod3(y * y);
    const u = mod3(y2 - _1n2);
    const v = mod3(d * y2 + _1n2);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n2) === _1n2;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod3(-x);
    }
    return new Point2(x, y);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes2 = numberTo32BytesLE(this.y);
    bytes2[31] |= this.x & _1n2 ? 128 : 0;
    return bytes2;
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toX25519() {
    const { y } = this;
    const u = mod3((_1n2 + y) * invert2(_1n2 - y));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point2(mod3(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
Point2.ZERO = new Point2(_0n2, _1n2);
var Signature2 = class {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes2(hex, 64);
    const r = Point2.fromHex(bytes2.slice(0, 32), false);
    const s = bytesToNumberLE(bytes2.slice(32, 64));
    return new Signature2(r, s);
  }
  assertValidity() {
    const { r, s } = this;
    if (!(r instanceof Point2))
      throw new Error("Expected Point instance");
    normalizeScalar2(s, CURVE2.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length23 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length23);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes2 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes2[uint8a[i2]];
  }
  return hex;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length23 = 32;
  const hex = num.toString(16).padStart(length23 * 2, "0");
  return hexToBytes2(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod3(num) & _1n2) === _1n2;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex2(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes2) {
  return mod3(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod3(a, b = CURVE2.P) {
  const res = a % b;
  return res >= _0n2 ? res : b + res;
}
function invert2(number, modulo = CURVE2.P) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod3(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function invertBatch2(nums, p = CURVE2.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    tmp[i2] = acc;
    return mod3(acc * num, p);
  }, _1n2);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    tmp[i2] = mod3(acc * tmp[i2], p);
    return mod3(acc * num, p);
  }, inverted);
  return tmp;
}
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE2;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n2) * b2 % P;
  const b5 = pow22(b4, _1n2) * x % P;
  const b10 = pow22(b5, _5n) * b5 % P;
  const b20 = pow22(b10, _10n) * b10 % P;
  const b40 = pow22(b20, _20n) * b20 % P;
  const b80 = pow22(b40, _40n) * b40 % P;
  const b160 = pow22(b80, _80n) * b80 % P;
  const b240 = pow22(b160, _80n) * b80 % P;
  const b250 = pow22(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n2) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod3(v * v * v);
  const v7 = mod3(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod3(u * v3 * pow);
  const vx2 = mod3(v * x * x);
  const root1 = x;
  const root2 = mod3(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod3(-u);
  const noRoot = vx2 === mod3(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod3(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number) {
  return uvRatio(_1n2, number);
}
function modlLE(hash3) {
  return mod3(bytesToNumberLE(hash3), CURVE2.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function ensureBytes2(hex, expectedLength) {
  const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar2(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n2 < num)
        return num;
    } else {
      if (_0n2 <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar2(key, POW_2_2562)) : ensureBytes2(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point2.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils2.sha512(checkPrivateKey(key)));
}
async function getPublicKey2(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign3(message6, privateKey) {
  message6 = ensureBytes2(message6);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils2.sha512(prefix, message6));
  const R = Point2.BASE.multiply(r);
  const k = modlLE(await utils2.sha512(R.toRawBytes(), pointBytes, message6));
  const s = mod3(r + k * scalar, CURVE2.l);
  return new Signature2(R, s).toRawBytes();
}
function prepareVerification(sig, message6, publicKey) {
  message6 = ensureBytes2(message6);
  if (!(publicKey instanceof Point2))
    publicKey = Point2.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message6 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
}
async function verify2(sig, message6, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message6, publicKey);
  const hashed = await utils2.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
Point2.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto2,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils2 = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  getExtendedPublicKey,
  mod: mod3,
  invert: invert2,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash3) => {
    hash3 = ensureBytes2(hash3);
    if (hash3.length < 40 || hash3.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod3(bytesToNumberLE(hash3), CURVE2.l - _1n2) + _1n2;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes: randomBytes3 } = crypto3.node;
      return new Uint8Array(randomBytes3(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils2.randomBytes(32);
  },
  sha512: async (...messages3) => {
    const message6 = concatBytes2(...messages3);
    if (crypto3.web) {
      const buffer2 = await crypto3.web.subtle.digest("SHA-512", message6.buffer);
      return new Uint8Array(buffer2);
    } else if (crypto3.node) {
      return Uint8Array.from(crypto3.node.createHash("sha512").update(message6).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point.equals(Point2.BASE) ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n2);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils2, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
async function generateKey2() {
  const privateKeyRaw = utils2.randomPrivateKey();
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function generateKeyFromSeed(seed2) {
  if (seed2.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed2 instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed2;
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSign2(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return await sign3(msg, privateKeyRaw);
}
async function hashAndVerify2(publicKey, sig, msg) {
  return await verify2(sig, msg, publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey[i2];
  }
  return privateKey;
}

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var Ed25519PublicKey = class {
  constructor(key) {
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(data, sig) {
    return await hashAndVerify2(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
};
var Ed25519PrivateKey = class {
  constructor(key, publicKey) {
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(message6) {
    return await hashAndSign2(this._key, message6);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const encoding = await identity12.digest(this.public.bytes);
    return base58btc8.encode(encoding.bytes).substring(1);
  }
  async export(password, format16 = "libp2p-key") {
    if (format16 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format16}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey(bytes2) {
  if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes2) {
  bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes2);
}
async function generateKeyPair2() {
  const { privateKey, publicKey } = await generateKey2();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed2) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed2);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length23) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length23) {
    throw new CodeError(`Key must be a Uint8Array of length ${length23}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js
function generateKey3() {
  return utils.randomPrivateKey();
}
async function hashAndSign3(key, msg) {
  const { digest: digest15 } = await sha2566.digest(msg);
  try {
    return await sign2(digest15, key);
  } catch (err2) {
    throw new CodeError(String(err2), "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify3(key, sig, msg) {
  try {
    const { digest: digest15 } = await sha2566.digest(msg);
    return verify(sig, digest15, key);
  } catch (err2) {
    throw new CodeError(String(err2), "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = Point.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    getPublicKey(key, true);
  } catch (err2) {
    throw new CodeError(String(err2), "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    Point.fromHex(key);
  } catch (err2) {
    throw new CodeError(String(err2), "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return getPublicKey(privateKey, true);
  } catch (err2) {
    throw new CodeError(String(err2), "ERR_INVALID_PRIVATE_KEY");
  }
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var Secp256k1PublicKey = class {
  constructor(key) {
    validatePublicKey(key);
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify3(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  async sign(message6) {
    return await hashAndSign3(this._key, message6);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals18(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2566.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const hash3 = await this.public.hash();
    return toString13(hash3, "base58btc");
  }
  async export(password, format16 = "libp2p-key") {
    if (format16 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format16}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey(bytes2) {
  return new Secp256k1PrivateKey(bytes2);
}
function unmarshalSecp256k1PublicKey(bytes2) {
  return new Secp256k1PublicKey(bytes2);
}
async function generateKeyPair3() {
  const privateKeyBytes = await generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var supportedKeys = {
  rsa: rsa_class_exports,
  ed25519: ed25519_class_exports,
  secp256k1: secp256k1_class_exports
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair4(type, bits2) {
  return await typeToKey(type).generateKeyPair(bits2 ?? 2048);
}
async function generateKeyPairFromSeed2(type, seed2, bits2) {
  if (type.toLowerCase() !== "ed25519") {
    throw new CodeError("Seed key derivation is unimplemented for RSA or secp256k1", "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  }
  return await generateKeyPairFromSeed(seed2);
}
function unmarshalPublicKey2(buf2) {
  const decoded = PublicKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPublicKey2(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey3(buf2) {
  const decoded = PrivateKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return await supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer(encryptedKey, password);
    return await unmarshalPrivateKey3(key2);
  } catch (_) {
  }
  const key = import_forge5.default.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw new CodeError("Cannot read the key, most likely the password is wrong or not a RSA key", "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = import_forge5.default.asn1.toDer(import_forge5.default.pki.privateKeyToAsn1(key));
  der = fromString12(der.getBytes(), "ascii");
  return await supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}

// node_modules/ipns/dist/src/index.js
var import_err_code10 = __toESM(require_err_code());

// node_modules/ipns/dist/src/utils.js
var import_err_code9 = __toESM(require_err_code(), 1);

// node_modules/ipns/dist/src/errors.js
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
var ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY";

// node_modules/protons-runtime/dist/src/decode.js
var import_protobufjs = __toESM(require_protobufjs(), 1);
var Reader = import_protobufjs.default.Reader;
var methods2 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
methods2.forEach((method) => {
  const original = Reader.prototype[method];
  Reader.prototype[method] = function() {
    return BigInt(original.call(this).toString());
  };
});
function decodeMessage2(buf2, codec) {
  const reader6 = Reader.create(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(reader6);
}

// node_modules/protons-runtime/dist/src/encode.js
var import_protobufjs2 = __toESM(require_protobufjs(), 1);
var Writer = import_protobufjs2.default.Writer;
var methods3 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
methods3.forEach((method) => {
  const original = Writer.prototype[method];
  Writer.prototype[method] = function(val) {
    return original.call(this, val.toString());
  };
});
function encodeMessage2(message6, codec) {
  const w = Writer.create();
  codec.encode(message6, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES2;
(function(CODEC_TYPES6) {
  CODEC_TYPES6[CODEC_TYPES6["VARINT"] = 0] = "VARINT";
  CODEC_TYPES6[CODEC_TYPES6["BIT64"] = 1] = "BIT64";
  CODEC_TYPES6[CODEC_TYPES6["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES6[CODEC_TYPES6["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES2 || (CODEC_TYPES2 = {}));
function createCodec7(name22, type, encode81, decode97) {
  return {
    name: name22,
    type,
    encode: encode81,
    decode: decode97
  };
}

// node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration2(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode81 = function enumEncode(val, writer5) {
    const enumValue = findValue(val);
    writer5.int32(enumValue);
  };
  const decode97 = function enumDecode(reader6) {
    const val = reader6.uint32();
    return findValue(val);
  };
  return createCodec7("enum", CODEC_TYPES2.VARINT, encode81, decode97);
}

// node_modules/protons-runtime/dist/src/codecs/message.js
function message2(encode81, decode97) {
  return createCodec7("message", CODEC_TYPES2.LENGTH_DELIMITED, encode81, decode97);
}

// node_modules/ipns/dist/src/pb/ipns.js
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration2(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.value != null) {
          writer5.uint32(10);
          writer5.bytes(obj.value);
        }
        if (obj.signature != null) {
          writer5.uint32(18);
          writer5.bytes(obj.signature);
        }
        if (obj.validityType != null) {
          writer5.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, writer5);
        }
        if (obj.validity != null) {
          writer5.uint32(34);
          writer5.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          writer5.uint32(40);
          writer5.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          writer5.uint32(48);
          writer5.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          writer5.uint32(58);
          writer5.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          writer5.uint32(66);
          writer5.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          writer5.uint32(74);
          writer5.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader6.bytes();
              break;
            case 2:
              obj.signature = reader6.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader6);
              break;
            case 4:
              obj.validity = reader6.bytes();
              break;
            case 5:
              obj.sequence = reader6.uint64();
              break;
            case 6:
              obj.ttl = reader6.uint64();
              break;
            case 7:
              obj.pubKey = reader6.bytes();
              break;
            case 8:
              obj.signatureV2 = reader6.bytes();
              break;
            case 9:
              obj.data = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage2(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf2) => {
    return decodeMessage2(buf2, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));

// node_modules/ipns/dist/src/utils.js
init_concat();
var log = logger("ipns:utils");
var IPNS_PREFIX = fromString3("/ipns/");
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute5 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute5, second3, millisecond));
}
var extractPublicKey = async (peerId, entry) => {
  if (entry == null || peerId == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log.error(error);
    throw (0, import_err_code9.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey2(entry.pubKey);
    } catch (err2) {
      log.error(err2);
      throw err2;
    }
    const otherId = await peerIdFromKeys(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw (0, import_err_code9.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.publicKey != null) {
    pubKey = unmarshalPublicKey2(peerId.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw (0, import_err_code9.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
var ipnsEntryDataForV1Sig = (value2, validityType, validity) => {
  const validityTypeBuffer = fromString3(validityType);
  return concat4([value2, validity, validityTypeBuffer]);
};
var ipnsEntryDataForV2Sig = (data) => {
  const entryData = fromString3("ipns-signature:");
  return concat4([entryData, data]);
};
var marshal = (obj) => {
  return IpnsEntry.encode(obj);
};
var unmarshal = (buf2) => {
  const message6 = IpnsEntry.decode(buf2);
  if (message6.sequence != null) {
    message6.sequence = BigInt(message6.sequence);
  }
  if (message6.ttl != null) {
    message6.ttl = BigInt(message6.ttl);
  }
  return {
    value: message6.value ?? new Uint8Array(0),
    signature: message6.signature ?? new Uint8Array(0),
    validityType: message6.validityType ?? IpnsEntry.ValidityType.EOL,
    validity: message6.validity ?? new Uint8Array(0),
    sequence: message6.sequence ?? 0n,
    pubKey: message6.pubKey,
    ttl: message6.ttl ?? void 0,
    signatureV2: message6.signatureV2,
    data: message6.data
  };
};
var peerIdToRoutingKey = (peerId) => {
  return concat4([
    IPNS_PREFIX,
    peerId.toBytes()
  ]);
};
var peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));
};
var createCborData = (value2, validity, validityType, sequence, ttl2) => {
  let ValidityType;
  if (validityType === IpnsEntry.ValidityType.EOL) {
    ValidityType = 0;
  } else {
    throw (0, import_err_code9.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  const data = {
    Value: value2,
    Validity: validity,
    ValidityType,
    Sequence: sequence,
    TTL: ttl2
  };
  return encode5(data);
};
var parseCborData = (buf2) => {
  const data = decode7(buf2);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw (0, import_err_code9.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};

// node_modules/ipns/dist/src/index.js
var log2 = logger("ipns");
var ID_MULTIHASH_CODE = identity.code;
var namespace = "/ipns/";
var namespaceLength = namespace.length;
var create10 = async (peerId, value2, seq, lifetime) => {
  const expirationDate = new import_timestamp_nano.default(Date.now() + Number(lifetime));
  const validityType = IpnsEntry.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split(".");
  const lifetimeNs = BigInt(ms) * BigInt(1e5) + BigInt(ns ?? "0");
  return await _create(peerId, value2, seq, validityType, expirationDate, lifetimeNs);
};
var _create = async (peerId, value2, seq, validityType, expirationDate, ttl2) => {
  seq = BigInt(seq);
  const isoValidity = fromString3(expirationDate.toString());
  if (peerId.privateKey == null) {
    throw (0, import_err_code10.default)(new Error("Missing private key"), ERR_MISSING_PRIVATE_KEY);
  }
  const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
  const signatureV1 = await sign4(privateKey, value2, validityType, isoValidity);
  const data = createCborData(value2, isoValidity, validityType, seq, ttl2);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value: value2,
    signature: signatureV1,
    validityType,
    validity: isoValidity,
    sequence: seq,
    ttl: ttl2,
    signatureV2,
    data
  };
  if (peerId.publicKey != null) {
    const digest15 = decode4(peerId.toBytes());
    if (digest15.code !== ID_MULTIHASH_CODE || !equals15(peerId.publicKey, digest15.digest)) {
      entry.pubKey = peerId.publicKey;
    }
  }
  log2("ipns entry for %b created", value2);
  return entry;
};
var rawStdEncoding = (key) => base32upper2.encode(key).slice(1);
var getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
var sign4 = async (privateKey, value2, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value2, validityType, validity);
    return await privateKey.sign(dataForSignature);
  } catch (error) {
    log2.error("record signature creation failed", error);
    throw (0, import_err_code10.default)(new Error("record signature creation failed"), ERR_SIGNATURE_CREATION);
  }
};

// node_modules/ipfs-core/src/ipns/publisher.js
var log3 = logger("ipfs:ipns:publisher");
var ERR_NOT_FOUND = notFoundError().code;
var defaultRecordLifetime = 60 * 60 * 1e3;
var IpnsPublisher = class {
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  async publishWithEOL(peerId, value2, lifetime, options) {
    const record = await this._updateOrCreateRecord(peerId, value2, lifetime, options);
    return this._putRecordToRouting(record, peerId, options);
  }
  publish(peerId, value2, options) {
    return this.publishWithEOL(peerId, value2, defaultRecordLifetime, options);
  }
  async _putRecordToRouting(record, peerId, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    if (peerId.publicKey == null) {
      throw (0, import_err_code11.default)(new Error("Public key was missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const routingKey = peerIdToRoutingKey(peerId);
    await this._publishEntry(routingKey, record, options);
    return record;
  }
  async _publishEntry(key, entry, options) {
    try {
      const res = await this._routing.put(key, entry, options);
      log3(`ipns record for ${toString11(key, "base32")} was stored in the routing`);
      return res;
    } catch (err2) {
      const errMsg = `ipns record for ${toString11(key, "base32")} could not be stored in the routing - ${err2.stack}`;
      log3.error(errMsg);
      log3.error(err2);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
    }
  }
  async _getPublished(peerId, options = {}) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      return this._unmarshalData(dsVal);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;
        log3.error(errMsg);
        throw (0, import_err_code11.default)(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
      }
      if (!checkRouting) {
        throw (0, import_err_code11.default)(err2, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
      }
      try {
        const routingKey = peerIdToRoutingKey(peerId);
        const res = await this._routing.get(routingKey);
        return this._unmarshalData(res);
      } catch (err3) {
        log3.error(err3);
        throw err3;
      }
    }
  }
  _unmarshalData(data) {
    try {
      return unmarshal(data);
    } catch (err2) {
      throw (0, import_err_code11.default)(err2, "ERR_INVALID_RECORD_DATA");
    }
  }
  async _updateOrCreateRecord(peerId, value2, lifetime, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const getPublishedOptions = {
      checkRouting: true
    };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err2.stack}`;
        log3.error(errMsg);
        throw (0, import_err_code11.default)(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
      }
    }
    let seqNumber = 0n;
    if (record && record.sequence !== void 0) {
      seqNumber = equals15(record.value, value2) ? record.sequence : record.sequence + BigInt(1);
    }
    let entryData;
    try {
      entryData = await create10(peerId, value2, seqNumber, lifetime);
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be created`;
      log3.error(err2);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
    }
    try {
      const data = marshal(entryData);
      await this._datastore.put(getLocalKey(peerId.toBytes()), data, options);
      log3(`ipns record for ${toString11(value2, "base32")} was stored in the datastore`);
      return data;
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be stored in the datastore`;
      log3.error(errMsg);
      throw (0, import_err_code11.default)(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
    }
  }
};
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;

// node_modules/ipfs-core/src/ipns/republisher.js
var import_err_code12 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller2 = __toESM(require_timeout_abort_controller(), 1);
var log4 = logger("ipfs:ipns:republisher");
var minute = 60 * 1e3;
var hour = 60 * minute;
var defaultBroadcastInterval = 4 * hour;
var defaultRecordLifetime2 = 24 * hour;
var IpnsRepublisher = class {
  constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw (0, import_err_code12.default)(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: (period) => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err2) {
            log4.error(err2);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const { pass } = this._options;
    let firstRun = true;
    republishHandle._task = async () => {
      const timeoutController = new import_timeout_abort_controller2.TimeoutController(3e4);
      try {
        await this._republishEntries(this._peerId, pass, {
          signal: timeoutController.signal
        });
      } finally {
        timeoutController.clear();
      }
    };
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw (0, import_err_code12.default)(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(peerId, pass, options) {
    try {
      await this._republishEntry(peerId, options);
    } catch (err2) {
      const errMsg = "cannot republish entry for the node's private key";
      log4.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === "self") {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await importKey(pem, pass);
          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);
          await this._republishEntry(peerIdKey, options);
        }
      } catch (err2) {
        log4.error(err2);
      }
    }
  }
  async _republishEntry(peerId, options) {
    try {
      const value2 = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(peerId, value2, defaultRecordLifetime2, options);
    } catch (err2) {
      if (err2.code === "ERR_NO_ENTRY_FOUND") {
        return;
      }
      throw err2;
    }
  }
  async _getPreviousValue(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code12.default)(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
    }
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      if (!(dsVal instanceof Uint8Array)) {
        throw (0, import_err_code12.default)(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
      }
      try {
        const record = unmarshal(dsVal);
        return record.value;
      } catch (err2) {
        log4.error(err2);
        throw (0, import_err_code12.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
      }
    } catch (err2) {
      if (err2 && err2.notFound) {
        throw (0, import_err_code12.default)(new Error(`no previous entry for record with id: ${peerId.toString()}`), "ERR_NO_ENTRY_FOUND");
      }
      throw err2;
    }
  }
};

// node_modules/ipfs-core/src/ipns/resolver.js
var import_err_code14 = __toESM(require_err_code(), 1);
init_concat();

// node_modules/ipns/dist/src/validator.js
var import_err_code13 = __toESM(require_err_code());
var log5 = logger("ipns:validator");
var validate2 = async (publicKey, entry) => {
  const { value: value2, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 != null && entry.data != null) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    signature = entry.signature ?? new Uint8Array(0);
    dataForSignature = ipnsEntryDataForV1Sig(value2, validityType, validity);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err2) {
    isValid = false;
  }
  if (!isValid) {
    log5.error("record signature verification failed");
    throw (0, import_err_code13.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339(toString11(validity));
    } catch (e) {
      log5.error("unrecognized validity format (not an rfc3339 format)");
      throw (0, import_err_code13.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log5.error("record has expired");
      throw (0, import_err_code13.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType != null) {
    log5.error("unrecognized validity type");
    throw (0, import_err_code13.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log5("ipns entry for %b is valid", value2);
};
var validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw (0, import_err_code13.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals15(data.Value, entry.value)) {
    throw (0, import_err_code13.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals15(data.Validity, entry.validity)) {
    throw (0, import_err_code13.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code13.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code13.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code13.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
var ipnsValidator = async (key, marshalledData) => {
  const peerId = peerIdFromRoutingKey(key);
  const receivedEntry = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId, receivedEntry);
  await validate2(pubKey, receivedEntry);
};

// node_modules/ipfs-core/src/ipns/resolver.js
var log6 = logger("ipfs:ipns:resolver");
var ERR_NOT_FOUND2 = notFoundError().code;
var defaultMaximumRecursiveDepth = 32;
var IpnsResolver = class {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name22, options = {}) {
    if (typeof name22 !== "string") {
      throw (0, import_err_code14.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const recursive2 = options.recursive && options.recursive.toString() === "true";
    const nameSegments = name22.split("/");
    if (nameSegments.length !== 3 || nameSegments[0] !== "") {
      throw (0, import_err_code14.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive2) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth, options);
    log6(`${name22} was locally resolved correctly`);
    return res;
  }
  async resolver(name22, depth, options) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
      log6.error(errMsg);
      throw (0, import_err_code14.default)(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
    }
    const res = await this._resolveName(name22, options);
    const nameSegments = res.split("/");
    if (nameSegments[1] === "ipfs" || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1, options);
  }
  async _resolveName(name22, options) {
    const peerId = peerIdFromString(name22);
    const routingKey = peerIdToRoutingKey(peerId);
    let record;
    try {
      record = await this._routing.get(routingKey, options);
    } catch (err2) {
      log6.error("could not get record from routing", err2);
      if (err2.code === ERR_NOT_FOUND2) {
        throw (0, import_err_code14.default)(new Error(`record requested for ${name22} was not found in the network`), "ERR_NO_RECORD_FOUND");
      }
      throw (0, import_err_code14.default)(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
    }
    return this._validateRecord(peerId, record);
  }
  async _validateRecord(peerId, record) {
    await ipnsValidator(concat4([
      fromString3("/ipns/"),
      peerId.toBytes()
    ]), record);
    const ipnsEntry = unmarshal(record);
    return toString11(ipnsEntry.value);
  }
};

// node_modules/ipfs-core/src/utils/tlru.js
var import_hashlru2 = __toESM(require_hashlru(), 1);
var TLRU2 = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru2.default)(maxSize);
  }
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// node_modules/ipfs-core/src/ipns/index.js
var log7 = logger("ipfs:ipns");
var defaultRecordTtl = 60 * 1e3;
var IPNS = class {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU2(1e3);
    this.routing = routing;
  }
  async publish(peerId, value2, lifetime = IpnsPublisher.defaultRecordLifetime, options) {
    try {
      await this.publisher.publishWithEOL(peerId, value2, lifetime, options);
      log7(`IPNS value ${toString11(value2, "base32")} was published correctly`);
      const id = peerId.toString();
      const ttEol = parseFloat(lifetime);
      const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value2, ttl2);
      log7(`IPNS value ${toString11(value2, "base32")} was cached correctly`);
      return {
        name: id,
        value: value2
      };
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  async resolve(name22, options = {}) {
    if (typeof name22 !== "string") {
      throw (0, import_err_code15.default)(new Error("name received is not valid"), "ERR_INVALID_NAME");
    }
    if (!options.nocache && !options.recursive) {
      const id = name22.split("/")[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name22, options);
      log7(`IPNS record from ${name22} was resolved correctly`);
      return result;
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  async initializeKeyspace(peerId, value2, options) {
    return this.publish(peerId, value2, IpnsPublisher.defaultRecordLifetime, options);
  }
};

// node_modules/datastore-core/node_modules/it-all/dist/src/index.js
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/datastore-core/src/utils.js
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await all(iterable);
    yield* values.sort(sorter);
  }();
};

// node_modules/datastore-core/node_modules/it-drain/dist/src/index.js
async function drain(source) {
  for await (const _ of source) {
  }
}

// node_modules/datastore-core/node_modules/it-filter/dist/src/index.js
async function* filter(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/datastore-core/node_modules/it-take/dist/src/index.js
async function* take(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}

// node_modules/datastore-core/src/base.js
var BaseDatastore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value: value2 } of source) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options));
        puts = [];
        await drain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = filter(
        it,
        (e) => e.key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = filter(
        it,
        (key) => key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
};

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last14 = this.buffer[this.btm];
    if (last14 === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last14;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev2 = this.head;
      this.head = prev2.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
function pushable(options = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function pushableV(options = {}) {
  const getNext = (buffer2) => {
    let next;
    const values = [];
    while (!buffer2.isEmpty()) {
      next = buffer2.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer2.isEmpty()) {
      return getNext(buffer2);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve7, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer2.push(next);
        try {
          resolve7(getNext(buffer2));
        } catch (err2) {
          reject(err2);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err2) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err2 });
    }
    buffer2.push({ error: err2 });
    return pushable2;
  };
  const push = (value2) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value2?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end = (err2) => {
    if (ended)
      return pushable2;
    ended = true;
    return err2 != null ? bufferError(err2) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err2) => {
    end(err2);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer2.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err2) {
      _pushable2.throw(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err2) {
      _pushable2.end(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}

// node_modules/datastore-core/src/tiered.js
var log8 = logger("datastore:core:tiered");
var TieredDatastore = class extends BaseDatastore {
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map((store) => store.open()));
    } catch (err2) {
      throw dbOpenFailedError(err2);
    }
  }
  async put(key, value2, options) {
    try {
      await Promise.all(this.stores.map((store) => store.put(key, value2, options)));
    } catch (err2) {
      throw dbWriteFailedError(err2);
    }
  }
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err2) {
        log8.error(err2);
      }
    }
    throw notFoundError();
  }
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map((store) => store.delete(key, options)));
    } catch (err2) {
      throw dbDeleteFailedError(err2);
    }
  }
  async *putMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      drain(store.putMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const pair2 of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(pair2));
        yield pair2;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async *deleteMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      drain(store.deleteMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const key of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map((store) => store.close()));
  }
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value2) => {
        batches.forEach((b) => b.put(key, value2));
      },
      delete: (key) => {
        batches.forEach((b) => b.delete(key));
      },
      commit: async (options) => {
        for (const batch3 of batches) {
          await batch3.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
};

// node_modules/dlv/dist/dlv.es.js
function dlv_es_default(t, e, l, n, r) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
    t = t ? t[e[n]] : r;
  return t === r ? l : t;
}

// node_modules/ipns/dist/src/selector.js
var ipnsSelector = (key, data) => {
  const entries = data.map((buf2, index) => ({
    entry: IpnsEntry.decode(buf2),
    index
  }));
  entries.sort((a, b) => {
    if (a.entry.signatureV2 != null && b.entry.signatureV2 == null) {
      return -1;
    } else if (a.entry.signatureV2 == null && b.entry.signatureV2 != null) {
      return 1;
    }
    const aSeq = a.entry.sequence ?? 0n;
    const bSeq = b.entry.sequence ?? 0n;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    const aValidty = a.entry.validity ?? new Uint8Array(0);
    const bValidty = b.entry.validity ?? new Uint8Array(0);
    const entryAValidityDate = parseRFC3339(toString11(aValidty));
    const entryBValidityDate = parseRFC3339(toString11(bValidty));
    if (entryAValidityDate.getTime() > entryBValidityDate.getTime()) {
      return -1;
    }
    if (entryAValidityDate.getTime() < entryBValidityDate.getTime()) {
      return 1;
    }
    return 0;
  });
  return entries[0].index;
};

// node_modules/datastore-core/src/shard.js
var SHARDING_FN = "SHARDING";
var README_FN = "_README";

// node_modules/datastore-core/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError();
    return this.data[key.toString()];
  }
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value2]) => ({ key: new Key(key), value: value2 }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
};

// node_modules/it-pipe/node_modules/it-merge/dist/src/index.js
async function* merge(...sources) {
  const output = pushable({
    objectMode: true
  });
  void Promise.resolve().then(async () => {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          output.push(item);
        }
      }));
      output.end();
    } catch (err2) {
      output.end(err2);
    }
  });
  yield* output;
}

// node_modules/it-pipe/dist/src/index.js
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isIterable = (obj) => {
  return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
};
var isDuplex = (obj) => {
  return obj != null && typeof obj.sink === "function" && isIterable(obj.source);
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err2) => {
        stream.end(err2);
      });
      const sourceWrap = async function* () {
        yield* duplex.source;
        stream.end();
      };
      return merge(stream, sourceWrap());
    }
    return duplex.source;
  };
};
function pipe(first10, ...rest) {
  if (isDuplex(first10)) {
    const duplex = first10;
    first10 = () => duplex.source;
  } else if (isIterable(first10)) {
    const source = first10;
    first10 = () => source;
  }
  const fns = [first10, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}

// node_modules/datastore-core/src/sharding.js
var shardKey = new Key(SHARDING_FN);
var shardReadmeKey = new Key(README_FN);

// node_modules/datastore-pubsub/src/utils.js
var import_err_code16 = __toESM(require_err_code(), 1);
var namespace2 = "/record/";
function encodeBase32(buf2) {
  return toString11(buf2, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString3(key.toString());
  }
  const b64url = toString11(key, "base64url");
  return `${namespace2}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace2.length) !== namespace2) {
    throw (0, import_err_code16.default)(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace2.length);
  return fromString3(key, "base64url");
}

// node_modules/datastore-pubsub/src/index.js
var import_err_code17 = __toESM(require_err_code());
var log9 = logger("datastore-pubsub:publisher");
var PubSubDatastore = class extends BaseDatastore {
  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {
    super();
    if (!validator) {
      throw (0, import_err_code17.default)(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator !== "function") {
      throw (0, import_err_code17.default)(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof selector !== "function") {
      throw (0, import_err_code17.default)(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
      throw (0, import_err_code17.default)(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator;
    this._selector = selector;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
    this._pubsub.addEventListener("message", this._onMessage);
  }
  async put(key, val, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = "received value is not a Uint8Array";
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
    }
    const stringifiedTopic = keyToTopic(key);
    log9(`publish value for topic ${stringifiedTopic}`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key, options);
    }
    try {
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err2) {
      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
    }
    log9(`subscribed values for key ${stringifiedTopic}`);
    return this._getLocal(key);
  }
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  async _getLocal(key, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey, options);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
        log9.error(errMsg2);
        throw (0, import_err_code17.default)(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      const errMsg = `local record requested was not found for ${routingKey.toString()}`;
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_NOT_FOUND");
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = "found record that we couldn't convert to a value";
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
    }
    return dsVal;
  }
  async _onMessage(evt) {
    const msg = evt.detail;
    if (msg.type !== "signed") {
      log9.error("unsigned message received, this module can only work with signed messages");
      return;
    }
    const { data, from: from33, topic } = msg;
    let key;
    try {
      key = topicToKey(topic);
    } catch (err2) {
      log9.error(err2);
      return;
    }
    log9(`message received for topic ${topic}`);
    if (this._peerId.equals(from33)) {
      log9("message discarded as it is from the same peer");
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err2) {
        log9.error("message discarded by the subscriptionKeyFn");
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err2) {
      log9.error(err2);
    }
  }
  async _storeIfSubscriptionIsBetter(key, data, options) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_VALID_RECORD") {
        throw err2;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data, options);
    }
  }
  async _validateRecord(key, value2) {
    return this._validator(key, value2);
  }
  async _selectRecord(key, records) {
    const res = await this._selector(key, records);
    return res === 0;
  }
  async _isBetter(key, val) {
    try {
      await this._validateRecord(key, val);
    } catch (err2) {
      const errMsg = "record received through pubsub is not valid";
      log9.error(errMsg);
      throw (0, import_err_code17.default)(new Error(errMsg), "ERR_NOT_VALID_RECORD");
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err2) {
      return true;
    }
    if (equals15(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [currentRecord, val]);
  }
  async _storeRecord(key, data, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    await this._datastore.put(routingKey, data, options);
    log9(`record for ${keyToTopic(key)} was stored in the datastore`);
  }
};

// node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js
var import_err_code18 = __toESM(require_err_code(), 1);
var log10 = logger("ipfs:ipns:pubsub");
var IpnsPubsubDatastore = class {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);
  }
  async put(key, value2, options) {
    try {
      await this._pubsubDs.put(key, value2, options);
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    let res;
    let err2;
    try {
      res = await this._pubsubDs.get(key, options);
    } catch (e) {
      err2 = e;
    }
    const ns = key.slice(0, namespaceLength);
    if (toString11(ns) === namespace) {
      const stringifiedTopic = base58btc2.encode(key).substring(1);
      const id = base58btc2.encode(key.slice(namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log10(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
    }
    if (err2) {
      throw err2;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString11(key, "base58btc");
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw (0, import_err_code18.default)(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
    }
    try {
      const k = peerIdToRoutingKey(peerIdFromString(subscriber));
      return k;
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map((sub) => `${namespace}${sub}`);
  }
  async cancel(name22) {
    if (typeof name22 !== "string") {
      throw (0, import_err_code18.default)(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
    }
    if (name22.startsWith(namespace)) {
      name22 = name22.substring(namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name22);
    if (!stringifiedTopic) {
      return {
        canceled: false
      };
    }
    const bufTopic = fromString3(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log10(`unsubscribed pubsub ${stringifiedTopic}: ${name22}`);
    return {
      canceled: true
    };
  }
};

// node_modules/@libp2p/record/node_modules/protons-runtime/dist/src/utils.js
var import_reader2 = __toESM(require_reader(), 1);
var import_reader_buffer2 = __toESM(require_reader_buffer(), 1);
var import_writer2 = __toESM(require_writer(), 1);
var import_writer_buffer2 = __toESM(require_writer_buffer(), 1);
var import_minimal3 = __toESM(require_minimal(), 1);
function configure2() {
  import_minimal3.default._configure();
  import_reader2.default._configure(import_reader_buffer2.default);
  import_writer2.default._configure(import_writer_buffer2.default);
}
configure2();
var methods4 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader2(obj) {
  for (const method of methods4) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader2(buf2) {
  return patchReader2(new import_reader2.default(buf2));
}
function patchWriter2(obj) {
  for (const method of methods4) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer2() {
  return patchWriter2(import_writer2.default.create());
}

// node_modules/@libp2p/record/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage3(buf2, codec) {
  const r = reader2(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/record/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage3(message6, codec) {
  const w = writer2();
  codec.encode(message6, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/record/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES3;
(function(CODEC_TYPES6) {
  CODEC_TYPES6[CODEC_TYPES6["VARINT"] = 0] = "VARINT";
  CODEC_TYPES6[CODEC_TYPES6["BIT64"] = 1] = "BIT64";
  CODEC_TYPES6[CODEC_TYPES6["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES6[CODEC_TYPES6["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES3 || (CODEC_TYPES3 = {}));
function createCodec8(name22, type, encode81, decode97) {
  return {
    name: name22,
    type,
    encode: encode81,
    decode: decode97
  };
}

// node_modules/@libp2p/record/node_modules/protons-runtime/dist/src/codecs/message.js
function message3(encode81, decode97) {
  return createCodec8("message", CODEC_TYPES3.LENGTH_DELIMITED, encode81, decode97);
}

// node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.writeDefaults === true || obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          key: new Uint8Array(0),
          value: new Uint8Array(0),
          timeReceived: ""
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader6.bytes();
              break;
            case 2:
              obj.value = reader6.bytes();
              break;
            case 5:
              obj.timeReceived = reader6.string();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage3(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage3(buf2, Record3.codec());
  };
})(Record || (Record = {}));

// node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour3 = String(time.getUTCHours()).padStart(2, "0");
  const minute5 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour3}:${minute5}:${seconds}.${nanoseconds}Z`;
}
function parseRFC33392(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute5 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute5, second3, millisecond));
}

// node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class {
  constructor(key, value2, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value2;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  static fromDeserialized(obj) {
    const recvtime = parseRFC33392(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};

// node_modules/ipfs-core/src/ipns/routing/offline-datastore.js
var import_err_code19 = __toESM(require_err_code(), 1);
var log11 = logger("ipfs:ipns:offline-datastore");
var OfflineDatastore = class {
  constructor(datastore) {
    this._datastore = datastore;
    this.stores = [];
  }
  async put(key, value2, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code19.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw (0, import_err_code19.default)(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code19.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const record = new Libp2pRecord(key, value2, new Date());
    await this._datastore.put(routingKey, record.serialize(), options);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code19.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code19.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const res = await this._datastore.get(routingKey, options);
    let record;
    try {
      record = Libp2pRecord.deserialize(res);
    } catch (err2) {
      log11.error(err2);
      throw err2;
    }
    return record.value;
  }
  _routingKey(key) {
    return new Key("/dht/record/" + toString11(key, "base32"), false);
  }
};

// node_modules/ipfs-core/src/ipns/routing/dht-datastore.js
var import_it_drain3 = __toESM(require_it_drain(), 1);
var log12 = logger("ipfs:ipns:dht-datastore");
var DHTDatastore = class {
  constructor(dht) {
    this._dht = dht;
  }
  async put(key, value2, options) {
    try {
      await (0, import_it_drain3.default)(this._dht.put(key, value2, options));
    } catch (err2) {
      log12.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    for await (const event of this._dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw notFoundError();
  }
};

// node_modules/ipfs-core/src/ipns/routing/config.js
function createRouting({ libp2p, repo, peerId, options }) {
  const ipnsStores = [];
  let pubsubDs;
  if (dlv_es_default(options, "EXPERIMENTAL.ipnsPubsub", false)) {
    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId);
    ipnsStores.push(pubsubDs);
  }
  if (dlv_es_default(options, "offline", false) !== true && ["dht", "dhtclient", "dhtserver"].includes(dlv_es_default(options, "config.Routing.Type", "none"))) {
    ipnsStores.push(new DHTDatastore(libp2p.dht));
  }
  if (dlv_es_default(options, "offline", false) || ipnsStores.length === 0) {
    const offlineDatastore = new OfflineDatastore(repo.datastore);
    ipnsStores.push(offlineDatastore);
  }
  return new TieredDatastore(ipnsStores);
}

// node_modules/ipfs-core/src/components/ipns.js
var log13 = logger("ipfs:components:ipns");
var IPNSAPI = class {
  constructor(options = { pass: "" }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  startOffline({ repo, peerId, keychain }) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log13("initializing IPNS keyspace (offline)");
    const routing = new OfflineDatastore(repo.datastore);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  async startOnline({ libp2p, repo, peerId, keychain }) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({ libp2p, repo, peerId, options: this.options });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  publish(peerId, value2, lifetime, options) {
    return this.getIPNS().publish(peerId, value2, lifetime, options);
  }
  resolve(name22, options) {
    return this.getIPNS().resolve(name22, options);
  }
  initializeKeyspace(peerId, value2, options) {
    return this.getIPNS().initializeKeyspace(peerId, value2, options);
  }
};

// node_modules/ipfs-core/src/components/name/publish.js
var import_err_code20 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/src/components/name/utils.js
var import_it_drain4 = __toESM(require_it_drain(), 1);
async function resolvePath2({ ipns, repo, codecs: codecs2 }, name22, options) {
  if (ipnsPath(name22)) {
    return ipns.resolve(name22);
  }
  const {
    cid,
    path: path2
  } = toCidAndPath(name22);
  await (0, import_it_drain4.default)(resolve(cid, path2 || "", codecs2, repo, options));
}

// node_modules/ipfs-core/src/components/name/publish.js
var log14 = logger("ipfs:name:publish");
function createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain }) {
  const lookupKey = async (keyName) => {
    let privateKey;
    if (keyName === "self" && peerId.privateKey != null) {
      privateKey = await unmarshalPrivateKey3(peerId.privateKey);
    } else {
      try {
        const pem = await keychain.exportKey(keyName, "temp");
        privateKey = await importKey(pem, "temp");
      } catch (err2) {
        log14.error(err2);
        throw (0, import_err_code20.default)(err2, "ERR_CANNOT_GET_KEY");
      }
    }
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  };
  async function publish(value2, options = {}) {
    const resolve7 = !(options.resolve === false);
    const lifetime = options.lifetime || "24h";
    const key = options.key || "self";
    if (!isOnline()) {
      throw (0, import_err_code20.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    try {
      value2 = normalizePath(value2);
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parse_duration_default(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve7 ? resolvePath2({ ipns, repo, codecs: codecs2 }, value2) : Promise.resolve()
    ]);
    const bytes2 = fromString3(value2);
    const result = await ipns.publish(results[0], bytes2, pubLifetime, options);
    return {
      name: result.name,
      value: toString11(result.value)
    };
  }
  return withTimeoutOption(publish);
}

// node_modules/ipfs-core/src/components/name/resolve.js
var import_err_code21 = __toESM(require_err_code(), 1);
var import_is_domain_name = __toESM(require_is_domain_name(), 1);
var mergeOptions2 = merge_options_default.bind({ ignoreUndefined: true });
var log15 = logger("ipfs:name:resolve");
var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
function createResolve2({ dns, ipns, isOnline, options: { offline } }) {
  async function* resolve7(name22, options = {}) {
    options = mergeOptions2({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw (0, import_err_code21.default)(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
    }
    if (!isOnline() && !offline) {
      throw (0, import_err_code21.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    let ipnsName = name22.toString();
    if (!ipnsName.startsWith("/ipns/")) {
      ipnsName = `/ipns/${ipnsName}`;
    }
    let [namespace3, hash3, ...remainder] = ipnsName.slice(1).split("/");
    try {
      if (hash3.substring(0, 1) === "1") {
        const id = peerIdFromString(hash3);
        const digest15 = decode4(id.toBytes());
        const libp2pKey = CID.createV1(114, digest15);
        hash3 = libp2pKey.toString(base36);
      } else {
        const cid = CID.parse(hash3);
        if (cid.version === 1) {
          hash3 = cid.toString(base36);
        }
      }
    } catch (err2) {
      if ((0, import_is_domain_name.default)(hash3)) {
        yield appendRemainder(await dns(hash3, options), remainder);
        return;
      }
      log15.error(err2);
      throw (0, import_err_code21.default)(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
    }
    const value2 = await ipns.resolve(`/${namespace3}/${hash3}`, options);
    yield appendRemainder(value2 instanceof Uint8Array ? toString11(value2) : value2, remainder);
  }
  return withTimeoutOption(resolve7);
}

// node_modules/ipfs-core/src/components/name/pubsub/utils.js
var import_err_code22 = __toESM(require_err_code(), 1);
function getPubsubRouting(ipns, options) {
  if (!ipns || !(options && options.ipnsPubsub)) {
    throw (0, import_err_code22.default)(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
  }
  if (ipns.routing instanceof IpnsPubsubDatastore) {
    return ipns.routing;
  }
  const pubsub = (ipns.routing.stores || []).find((s) => s instanceof IpnsPubsubDatastore);
  if (!pubsub) {
    throw (0, import_err_code22.default)(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
  }
  return pubsub;
}

// node_modules/ipfs-core/src/components/name/pubsub/cancel.js
function createCancel({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function cancel(name22, options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.cancel(name22, options2);
  }
  return withTimeoutOption(cancel);
}

// node_modules/ipfs-core/src/components/name/pubsub/state.js
function createState({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function state(_options = {}) {
    try {
      return { enabled: Boolean(getPubsubRouting(ipns, experimental)) };
    } catch (err2) {
      return { enabled: false };
    }
  }
  return withTimeoutOption(state);
}

// node_modules/ipfs-core/src/components/name/pubsub/subs.js
function createSubs({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function subs(options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.getSubscriptions(options2);
  }
  return withTimeoutOption(subs);
}

// node_modules/ipfs-core/src/components/name/pubsub/index.js
var PubSubAPI = class {
  constructor({ ipns, options }) {
    this.cancel = createCancel({ ipns, options });
    this.state = createState({ ipns, options });
    this.subs = createSubs({ ipns, options });
  }
};

// node_modules/ipfs-core/src/components/name/index.js
var NameAPI = class {
  constructor({ dns, ipns, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
    this.publish = createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain });
    this.resolve = createResolve2({ dns, ipns, isOnline, options });
    this.pubsub = new PubSubAPI({ ipns, options });
  }
};

// node_modules/ipfs-core/src/components/refs/index.js
var import_timeout_abort_controller3 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var ERR_NOT_FOUND3 = notFoundError().code;
var Format = {
  default: "<dst>",
  edges: "<src> -> <dst>"
};
function createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }) {
  async function* refs(ipfsPath3, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error("Cannot set edges to true and also specify format");
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== "number") {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new import_timeout_abort_controller3.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = (0, import_any_signal2.anySignal)(signals);
    }
    const rawPaths = Array.isArray(ipfsPath3) ? ipfsPath3 : [ipfsPath3];
    const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
    for (const path2 of paths) {
      try {
        yield* refsStream(resolve7, repo, codecs2, path2, options);
      } catch (err2) {
        yield {
          ref: "",
          err: err2.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload2, ipfsPath3, options) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath3);
  if (options.preload !== false) {
    preload2(cid);
  }
  return `/ipfs/${cid}${path2 || ""}`;
}
async function* refsStream(resolve7, repo, codecs2, path2, options) {
  const resPath = await resolve7(path2, options);
  const {
    cid
  } = toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs2, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield {
      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)
    };
  }
}
function formatLink(srcCid, dstCid, linkName = "", format16 = Format.default) {
  let out = format16.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
  const seen = /* @__PURE__ */ new Set();
  async function* traverseLevel(parent2, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
        yield {
          parent: parent2,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND3) {
        err2.message = `Could not find object with CID: ${parent2.cid}`;
      }
      throw err2;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs2, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs2.getCodec(cid.code);
  const value2 = codec.decode(block);
  const isDagPb = cid.code === code;
  const base30 = [];
  for (const [name22, cid2] of links(value2, base30)) {
    if (isDagPb) {
      const match = name22.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index = Number(match[1]);
        if (index < value2.Links.length) {
          yield {
            name: value2.Links[index].Name,
            cid: cid2
          };
          continue;
        }
      }
    }
    yield {
      name: name22,
      cid: cid2
    };
  }
}
var links = function* (source, base30) {
  if (source == null) {
    return;
  }
  if (source instanceof Uint8Array) {
    return;
  }
  for (const [key, value2] of Object.entries(source)) {
    const path2 = [...base30, key];
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (const [index, element] of value2.entries()) {
          const elementPath = [...path2, index];
          const cid = CID.asCID(element);
          if (cid) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value2);
        if (cid) {
          yield [path2.join("/"), cid];
        } else {
          yield* links(value2, path2);
        }
      }
    }
  }
  return [];
};

// node_modules/ipfs-core/src/components/refs/local.js
function createLocal({ repo }) {
  async function* refsLocal(options = {}) {
    for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
      yield { ref: cid.toString() };
    }
  }
  return withTimeoutOption(refsLocal);
}

// node_modules/ipfs-core/src/components/bitswap/wantlist.js
function createWantlist({ network }) {
  async function wantlist(options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.getWantlist();
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlist);
}

// node_modules/ipfs-core/src/components/bitswap/wantlist-for-peer.js
function createWantlistForPeer({ network }) {
  async function wantlistForPeer(peerId, options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.wantlistForPeer(peerId);
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlistForPeer);
}

// node_modules/ipfs-core/src/components/bitswap/unwant.js
function createUnwant({ network }) {
  async function unwant(cids, options = {}) {
    const { bitswap } = await network.use(options);
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    return bitswap.unwant(cids);
  }
  return withTimeoutOption(unwant);
}

// node_modules/ipfs-core/src/components/bitswap/stat.js
function createStat({ network }) {
  async function stat(options = {}) {
    const bitswap = (await network.use(options)).bitswap;
    const snapshot = bitswap.stat().snapshot;
    return {
      provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
      blocksReceived: BigInt(snapshot.blocksReceived.toString()),
      wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
      peers: bitswap.peers(),
      dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
      dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
      dataReceived: BigInt(snapshot.dataReceived.toString()),
      blocksSent: BigInt(snapshot.blocksSent.toString()),
      dataSent: BigInt(snapshot.dataSent.toString())
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/src/components/bitswap/index.js
var BitswapAPI = class {
  constructor({ network }) {
    this.wantlist = createWantlist({ network });
    this.wantlistForPeer = createWantlistForPeer({ network });
    this.unwant = createUnwant({ network });
    this.stat = createStat({ network });
  }
};

// node_modules/ipfs-core/src/components/bootstrap/utils.js
function isValidMultiaddr(ma) {
  try {
    return IPFS.matches(ma);
  } catch (err2) {
    return false;
  }
}

// node_modules/ipfs-core/src/components/bootstrap/add.js
function createAdd2({ repo }) {
  async function add(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    const boostrappers = config2.Bootstrap || [];
    boostrappers.push(multiaddr2.toString());
    config2.Bootstrap = Array.from(
      new Set(boostrappers)
    ).sort((a, b) => a.localeCompare(b));
    await repo.config.replace(config2);
    return {
      Peers: [multiaddr2]
    };
  }
  return withTimeoutOption(add);
}

// node_modules/ipfs-core/src/components/bootstrap/clear.js
function createClear({ repo }) {
  async function clear(options = {}) {
    const config2 = await repo.config.getAll(options);
    const removed = config2.Bootstrap || [];
    config2.Bootstrap = [];
    await repo.config.replace(config2);
    return { Peers: removed.map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(clear);
}

// node_modules/ipfs-core/src/components/bootstrap/list.js
function createList({ repo }) {
  async function list(options = {}) {
    const peers = await repo.config.get("Bootstrap", options);
    return { Peers: (peers || []).map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(list);
}

// node_modules/ipfs-core-config/src/config.browser.js
var config_browser_default = () => ({
  Addresses: {
    Swarm: [],
    Announce: [],
    NoAnnounce: [],
    API: "",
    Gateway: "",
    RPC: "",
    Delegates: [
      "/dns4/node0.delegate.ipfs.io/tcp/443/https",
      "/dns4/node1.delegate.ipfs.io/tcp/443/https",
      "/dns4/node2.delegate.ipfs.io/tcp/443/https",
      "/dns4/node3.delegate.ipfs.io/tcp/443/https"
    ]
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: {
      Enabled: true
    }
  },
  Bootstrap: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
    "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
    "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
    "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
  ],
  Pubsub: {
    Enabled: true
  },
  Swarm: {
    ConnMgr: {
      LowWater: 5,
      HighWater: 20
    },
    DisableNatPortMap: true
  },
  Routing: {
    Type: "dhtclient"
  }
});

// node_modules/ipfs-core/src/components/bootstrap/reset.js
function createReset({ repo }) {
  async function reset(options = {}) {
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = config_browser_default().Bootstrap;
    await repo.config.replace(config2);
    return {
      Peers: config_browser_default().Bootstrap.map((ma) => multiaddr(ma))
    };
  }
  return withTimeoutOption(reset);
}

// node_modules/ipfs-core/src/components/bootstrap/rm.js
function createRm2({ repo }) {
  async function rm(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr2.toString());
    await repo.config.replace(config2);
    return { Peers: [multiaddr2] };
  }
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/src/components/bootstrap/index.js
var BootstrapAPI = class {
  constructor({ repo }) {
    this.add = createAdd2({ repo });
    this.list = createList({ repo });
    this.rm = createRm2({ repo });
    this.clear = createClear({ repo });
    this.reset = createReset({ repo });
  }
};

// node_modules/ipfs-core/src/components/block/get.js
function createGet({ preload: preload2, repo }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    return repo.blocks.get(cid, options);
  }
  return withTimeoutOption(get3);
}

// node_modules/ipfs-core/src/components/block/put.js
function createPut({ codecs: codecs2, hashers, repo, preload: preload2 }) {
  async function put(block, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const cidVersion = options.version != null ? options.version : 0;
      const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
      const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
      const hash3 = await hasher.digest(block);
      const codec = await codecs2.getCodec(codecName);
      const cid = CID.create(cidVersion, codec.code, hash3);
      await repo.blocks.put(cid, block, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin === true) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/src/components/block/rm.js
var import_err_code23 = __toESM(require_err_code(), 1);
var import_it_parallel = __toESM(require_it_parallel(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
var import_it_filter3 = __toESM(require_it_filter(), 1);

// node_modules/ipfs-core/src/components/block/utils.js
function cleanCid(cid) {
  if (cid instanceof Uint8Array) {
    return CID.decode(cid);
  }
  return CID.parse(cid.toString());
}

// node_modules/ipfs-core/src/components/block/rm.js
var BLOCK_RM_CONCURRENCY = 8;
function createRm3({ repo }) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* pipe(
        cids,
        (source) => (0, import_it_map2.default)(source, (cid) => {
          return async () => {
            cid = cleanCid(cid);
            const result = { cid };
            try {
              const has = await repo.blocks.has(cid);
              if (!has) {
                throw (0, import_err_code23.default)(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
              }
              await repo.blocks.delete(cid);
            } catch (err2) {
              if (!options.force) {
                err2.message = `cannot remove ${cid}: ${err2.message}`;
                result.error = err2;
              }
            }
            return result;
          };
        }),
        (source) => (0, import_it_parallel.default)(source, { concurrency: BLOCK_RM_CONCURRENCY }),
        (source) => (0, import_it_filter3.default)(source, () => !options.quiet)
      );
    } finally {
      release();
    }
  }
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/src/components/block/stat.js
function createStat2({ repo, preload: preload2 }) {
  async function stat(cid, options = {}) {
    cid = cleanCid(cid);
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid);
    return { cid, size: block.length };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/src/components/block/index.js
var BlockAPI = class {
  constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
    this.get = createGet({ preload: preload2, repo });
    this.put = createPut({ codecs: codecs2, hashers, preload: preload2, repo });
    this.rm = createRm3({ repo });
    this.stat = createStat2({ preload: preload2, repo });
  }
};

// node_modules/ipfs-core/src/components/add.js
var import_it_last3 = __toESM(require_it_last(), 1);

// node_modules/ipfs-core-utils/src/files/normalise-content.js
var import_err_code24 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
var import_blob_to_it = __toESM(require_blob_to_it(), 1);
var import_it_peekable = __toESM(require_it_peekable(), 1);
var import_it_all2 = __toESM(require_it_all(), 1);
var import_it_map3 = __toESM(require_it_map(), 1);

// node_modules/ipfs-core-utils/src/files/utils.js
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value2) => value2 && typeof value2.getReader === "function";

// node_modules/ipfs-core-utils/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes(input)) {
    return toAsyncIterable(toBytes2(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes2(input.toString()));
  }
  if (isBlob(input)) {
    return (0, import_blob_to_it.default)(input);
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable.default)(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return toAsyncIterable(Uint8Array.from(await (0, import_it_all2.default)(peekable)));
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return (0, import_it_map3.default)(peekable, toBytes2);
    }
  }
  throw (0, import_err_code24.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes2(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}

// node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js
var import_err_code25 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable2 = __toESM(require_it_peekable(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code25.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input) || isBlob(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it2.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable2.default)(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2) || isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      yield toFileObject(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code25.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code25.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path2) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/src/files/normalise-input-single.js
function normaliseInput2(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}

// node_modules/ipfs-core/src/components/add.js
function createAdd3({ addAll }) {
  async function add(entry, options = {}) {
    const result = await (0, import_it_last3.default)(addAll(normaliseInput2(entry), options));
    if (result == null) {
      throw Error("Failed to add a file, if you see this please report a bug");
    }
    return result;
  }
  return add;
}

// node_modules/ipfs-unixfs-importer/src/index.js
var import_it_parallel_batch2 = __toESM(require_it_parallel_batch());

// node_modules/@multiformats/murmur3/esm/index.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited());
function fromNumberTo32BitBuf(number) {
  const bytes2 = new Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes2[i2] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
var murmur332 = from3({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from3({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});

// node_modules/ipfs-unixfs-importer/src/options.js
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults = merge_options_default.bind({ ignoreUndefined: true });
  return defaults(defaultOptions, options);
};

// node_modules/ipfs-unixfs-importer/src/utils/persist.js
var persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
var persist_default = persist;

// node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js
var dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode4(prepare({ Data: unixfs.marshal() }));
  const cid = await persist_default(buffer2, blockstore, options);
  const path2 = item.path;
  return {
    cid,
    path: path2,
    unixfs,
    size: buffer2.length
  };
};
var dir_default = dirBuilder;

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
var import_err_code26 = __toESM(require_err_code(), 1);
var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js
var import_it_all3 = __toESM(require_it_all(), 1);
async function flat(source, reduce2) {
  return reduce2(await (0, import_it_all3.default)(source));
}
var flat_default = flat;

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js
var import_it_batch = __toESM(require_it_batch(), 1);
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots = [];
  for await (const chunked of (0, import_it_batch.default)(source, options.maxChildrenPerNode)) {
    roots.push(await reduce2(chunked));
  }
  if (roots.length > 1) {
    return reduceToParents(roots, reduce2, options);
  }
  return roots[0];
}
var balanced_default = balanced;

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js
var import_it_batch2 = __toESM(require_it_batch(), 1);
async function trickleStream(source, reduce2, options) {
  const root = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root;
  for await (const layer of (0, import_it_batch2.default)(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce2));
  }
  return root.reduce(reduce2);
}
var trickle_default = trickleStream;
var SubTree = class {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent2) {
    this.parent = parent2;
    const nextNode = {
      children: [],
      depth: parent2.depth + 1,
      parent: parent2,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent2.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node, reduce2) {
    let children = [];
    if (node.children.length) {
      children = await Promise.all(
        node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2))
      );
    }
    return reduce2((node.data || []).concat(children));
  }
  _findParent(node, depth) {
    const parent2 = node.parent;
    if (!parent2 || parent2.depth === 0) {
      return;
    }
    if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
      return this._findParent(parent2, depth);
    }
    return parent2;
  }
};
var Root = class extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/buffer-importer.js
async function* bufferImporter(file, block, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: src_exports,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw_exports;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode4({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist_default(buffer2, block, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
var buffer_importer_default = bufferImporter;

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter2;
  if (typeof options.bufferImporter === "function") {
    bufferImporter2 = options.bufferImporter;
  } else {
    bufferImporter2 = buffer_importer_default;
  }
  for await (const entry of (0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
var reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode4(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist_default(buffer3, blockstore, {
          ...options,
          codec: src_exports,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links3 = leaves.filter((leaf) => {
      if (leaf.cid.code === code6 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code6) {
        f.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f.marshal(),
      Links: links3
    };
    const buffer2 = encode4(prepare(node));
    const cid = await persist_default(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f,
      size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code26.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;

// node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
var import_err_code29 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs-importer/src/chunker/rabin.js
var import_BufferList = __toESM(require_BufferList(), 1);
var import_rabin_wasm = __toESM(require_src3(), 1);
var import_err_code27 = __toESM(require_err_code(), 1);
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw (0, import_err_code27.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw (0, import_err_code27.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
var rabin_default = rabinChunker;
async function* rabin(source, options) {
  const r = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
  const buffers = new import_BufferList.default();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i2 = 0; i2 < sizes.length; i2++) {
      const size = sizes[i2];
      const buf2 = buffers.slice(0, size);
      buffers.consume(size);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}

// node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js
var import_BufferList2 = __toESM(require_BufferList(), 1);
async function* fixedSizeChunker(source, options) {
  let bl = new import_BufferList2.default();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    bl.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl.length) {
        bl = new import_BufferList2.default();
        currentLength = 0;
      } else {
        const newBl = new import_BufferList2.default();
        newBl.append(bl.shallowSlice(maxChunkSize));
        bl = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl.slice(0, currentLength);
  }
}
var fixed_size_default = fixedSizeChunker;

// node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js
var import_err_code28 = __toESM(require_err_code(), 1);
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw (0, import_err_code28.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString3(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw (0, import_err_code28.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
var validate_chunks_default = validateChunks;

// node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
function isIterable2(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable2(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code29.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code29.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path2) => path2 && path2 !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabin_default;
      } else {
        chunker = fixed_size_default;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validate_chunks_default;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => file_default(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dir_default(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
var dag_builder_default = dagBuilder;

// node_modules/ipfs-unixfs-importer/src/dir.js
var Dir = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name22, value2) {
  }
  get(name22) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var dir_default2 = Dir;

// node_modules/ipfs-unixfs-importer/src/dir-flat.js
var DirFlat = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name22, value2) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name22] = value2;
  }
  get(name22) {
    return Promise.resolve(this._children[name22]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys = Object.keys(this._children);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  async *flush(block) {
    const children = Object.keys(this._children);
    const links3 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = this._children[children[i2]];
      if (child instanceof dir_default2) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links3.push({
          Name: children[i2],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = { Data: unixfs.marshal(), Links: links3 };
    const buffer2 = encode4(prepare(node));
    const cid = await persist_default(buffer2, block, this.options);
    const size = buffer2.length + node.Links.reduce(
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs,
      path: this.path,
      size
    };
  }
};
var dir_flat_default = DirFlat;

// node_modules/hamt-sharding/dist/src/bucket.js
var import_sparse_array = __toESM(require_sparse_array(), 1);

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/identity.js
var identity_exports13 = {};
__export(identity_exports13, {
  identity: () => identity13
});

// node_modules/hamt-sharding/node_modules/multiformats/vendor/base-x.js
function base12(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src9 = base12;
var _brrp__multiformats_scope_baseX9 = src9;
var base_x_default9 = _brrp__multiformats_scope_baseX9;

// node_modules/hamt-sharding/node_modules/multiformats/src/bytes.js
var empty9 = new Uint8Array(0);
var equals19 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce9 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString13 = (str) => new TextEncoder().encode(str);
var toString14 = (b) => new TextDecoder().decode(b);

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base.js
var Encoder9 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder9 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or10(this, decoder);
  }
};
var ComposedDecoder9 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or10(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or10 = (left, right) => new ComposedDecoder9({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec9 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder9(name22, prefix, baseEncode);
    this.decoder = new Decoder9(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from15 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec9(name22, prefix, encode81, decode97);
var baseX9 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default9(alphabet16, name22);
  return from15({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce9(decode97(text))
  });
};
var decode46 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode38 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46489 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from15({
    prefix,
    name: name22,
    encode(input) {
      return encode38(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode46(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/identity.js
var identity13 = from15({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString14(buf2),
  decode: (str) => fromString13(str)
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base2.js
var base2_exports7 = {};
__export(base2_exports7, {
  base2: () => base28
});
var base28 = rfc46489({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base8.js
var base8_exports7 = {};
__export(base8_exports7, {
  base8: () => base87
});
var base87 = rfc46489({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base10.js
var base10_exports7 = {};
__export(base10_exports7, {
  base10: () => base107
});
var base107 = baseX9({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base16.js
var base16_exports7 = {};
__export(base16_exports7, {
  base16: () => base167,
  base16upper: () => base16upper7
});
var base167 = rfc46489({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper7 = rfc46489({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base32.js
var base32_exports7 = {};
__export(base32_exports7, {
  base32: () => base329,
  base32hex: () => base32hex9,
  base32hexpad: () => base32hexpad9,
  base32hexpadupper: () => base32hexpadupper9,
  base32hexupper: () => base32hexupper9,
  base32pad: () => base32pad9,
  base32padupper: () => base32padupper9,
  base32upper: () => base32upper9,
  base32z: () => base32z9
});
var base329 = rfc46489({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper9 = rfc46489({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad9 = rfc46489({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper9 = rfc46489({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex9 = rfc46489({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper9 = rfc46489({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad9 = rfc46489({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper9 = rfc46489({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z9 = rfc46489({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base36.js
var base36_exports7 = {};
__export(base36_exports7, {
  base36: () => base367,
  base36upper: () => base36upper7
});
var base367 = baseX9({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper7 = baseX9({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base58.js
var base58_exports7 = {};
__export(base58_exports7, {
  base58btc: () => base58btc9,
  base58flickr: () => base58flickr9
});
var base58btc9 = baseX9({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr9 = baseX9({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base64.js
var base64_exports7 = {};
__export(base64_exports7, {
  base64: () => base648,
  base64pad: () => base64pad8,
  base64url: () => base64url8,
  base64urlpad: () => base64urlpad8
});
var base648 = rfc46489({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad8 = rfc46489({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url8 = rfc46489({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad8 = rfc46489({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/hamt-sharding/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports7 = {};
__export(base256emoji_exports7, {
  base256emoji: () => base256emoji7
});
var alphabet7 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars7 = alphabet7.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes7 = alphabet7.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode39(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars7[c];
    return p;
  }, "");
}
function decode47(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes7[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji7 = from15({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode39,
  decode: decode47
});

// node_modules/hamt-sharding/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports7 = {};
__export(sha2_browser_exports7, {
  sha256: () => sha2567,
  sha512: () => sha5127
});

// node_modules/hamt-sharding/node_modules/multiformats/vendor/varint.js
var encode_18 = encode40;
var MSB8 = 128;
var REST8 = 127;
var MSBALL8 = ~REST8;
var INT8 = Math.pow(2, 31);
function encode40(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT8) {
    out[offset++] = num & 255 | MSB8;
    num /= 128;
  }
  while (num & MSBALL8) {
    out[offset++] = num & 255 | MSB8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode40.bytes = offset - oldOffset + 1;
  return out;
}
var decode48 = read8;
var MSB$18 = 128;
var REST$18 = 127;
function read8(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$18);
  read8.bytes = counter - offset;
  return res;
}
var N18 = Math.pow(2, 7);
var N28 = Math.pow(2, 14);
var N38 = Math.pow(2, 21);
var N48 = Math.pow(2, 28);
var N58 = Math.pow(2, 35);
var N68 = Math.pow(2, 42);
var N78 = Math.pow(2, 49);
var N88 = Math.pow(2, 56);
var N98 = Math.pow(2, 63);
var length8 = function(value2) {
  return value2 < N18 ? 1 : value2 < N28 ? 2 : value2 < N38 ? 3 : value2 < N48 ? 4 : value2 < N58 ? 5 : value2 < N68 ? 6 : value2 < N78 ? 7 : value2 < N88 ? 8 : value2 < N98 ? 9 : 10;
};
var varint11 = {
  encode: encode_18,
  decode: decode48,
  encodingLength: length8
};
var _brrp_varint8 = varint11;
var varint_default8 = _brrp_varint8;

// node_modules/hamt-sharding/node_modules/multiformats/src/varint.js
var decode49 = (data, offset = 0) => {
  const code22 = varint_default8.decode(data, offset);
  return [code22, varint_default8.decode.bytes];
};
var encodeTo8 = (int, target, offset = 0) => {
  varint_default8.encode(int, target, offset);
  return target;
};
var encodingLength8 = (int) => {
  return varint_default8.encodingLength(int);
};

// node_modules/hamt-sharding/node_modules/multiformats/src/hashes/digest.js
var create12 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength8(code22);
  const digestOffset = sizeOffset + encodingLength8(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo8(code22, bytes2, 0);
  encodeTo8(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest8(code22, size, digest15, bytes2);
};
var decode50 = (multihash) => {
  const bytes2 = coerce9(multihash);
  const [code22, sizeOffset] = decode49(bytes2);
  const [size, digestOffset] = decode49(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest8(code22, size, digest15, bytes2);
};
var equals20 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals19(a.bytes, data.bytes);
  }
};
var Digest8 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/hamt-sharding/node_modules/multiformats/src/hashes/hasher.js
var from16 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher7(name22, code22, encode81);
var Hasher7 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create12(this.code, result) : result.then((digest15) => create12(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/hamt-sharding/node_modules/multiformats/src/hashes/sha2-browser.js
var sha7 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2567 = from16({
  name: "sha2-256",
  code: 18,
  encode: sha7("SHA-256")
});
var sha5127 = from16({
  name: "sha2-512",
  code: 19,
  encode: sha7("SHA-512")
});

// node_modules/hamt-sharding/node_modules/multiformats/src/hashes/identity.js
var identity_exports14 = {};
__export(identity_exports14, {
  identity: () => identity14
});
var code13 = 0;
var name13 = "identity";
var encode41 = coerce9;
var digest7 = (input) => create12(code13, encode41(input));
var identity14 = { code: code13, name: name13, encode: encode41, digest: digest7 };

// node_modules/hamt-sharding/node_modules/multiformats/src/codecs/json.js
var textEncoder10 = new TextEncoder();
var textDecoder9 = new TextDecoder();

// node_modules/hamt-sharding/node_modules/multiformats/src/cid.js
var format7 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV08(
        bytes2,
        baseCache7(link),
        base30 || base58btc9.encoder
      );
    default:
      return toStringV18(
        bytes2,
        baseCache7(link),
        base30 || base329.encoder
      );
  }
};
var cache8 = /* @__PURE__ */ new WeakMap();
var baseCache7 = (cid) => {
  const baseCache16 = cache8.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache8.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID8 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID8.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create12(code22, digest15);
        return CID8.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID8.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals20(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format7(this, base30);
  }
  toJSON() {
    return { "/": format7(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID8) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID8(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID8(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol8] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode50(multihash);
      return CID8.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE8) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`
          );
        } else {
          return new CID8(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID8(version4, code22, digest15.bytes);
        return new CID8(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID8.create(0, DAG_PB_CODE8, digest15);
  }
  static createV1(code22, digest15) {
    return CID8.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID8.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID8.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce9(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest8(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID8.createV0(digest15) : CID8.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode49(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE8;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes8(source, base30);
    const cid = CID8.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache7(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes8 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc9;
      return [
        base58btc9.prefix,
        decoder.decode(`${base58btc9.prefix}${source}`)
      ];
    }
    case base58btc9.prefix: {
      const decoder = base30 || base58btc9;
      return [base58btc9.prefix, decoder.decode(source)];
    }
    case base329.prefix: {
      const decoder = base30 || base329;
      return [base329.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV08 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc9.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV18 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE8 = 112;
var SHA_256_CODE8 = 18;
var encodeCID8 = (version4, code22, multihash) => {
  const codeOffset = encodingLength8(version4);
  const hashOffset = codeOffset + encodingLength8(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo8(version4, bytes2, 0);
  encodeTo8(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

// node_modules/hamt-sharding/node_modules/multiformats/src/basics.js
var bases7 = { ...identity_exports13, ...base2_exports7, ...base8_exports7, ...base10_exports7, ...base16_exports7, ...base32_exports7, ...base36_exports7, ...base58_exports7, ...base64_exports7, ...base256emoji_exports7 };
var hashes7 = { ...sha2_browser_exports7, ...identity_exports14 };

// node_modules/hamt-sharding/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array6(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/hamt-sharding/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe6(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array6(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/hamt-sharding/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec9(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string6 = createCodec9("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii6 = createCodec9("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe6(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES6 = {
  utf8: string6,
  "utf-8": string6,
  hex: bases7.base16,
  latin1: ascii6,
  ascii: ascii6,
  binary: ascii6,
  ...bases7
};
var bases_default6 = BASES6;

// node_modules/hamt-sharding/node_modules/uint8arrays/dist/src/from-string.js
function fromString14(string14, encoding = "utf8") {
  const base30 = bases_default6[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array6(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/hamt-sharding/dist/src/bucket.js
var Bucket = class {
  constructor(options, parent2, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent2;
    this._posAtParent = posAtParent;
    this._children = new import_sparse_array.default();
    this.key = null;
  }
  async put(key, value2) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value2);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map19, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map19, reduce2));
        } else {
          acc2.push(map19(child, index));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return await asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString14(key) : key);
    const index = await hashValue.take(this._options.bits);
    const child = this._children.get(index);
    if (child instanceof Bucket) {
      return await child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return await bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value2) {
    this._putObjectAt(place.pos, {
      key,
      value: value2,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash3 = onlyChild.hash;
          hash3.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash3,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index) {
    return this._children.get(index);
  }
};
function exists(o) {
  return Boolean(o);
}
function mapNode(node, _) {
  return node.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return await asyncReduce(output);
}

// node_modules/hamt-sharding/dist/src/consumable-buffer.js
var START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
var STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var ConsumableBuffer = class {
  constructor(value2) {
    this._value = value2;
    this._currentBytePos = value2.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits2) {
    let pendingBits = bits2;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value2 = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value2;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits2) {
    this._currentBitPos += bits2;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte, start, length23) {
  const mask = maskFor(start, length23);
  return (byte & mask) >>> start;
}
function maskFor(start, length23) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length23 + start - 1, 7)];
}

// node_modules/hamt-sharding/node_modules/uint8arrays/dist/src/concat.js
function concat5(arrays, length23) {
  if (length23 == null) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe6(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array6(output);
}

// node_modules/hamt-sharding/dist/src/consumable-hash.js
function wrapHash(hashFn2) {
  function hashing(value2) {
    if (value2 instanceof InfiniteHash) {
      return value2;
    } else {
      return new InfiniteHash(value2, hashFn2);
    }
  }
  return hashing;
}
var InfiniteHash = class {
  constructor(value2, hashFn2) {
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value2;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits2) {
    let pendingBits = bits2;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash3.availableBits(), pendingBits);
      const took = hash3.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash3.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits2) {
    let pendingBits = bits2;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash3.totalBits() - hash3.availableBits(), pendingBits);
      hash3.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash3.totalBits() === hash3.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value2 = this._depth > 0 ? concat5([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value2);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
};

// node_modules/hamt-sharding/dist/src/index.js
function createHAMT(options) {
  if (options == null || options.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits ?? 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}

// node_modules/ipfs-unixfs-importer/src/dir-sharded.js
var DirSharded = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name22, value2) {
    await this._bucket.put(name22, value2);
  }
  get(name22) {
    return this._bucket.get(name22);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
var dir_sharded_default = DirSharded;
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value2.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value2.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode4(prepare(node));
  const cid = await persist_default(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}

// node_modules/ipfs-unixfs-importer/src/flat-to-shard.js
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
var flat_to_shard_default = flatToShard;

// node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js
var toPathComponents = (path2 = "") => {
  return (path2.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;

// node_modules/ipfs-unixfs-importer/src/tree-builder.js
async function addToTree(elem, tree2, options) {
  const pathElems = to_path_components_default(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i2 = 0; i2 < pathElems.length; i2++) {
    const pathElem = pathElems[i2];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last14 = i2 === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last14) {
      await parent2.put(pathElem, elem);
      tree2 = await flat_to_shard_default(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof dir_default2)) {
        dir = new dir_flat_default({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof dir_default2)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block, options) {
  let tree2 = new dir_flat_default({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
var tree_builder_default = treeBuilder;

// node_modules/ipfs-unixfs-importer/src/index.js
async function* importer2(source, blockstore, options = {}) {
  const opts = options_default(options);
  let dagBuilder2;
  if (typeof options.dagBuilder === "function") {
    dagBuilder2 = options.dagBuilder;
  } else {
    dagBuilder2 = dag_builder_default;
  }
  let treeBuilder2;
  if (typeof options.treeBuilder === "function") {
    treeBuilder2 = options.treeBuilder;
  } else {
    treeBuilder2 = tree_builder_default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}

// node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
var import_err_code30 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable3 = __toESM(require_it_peekable(), 1);
var import_it_map4 = __toESM(require_it_map(), 1);
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
    throw (0, import_err_code30.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it3.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable3.default)(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      throw (0, import_err_code30.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value2._readableState) {
      yield* (0, import_it_map4.default)(peekable, (value3) => toFileObject2({ content: value3 }, normaliseContent3));
      return;
    }
    if (isBytes(value2)) {
      yield toFileObject2({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value2) || value2[Symbol.iterator] || value2[Symbol.asyncIterator] || isReadableStream(value2) || isBlob(value2)) {
      yield* (0, import_it_map4.default)(peekable, (value3) => toFileObject2(value3, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code30.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code30.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path2) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js
function normaliseInput3(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}

// node_modules/ipfs-core/src/components/add-all/utils.js
var parseChunkerString = (chunker) => {
  if (!chunker) {
    return {
      chunker: "fixed"
    };
  } else if (chunker.startsWith("size-")) {
    const sizeStr = chunker.split("-")[1];
    const size = parseInt(sizeStr);
    if (isNaN(size)) {
      throw new Error("Chunker parameter size must be an integer");
    }
    return {
      chunker: "fixed",
      maxChunkSize: size
    };
  } else if (chunker.startsWith("rabin")) {
    return {
      chunker: "rabin",
      ...parseRabinString(chunker)
    };
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`);
  }
};
var parseRabinString = (chunker) => {
  const options = {};
  const parts2 = chunker.split("-");
  switch (parts2.length) {
    case 1:
      options.avgChunkSize = 262144;
      break;
    case 2:
      options.avgChunkSize = parseChunkSize(parts2[1], "avg");
      break;
    case 4:
      options.minChunkSize = parseChunkSize(parts2[1], "min");
      options.avgChunkSize = parseChunkSize(parts2[2], "avg");
      options.maxChunkSize = parseChunkSize(parts2[3], "max");
      break;
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
  }
  return options;
};
var parseChunkSize = (str, name22) => {
  const size = parseInt(str);
  if (isNaN(size)) {
    throw new Error(`Chunker parameter ${name22} must be an integer`);
  }
  return size;
};

// node_modules/ipfs-core/src/components/add-all/index.js
var mergeOptions3 = merge_options_default.bind({ ignoreUndefined: true });
function createAddAll2({ repo, preload: preload2, hashers, options }) {
  const isShardingEnabled = options && options.sharding;
  async function* addAll(source, options2 = {}) {
    const opts = mergeOptions3({
      shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
      strategy: "balanced"
    }, options2, {
      ...parseChunkerString(options2.chunker)
    });
    if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
      opts.cidVersion = 1;
    }
    if (opts.trickle) {
      opts.strategy = "trickle";
    }
    if (opts.strategy === "trickle") {
      opts.leafType = "raw";
      opts.reduceSingleLeafToSelf = false;
    }
    if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    delete opts.trickle;
    const totals = {};
    if (opts.progress) {
      const prog = opts.progress;
      opts.progress = (bytes2, path2) => {
        if (!totals[path2]) {
          totals[path2] = 0;
        }
        totals[path2] += bytes2;
        prog(totals[path2], path2);
      };
    }
    let hasher;
    if (opts.hashAlg != null) {
      hasher = await hashers.getHasher(opts.hashAlg);
    }
    const iterator = pipe(
      normaliseInput3(source),
      (source2) => importer2(source2, repo.blocks, {
        ...opts,
        hasher,
        pin: false
      }),
      transformFile(opts),
      preloadFile(preload2, opts),
      pinFile(repo, opts)
    );
    const releaseLock = await repo.gcLock.readLock();
    try {
      for await (const added of iterator) {
        const path2 = added.path ?? added.cid.toString();
        delete totals[path2];
        yield {
          ...added,
          path: path2
        };
      }
    } finally {
      releaseLock();
    }
  }
  return withTimeoutOption(addAll);
}
function transformFile(opts) {
  async function* transformFile2(source) {
    for await (const file of source) {
      let cid = file.cid;
      if (opts.cidVersion === 1) {
        cid = cid.toV1();
      }
      let path2 = file.path ? file.path : cid.toString();
      if (opts.wrapWithDirectory && !file.path) {
        path2 = "";
      }
      yield {
        path: path2,
        cid,
        size: file.size,
        mode: file.unixfs && file.unixfs.mode,
        mtime: file.unixfs && file.unixfs.mtime
      };
    }
  }
  return transformFile2;
}
function preloadFile(preload2, opts) {
  async function* maybePreloadFile(source) {
    for await (const file of source) {
      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
      if (shouldPreload) {
        preload2(file.cid);
      }
      yield file;
    }
  }
  return maybePreloadFile;
}
function pinFile(repo, opts) {
  async function* maybePinFile(source) {
    for await (const file of source) {
      const isRootDir = !(file.path && file.path.includes("/"));
      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
      if (shouldPin) {
        await repo.pins.pinRecursively(file.cid);
      }
      yield file;
    }
  }
  return maybePinFile;
}

// node_modules/ipfs-unixfs-exporter/src/index.js
var import_err_code38 = __toESM(require_err_code());

// node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
var import_err_code37 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
var import_err_code33 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js
var hashFn = async function(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
};
var addLinksToHamtBucket = (links3, bucket, rootBucket) => {
  return Promise.all(
    links3.map((link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    })
  );
};
var toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var toBucketPath = (position) => {
  let bucket = position.bucket;
  const path2 = [];
  while (bucket._parent) {
    path2.push(bucket);
    bucket = bucket._parent;
  }
  path2.push(bucket);
  return path2.reverse();
};
var findShardCid = async (node, name22, blockstore, context, options) => {
  if (!context) {
    const rootBucket = createHAMT({
      hashFn
    });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name22);
  let prefix = toPrefix(position.pos);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix(context.lastBucket._posAtParent);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name22) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name22) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node = decode6(block);
  return findShardCid(node, name22, blockstore, context, options);
};
var find_cid_in_shard_default = findShardCid;

// node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.subarray(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.subarray(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default = extractDataFromBlock;

// node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js
var import_err_code31 = __toESM(require_err_code(), 1);
var validateOffsetAndLength = (size, offset, length23) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw (0, import_err_code31.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size) {
    throw (0, import_err_code31.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length23 && length23 !== 0) {
    length23 = size - offset;
  }
  if (length23 < 0) {
    throw (0, import_err_code31.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length23 > size) {
    length23 = size - offset;
  }
  return {
    offset,
    length: length23
  };
};
var validate_offset_and_length_default = validateOffsetAndLength;

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js
var import_err_code32 = __toESM(require_err_code(), 1);
var import_it_parallel2 = __toESM(require_it_parallel(), 1);
var import_it_map5 = __toESM(require_it_map(), 1);
async function walkDAG(blockstore, node, queue, streamPosition, start, end, walkQueue, options) {
  if (node instanceof Uint8Array) {
    queue.push(extract_data_from_block_default(node, streamPosition, start, end));
    return;
  }
  if (node.Data == null) {
    throw (0, import_err_code32.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code32.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (file.data != null) {
    const data = file.data;
    const buf2 = extract_data_from_block_default(data, streamPosition, start, end);
    queue.push(buf2);
    streamPosition += buf2.byteLength;
  }
  const childOps = [];
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const childLink = node.Links[i2];
    const childStart = streamPosition;
    const childEnd = childStart + file.blockSizes[i2];
    if (start >= childStart && start < childEnd || end >= childStart && end <= childEnd || start < childStart && end > childEnd) {
      childOps.push({
        link: childLink,
        blockStart: streamPosition
      });
    }
    streamPosition = childEnd;
    if (streamPosition > end) {
      break;
    }
  }
  await pipe(
    childOps,
    (source) => (0, import_it_map5.default)(source, (op) => {
      return async () => {
        const block = await blockstore.get(op.link.Hash, {
          signal: options.signal
        });
        return {
          ...op,
          block
        };
      };
    }),
    (source) => (0, import_it_parallel2.default)(source, {
      ordered: true
    }),
    async (source) => {
      for await (const { link, block, blockStart } of source) {
        let child;
        switch (link.Hash.code) {
          case code:
            child = decode6(block);
            break;
          case code6:
            child = block;
            break;
          default:
            queue.end((0, import_err_code32.default)(new Error(`Unsupported codec: ${link.Hash.code}`), "ERR_NOT_UNIXFS"));
            return;
        }
        walkQueue.add(async () => {
          await walkDAG(blockstore, child, queue, blockStart, start, end, walkQueue, options);
        });
      }
    }
  );
}
var fileContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  async function* yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const {
      offset,
      length: length23
    } = validate_offset_and_length_default(fileSize, options.offset, options.length);
    if (length23 === 0) {
      return;
    }
    const walkQueue = new PQueue({
      concurrency: 1
    });
    const queue = pushable();
    walkQueue.add(async () => {
      await walkDAG(blockstore, node, queue, 0, offset, offset + length23, walkQueue, options);
    });
    walkQueue.on("error", (error) => {
      queue.end(error);
    });
    let read19 = 0;
    for await (const buf2 of queue) {
      if (buf2 == null) {
        continue;
      }
      read19 += buf2.byteLength;
      if (read19 === length23) {
        queue.end();
      }
      yield buf2;
    }
  }
  return yieldFileContent;
};
var file_default2 = fileContent;

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js
var directoryContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length23 = options.length || node.Links.length;
    const links3 = node.Links.slice(offset, length23);
    for (const link of links3) {
      const result = await resolve7(link.Hash, link.Name || "", `${path2}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
var directory_default = directoryContent;

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
var hamtShardedDirectoryContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node, path2, resolve7, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path2, resolve7, depth, blockstore, options) {
  const links3 = node.Links;
  for (const link of links3) {
    const name22 = link.Name != null ? link.Name.substring(2) : null;
    if (name22) {
      const result = await resolve7(link.Hash, name22, `${path2}/${name22}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode6(block);
      for await (const file of listDirectory(node, path2, resolve7, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamt_sharded_directory_default = hamtShardedDirectoryContent;

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
var findLinkCid = (node, name22) => {
  const link = node.Links.find((link2) => link2.Name === name22);
  return link && link.Hash;
};
var contentExporters = {
  raw: file_default2,
  file: file_default2,
  directory: directory_default,
  "hamt-sharded-directory": hamt_sharded_directory_default,
  metadata: (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
    return () => [];
  }
};
var unixFsResolver = async (cid, name22, path2, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node = decode6(block);
  let unixfs;
  let next;
  if (!name22) {
    name22 = cid.toString();
  }
  if (node.Data == null) {
    throw (0, import_err_code33.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code33.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (!path2) {
    path2 = name22;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (!linkCid) {
      throw (0, import_err_code33.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path2}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name22,
      path: path2,
      cid,
      content: contentExporters[unixfs.type](cid, node, unixfs, path2, resolve7, depth, blockstore),
      unixfs,
      depth,
      node,
      size: unixfs.fileSize()
    },
    next
  };
};
var unixfs_v1_default = unixFsResolver;

// node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js
var import_err_code34 = __toESM(require_err_code(), 1);
var rawContent = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length23
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length23);
  }
  return contentGenerator;
};
var resolve2 = async (cid, name22, path2, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code34.default)(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name22,
      path: path2,
      cid,
      content: rawContent(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
var raw_default = resolve2;

// node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js
var import_err_code35 = __toESM(require_err_code(), 1);
var resolve3 = async (cid, name22, path2, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode8(block);
  let subObject = object;
  let subPath = path2;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name22,
            path: path2,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw (0, import_err_code35.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name22,
      path: path2,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
var dag_cbor_default = resolve3;

// node_modules/ipfs-unixfs-exporter/src/resolvers/identity.js
var import_err_code36 = __toESM(require_err_code(), 1);
var rawContent2 = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length23
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length23);
  }
  return contentGenerator;
};
var resolve4 = async (cid, name22, path2, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code36.default)(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = await decode4(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name22,
      path: path2,
      cid,
      content: rawContent2(buf2.digest),
      depth,
      size: buf2.digest.length,
      node: buf2.digest
    }
  };
};
var identity_default = resolve4;

// node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
var resolvers2 = {
  [code]: unixfs_v1_default,
  [code6]: raw_default,
  [code2]: dag_cbor_default,
  [identity.code]: identity_default
};
function resolve5(cid, name22, path2, toResolve, depth, blockstore, options) {
  const resolver = resolvers2[cid.code];
  if (!resolver) {
    throw (0, import_err_code37.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name22, path2, toResolve, resolve5, depth, blockstore, options);
}
var resolvers_default = resolve5;

// node_modules/ipfs-unixfs-exporter/src/index.js
var import_it_last4 = __toESM(require_it_last());
var toPathComponents2 = (path2 = "") => {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
var cidAndRest = (path2) => {
  if (path2 instanceof Uint8Array) {
    return {
      cid: CID.decode(path2),
      toResolve: []
    };
  }
  const cid = CID.asCID(path2);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path2 === "string") {
    if (path2.indexOf("/ipfs/") === 0) {
      path2 = path2.substring(6);
    }
    const output = toPathComponents2(path2);
    return {
      cid: CID.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw (0, import_err_code38.default)(new Error(`Unknown path type ${path2}`), "ERR_BAD_PATH");
};
async function* walkPath(path2, blockstore, options = {}) {
  let {
    cid,
    toResolve
  } = cidAndRest(path2);
  let name22 = cid.toString();
  let entryPath = name22;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name22, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code38.default)(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name22 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter2(path2, blockstore, options = {}) {
  const result = await (0, import_it_last4.default)(walkPath(path2, blockstore, options));
  if (!result) {
    throw (0, import_err_code38.default)(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path2, blockstore, options = {}) {
  const node = await exporter2(path2, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}

// node_modules/ipfs-core/src/components/cat.js
function createCat({ repo, preload: preload2 }) {
  async function* cat(ipfsPath3, options = {}) {
    ipfsPath3 = normalizeCidPath(ipfsPath3);
    if (options.preload !== false) {
      const pathComponents = ipfsPath3.split("/");
      preload2(CID.parse(pathComponents[0]));
    }
    const file = await exporter2(ipfsPath3, repo.blocks, options);
    if (file.type === "directory") {
      throw new Error("this dag node is a directory");
    }
    if (!file.content) {
      throw new Error("this dag node has no content");
    }
    yield* file.content(options);
  }
  return withTimeoutOption(cat);
}

// node_modules/ipfs-core/src/components/get.js
var import_err_code39 = __toESM(require_err_code(), 1);

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve7, reject) => {
    deferred.resolve = resolve7;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array7(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js
function alloc2(size = 0) {
  if (globalThis.Buffer?.alloc != null) {
    return asUint8Array7(globalThis.Buffer.alloc(size));
  }
  return new Uint8Array(size);
}
function allocUnsafe7(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array7(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js
function concat6(arrays, length23) {
  if (length23 == null) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe7(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array7(output);
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js
function equals21(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/uint8arraylist/dist/src/index.js
var symbol3 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf2,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value2) {
  return Boolean(value2?.[symbol3]);
}
var Uint8ArrayList = class {
  constructor(...data) {
    Object.defineProperty(this, symbol3, { value: true });
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  append(...bufs) {
    this.appendAll(bufs);
  }
  appendAll(bufs) {
    let length23 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length23 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length23 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length23;
  }
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  prependAll(bufs) {
    let length23 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length23 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length23 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length23;
  }
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  set(index, value2) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value2;
  }
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2[i2]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  consume(bytes2) {
    bytes2 = Math.trunc(bytes2);
    if (Number.isNaN(bytes2) || bytes2 <= 0) {
      return;
    }
    if (bytes2 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes2 >= this.bufs[0].byteLength) {
        bytes2 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes2);
        this.length -= bytes2;
        break;
      }
    }
  }
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length23 } = this._subList(beginInclusive, endExclusive);
    return concat6(bufs, length23);
  }
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length23 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat6(bufs, length23);
  }
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length23 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length23;
    list.bufs = bufs;
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: [...this.bufs], length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf2 = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value2) {
    const buf2 = allocUnsafe7(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value2);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value2) {
    const buf2 = allocUnsafe7(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value2);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value2, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals21(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  static fromUint8Arrays(bufs, length23) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length23 == null) {
      length23 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length23;
    return list;
  }
};

// node_modules/it-tar/node_modules/multiformats/src/bases/identity.js
var identity_exports15 = {};
__export(identity_exports15, {
  identity: () => identity15
});

// node_modules/it-tar/node_modules/multiformats/vendor/base-x.js
function base13(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src10 = base13;
var _brrp__multiformats_scope_baseX10 = src10;
var base_x_default10 = _brrp__multiformats_scope_baseX10;

// node_modules/it-tar/node_modules/multiformats/src/bytes.js
var empty10 = new Uint8Array(0);
var equals22 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce10 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString15 = (str) => new TextEncoder().encode(str);
var toString15 = (b) => new TextDecoder().decode(b);

// node_modules/it-tar/node_modules/multiformats/src/bases/base.js
var Encoder10 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder10 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or11(this, decoder);
  }
};
var ComposedDecoder10 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or11(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or11 = (left, right) => new ComposedDecoder10({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec10 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder10(name22, prefix, baseEncode);
    this.decoder = new Decoder10(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from17 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec10(name22, prefix, encode81, decode97);
var baseX10 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default10(alphabet16, name22);
  return from17({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce10(decode97(text))
  });
};
var decode51 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode42 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464810 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from17({
    prefix,
    name: name22,
    encode(input) {
      return encode42(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode51(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/it-tar/node_modules/multiformats/src/bases/identity.js
var identity15 = from17({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString15(buf2),
  decode: (str) => fromString15(str)
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base2.js
var base2_exports8 = {};
__export(base2_exports8, {
  base2: () => base29
});
var base29 = rfc464810({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base8.js
var base8_exports8 = {};
__export(base8_exports8, {
  base8: () => base88
});
var base88 = rfc464810({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base10.js
var base10_exports8 = {};
__export(base10_exports8, {
  base10: () => base108
});
var base108 = baseX10({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base16.js
var base16_exports8 = {};
__export(base16_exports8, {
  base16: () => base168,
  base16upper: () => base16upper8
});
var base168 = rfc464810({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper8 = rfc464810({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base32.js
var base32_exports8 = {};
__export(base32_exports8, {
  base32: () => base3210,
  base32hex: () => base32hex10,
  base32hexpad: () => base32hexpad10,
  base32hexpadupper: () => base32hexpadupper10,
  base32hexupper: () => base32hexupper10,
  base32pad: () => base32pad10,
  base32padupper: () => base32padupper10,
  base32upper: () => base32upper10,
  base32z: () => base32z10
});
var base3210 = rfc464810({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper10 = rfc464810({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad10 = rfc464810({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper10 = rfc464810({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex10 = rfc464810({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper10 = rfc464810({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad10 = rfc464810({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper10 = rfc464810({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z10 = rfc464810({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base36.js
var base36_exports8 = {};
__export(base36_exports8, {
  base36: () => base368,
  base36upper: () => base36upper8
});
var base368 = baseX10({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper8 = baseX10({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base58.js
var base58_exports8 = {};
__export(base58_exports8, {
  base58btc: () => base58btc10,
  base58flickr: () => base58flickr10
});
var base58btc10 = baseX10({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr10 = baseX10({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base64.js
var base64_exports8 = {};
__export(base64_exports8, {
  base64: () => base649,
  base64pad: () => base64pad9,
  base64url: () => base64url9,
  base64urlpad: () => base64urlpad9
});
var base649 = rfc464810({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad9 = rfc464810({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url9 = rfc464810({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad9 = rfc464810({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/it-tar/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports8 = {};
__export(base256emoji_exports8, {
  base256emoji: () => base256emoji8
});
var alphabet8 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars8 = alphabet8.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes8 = alphabet8.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode43(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars8[c];
    return p;
  }, "");
}
function decode52(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes8[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji8 = from17({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode43,
  decode: decode52
});

// node_modules/it-tar/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports8 = {};
__export(sha2_browser_exports8, {
  sha256: () => sha2568,
  sha512: () => sha5128
});

// node_modules/it-tar/node_modules/multiformats/vendor/varint.js
var encode_19 = encode44;
var MSB9 = 128;
var REST9 = 127;
var MSBALL9 = ~REST9;
var INT9 = Math.pow(2, 31);
function encode44(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT9) {
    out[offset++] = num & 255 | MSB9;
    num /= 128;
  }
  while (num & MSBALL9) {
    out[offset++] = num & 255 | MSB9;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode44.bytes = offset - oldOffset + 1;
  return out;
}
var decode53 = read9;
var MSB$19 = 128;
var REST$19 = 127;
function read9(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$19);
  read9.bytes = counter - offset;
  return res;
}
var N19 = Math.pow(2, 7);
var N29 = Math.pow(2, 14);
var N39 = Math.pow(2, 21);
var N49 = Math.pow(2, 28);
var N59 = Math.pow(2, 35);
var N69 = Math.pow(2, 42);
var N79 = Math.pow(2, 49);
var N89 = Math.pow(2, 56);
var N99 = Math.pow(2, 63);
var length9 = function(value2) {
  return value2 < N19 ? 1 : value2 < N29 ? 2 : value2 < N39 ? 3 : value2 < N49 ? 4 : value2 < N59 ? 5 : value2 < N69 ? 6 : value2 < N79 ? 7 : value2 < N89 ? 8 : value2 < N99 ? 9 : 10;
};
var varint12 = {
  encode: encode_19,
  decode: decode53,
  encodingLength: length9
};
var _brrp_varint9 = varint12;
var varint_default9 = _brrp_varint9;

// node_modules/it-tar/node_modules/multiformats/src/varint.js
var decode54 = (data, offset = 0) => {
  const code22 = varint_default9.decode(data, offset);
  return [code22, varint_default9.decode.bytes];
};
var encodeTo9 = (int, target, offset = 0) => {
  varint_default9.encode(int, target, offset);
  return target;
};
var encodingLength9 = (int) => {
  return varint_default9.encodingLength(int);
};

// node_modules/it-tar/node_modules/multiformats/src/hashes/digest.js
var create13 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength9(code22);
  const digestOffset = sizeOffset + encodingLength9(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo9(code22, bytes2, 0);
  encodeTo9(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest9(code22, size, digest15, bytes2);
};
var decode55 = (multihash) => {
  const bytes2 = coerce10(multihash);
  const [code22, sizeOffset] = decode54(bytes2);
  const [size, digestOffset] = decode54(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest9(code22, size, digest15, bytes2);
};
var equals23 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals22(a.bytes, data.bytes);
  }
};
var Digest9 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/it-tar/node_modules/multiformats/src/hashes/hasher.js
var from18 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher8(name22, code22, encode81);
var Hasher8 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create13(this.code, result) : result.then((digest15) => create13(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/it-tar/node_modules/multiformats/src/hashes/sha2-browser.js
var sha8 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2568 = from18({
  name: "sha2-256",
  code: 18,
  encode: sha8("SHA-256")
});
var sha5128 = from18({
  name: "sha2-512",
  code: 19,
  encode: sha8("SHA-512")
});

// node_modules/it-tar/node_modules/multiformats/src/hashes/identity.js
var identity_exports16 = {};
__export(identity_exports16, {
  identity: () => identity16
});
var code14 = 0;
var name14 = "identity";
var encode45 = coerce10;
var digest8 = (input) => create13(code14, encode45(input));
var identity16 = { code: code14, name: name14, encode: encode45, digest: digest8 };

// node_modules/it-tar/node_modules/multiformats/src/codecs/json.js
var textEncoder11 = new TextEncoder();
var textDecoder10 = new TextDecoder();

// node_modules/it-tar/node_modules/multiformats/src/cid.js
var format8 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV09(
        bytes2,
        baseCache8(link),
        base30 || base58btc10.encoder
      );
    default:
      return toStringV19(
        bytes2,
        baseCache8(link),
        base30 || base3210.encoder
      );
  }
};
var cache9 = /* @__PURE__ */ new WeakMap();
var baseCache8 = (cid) => {
  const baseCache16 = cache9.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache9.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID9 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE9) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE9) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID9.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create13(code22, digest15);
        return CID9.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID9.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals23(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format8(this, base30);
  }
  toJSON() {
    return { "/": format8(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID9) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID9(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID9(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol9] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode55(multihash);
      return CID9.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE9) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`
          );
        } else {
          return new CID9(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID9(version4, code22, digest15.bytes);
        return new CID9(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID9.create(0, DAG_PB_CODE9, digest15);
  }
  static createV1(code22, digest15) {
    return CID9.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID9.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID9.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce10(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest9(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID9.createV0(digest15) : CID9.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode54(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE9;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes9(source, base30);
    const cid = CID9.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache8(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes9 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc10;
      return [
        base58btc10.prefix,
        decoder.decode(`${base58btc10.prefix}${source}`)
      ];
    }
    case base58btc10.prefix: {
      const decoder = base30 || base58btc10;
      return [base58btc10.prefix, decoder.decode(source)];
    }
    case base3210.prefix: {
      const decoder = base30 || base3210;
      return [base3210.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV09 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc10.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV19 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE9 = 112;
var SHA_256_CODE9 = 18;
var encodeCID9 = (version4, code22, multihash) => {
  const codeOffset = encodingLength9(version4);
  const hashOffset = codeOffset + encodingLength9(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo9(version4, bytes2, 0);
  encodeTo9(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

// node_modules/it-tar/node_modules/multiformats/src/basics.js
var bases8 = { ...identity_exports15, ...base2_exports8, ...base8_exports8, ...base10_exports8, ...base16_exports8, ...base32_exports8, ...base36_exports8, ...base58_exports8, ...base64_exports8, ...base256emoji_exports8 };
var hashes8 = { ...sha2_browser_exports8, ...identity_exports16 };

// node_modules/it-tar/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array8(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/it-tar/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe8(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array8(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/it-tar/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec10(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string7 = createCodec10("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii7 = createCodec10("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe8(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES7 = {
  utf8: string7,
  "utf-8": string7,
  hex: bases8.base16,
  latin1: ascii7,
  ascii: ascii7,
  binary: ascii7,
  ...bases8
};
var bases_default7 = BASES7;

// node_modules/it-tar/node_modules/uint8arrays/dist/src/to-string.js
function toString16(array, encoding = "utf8") {
  const base30 = bases_default7[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/it-tar/node_modules/uint8arrays/dist/src/from-string.js
function fromString16(string14, encoding = "utf8") {
  const base30 = bases_default7[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array8(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/it-tar/dist/src/extract-headers.js
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR_MAGIC = fromString16("ustar\0", "binary");
var GNU_MAGIC = fromString16("ustar ", "binary");
var GNU_VER = fromString16(" \0", "binary");

// node_modules/it-reader/dist/src/index.js
function reader3(source) {
  const reader6 = async function* () {
    let bytes2 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes2 == null) {
        bl.append(chunk);
        bytes2 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes2) {
        const data = bl.sublist(0, bytes2);
        bl.consume(bytes2);
        bytes2 = yield data;
        if (bytes2 == null) {
          if (bl.length > 0) {
            bytes2 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes2 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader6.next();
  return reader6;
}

// node_modules/it-tar/dist/src/pack.js
var import_iso_constants = __toESM(require_index_browser(), 1);

// node_modules/it-tar/node_modules/uint8arrays/dist/src/concat.js
function concat7(arrays, length23) {
  if (length23 == null) {
    length23 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe8(length23);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array8(output);
}

// node_modules/it-tar/node_modules/it-to-buffer/dist/src/index.js
async function toBuffer(stream) {
  let buffer2 = new Uint8Array(0);
  for await (const buf2 of stream) {
    buffer2 = concat7([buffer2, buf2], buffer2.length + buf2.length);
  }
  return buffer2;
}

// node_modules/it-tar/dist/src/pack-headers.js
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET2 = "0".charCodeAt(0);
var USTAR_MAGIC2 = fromString16("ustar\0", "binary");
var USTAR_VER = fromString16("00", "binary");
var MASK = parseInt("7777", 8);
var MAGIC_OFFSET = 257;
var VERSION_OFFSET = 263;
var toTypeflag = function(flag) {
  switch (flag) {
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
    default:
      return 0;
  }
};
var cksum = function(block) {
  let sum = 8 * 32;
  for (let i2 = 0; i2 < 148; i2++)
    sum += block[i2];
  for (let j = 156; j < 512; j++)
    sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  const str = val.toString(8);
  if (str.length > n) {
    return fromString16(SEVENS.slice(0, n) + " ");
  }
  return fromString16(ZEROS.slice(0, n - str.length) + str + " ");
};
var addLength = function(str) {
  const len = fromString16(str).byteLength;
  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) {
    digits++;
  }
  return `${len + digits}${str}`;
};
function encodePax(opts) {
  let result = "";
  if (opts.name != null) {
    result += addLength(" path=" + opts.name + "\n");
  }
  if (opts.linkname != null) {
    result += addLength(" linkpath=" + opts.linkname + "\n");
  }
  const pax = opts.pax;
  if (pax != null) {
    for (const key in pax) {
      if (Object.prototype.hasOwnProperty.call(pax, key)) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
  }
  return fromString16(result);
}
function encode46(opts) {
  const buf2 = new Uint8Array(512);
  let name22 = opts.name;
  let prefix = "";
  if (opts.typeflag === 5 && name22[name22.length - 1] !== "/") {
    name22 += "/";
  }
  if (fromString16(name22).byteLength !== name22.length) {
    return null;
  }
  while (fromString16(name22).byteLength > 100) {
    const i2 = name22.indexOf("/");
    if (i2 === -1) {
      return null;
    }
    prefix += prefix !== "" ? "/" + name22.slice(0, i2) : name22.slice(0, i2);
    name22 = name22.slice(i2 + 1);
  }
  if (fromString16(name22).byteLength > 100 || fromString16(prefix).byteLength > 155) {
    return null;
  }
  if (opts.linkname != null && fromString16(opts.linkname).byteLength > 100) {
    return null;
  }
  buf2.set(fromString16(name22), 0);
  buf2.set(encodeOct(opts.mode & MASK, 6), 100);
  buf2.set(encodeOct(opts.uid, 6), 108);
  buf2.set(encodeOct(opts.gid, 6), 116);
  buf2.set(encodeOct(opts.size, 11), 124);
  buf2.set(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf2[156] = ZERO_OFFSET2 + toTypeflag(opts.type);
  if (opts.linkname != null) {
    buf2.set(fromString16(opts.linkname), 157);
  }
  buf2.set(USTAR_MAGIC2, MAGIC_OFFSET);
  buf2.set(USTAR_VER, VERSION_OFFSET);
  if (opts.uname != null) {
    buf2.set(fromString16(opts.uname), 265);
  }
  if (opts.gname != null) {
    buf2.set(fromString16(opts.gname), 297);
  }
  buf2.set(encodeOct(opts.devmajor ?? 0, 6), 329);
  buf2.set(encodeOct(opts.devminor ?? 0, 6), 337);
  if (prefix != null) {
    buf2.set(fromString16(prefix), 345);
  }
  buf2.set(encodeOct(cksum(buf2), 6), 148);
  return buf2;
}

// node_modules/it-tar/dist/src/pack.js
var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = import_iso_constants.default;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = new Uint8Array(1024);
function modeToType(mode = 0) {
  switch (mode & S_IFMT) {
    case S_IFBLK:
      return "block-device";
    case S_IFCHR:
      return "character-device";
    case S_IFDIR:
      return "directory";
    case S_IFIFO:
      return "fifo";
    case S_IFLNK:
      return "symlink";
    default:
      return "file";
  }
}
function getPadding(size) {
  size &= 511;
  if (size !== 0) {
    return END_OF_TAR.subarray(0, 512 - size);
  }
  return new Uint8Array(0);
}
function encode47(header) {
  if (header.pax == null) {
    const encoded = encode46(header);
    if (encoded != null) {
      return encoded;
    }
  }
  return encodePax2(header);
}
function encodePax2(header) {
  const paxHeader = encodePax(header);
  const newHeader = {
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname,
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  return new Uint8ArrayList(encode46(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), encode46({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)).subarray();
}
function pack() {
  return async function* (source) {
    for await (let { header: partialHeader, body } of source) {
      const header = {
        ...partialHeader,
        size: partialHeader.type === "symlink" ? 0 : partialHeader.size ?? 0,
        type: partialHeader.type ?? modeToType(partialHeader.mode),
        mode: partialHeader.mode ?? (partialHeader.type === "directory" ? DMODE : FMODE),
        uid: partialHeader.uid ?? 0,
        gid: partialHeader.gid ?? 0,
        mtime: partialHeader.mtime ?? new Date()
      };
      if (typeof body === "string") {
        body = fromString16(body);
      }
      if (body instanceof Uint8Array || isUint8ArrayList(body)) {
        header.size = body.length;
        yield encode47(header);
        yield isUint8ArrayList(body) ? body.subarray() : body;
        yield getPadding(header.size);
        continue;
      }
      if (header.type === "symlink" && header.linkname == null) {
        if (body == null) {
          throw new Error("type was symlink but no linkname or body specified");
        }
        header.linkname = toString16(await toBuffer(body));
        yield encode47(header);
        continue;
      }
      yield encode47(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        continue;
      }
      let written = 0;
      for await (const chunk of body ?? []) {
        written += chunk.length;
        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;
      }
      if (written !== header.size) {
        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);
      }
      yield getPadding(header.size);
    }
    yield END_OF_TAR;
  };
}

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf2) {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value2, length23) => {
  if (s.bi_valid > Buf_size - length23) {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value2 >> Buf_size - s.bi_valid;
    s.bi_valid += length23 - Buf_size;
  } else {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    s.bi_valid += length23;
  }
};
var send_code = (s, c, tree2) => {
  send_bits(s, tree2[c * 2], tree2[c * 2 + 1]);
};
var bi_reverse = (code22, len) => {
  let res = 0;
  do {
    res |= code22 & 1;
    code22 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base30 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits2;
  let xbits;
  let f;
  let overflow = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s.bl_count[bits2] = 0;
  }
  tree2[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits2 = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow++;
    }
    tree2[n * 2 + 1] = bits2;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits2]++;
    xbits = 0;
    if (n >= base30) {
      xbits = extra[n - base30];
    }
    f = tree2[n * 2];
    s.opt_len += f * (bits2 + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s.bl_count[bits2] === 0) {
      bits2--;
    }
    s.bl_count[bits2]--;
    s.bl_count[bits2 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n = s.bl_count[bits2];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree2[m * 2 + 1] !== bits2) {
        s.opt_len += (bits2 - tree2[m * 2 + 1]) * tree2[m * 2];
        tree2[m * 2 + 1] = bits2;
      }
      n--;
    }
  }
};
var gen_codes = (tree2, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code22 = 0;
  let bits2;
  let n;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    code22 = code22 + bl_count[bits2 - 1] << 1;
    next_code[bits2] = code22;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree2[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree2[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits2;
  let length23;
  let code22;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length23 = 0;
  for (code22 = 0; code22 < LENGTH_CODES$1 - 1; code22++) {
    base_length[code22] = length23;
    for (n = 0; n < 1 << extra_lbits[code22]; n++) {
      _length_code[length23++] = code22;
    }
  }
  _length_code[length23 - 1] = code22;
  dist = 0;
  for (code22 = 0; code22 < 16; code22++) {
    base_dist[code22] = dist;
    for (n = 0; n < 1 << extra_dbits[code22]; n++) {
      _dist_code[dist++] = code22;
    }
  }
  dist >>= 7;
  for (; code22 < D_CODES$1; code22++) {
    base_dist[code22] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code22] - 7; n++) {
      _dist_code[256 + dist++] = code22;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree2, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree2, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree2, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree2, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code22;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code22 = _length_code[lc];
        send_code(s, code22 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code22];
        if (extra !== 0) {
          lc -= base_length[code22];
          send_bits(s, lc, extra);
        }
        dist--;
        code22 = d_code(dist);
        send_code(s, code22, dtree);
        extra = extra_dbits[code22];
        if (extra !== 0) {
          dist -= base_dist[code22];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree2[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree2[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree2[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree2, n);
  }
  node = elems;
  do {
    n = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree2, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree2[node * 2] = tree2[n * 2] + tree2[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree2[n * 2 + 1] = tree2[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree2, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree2, max_code, s.bl_count);
};
var scan_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree2[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf2, stored_len, last14) => {
  send_bits(s, (STORED_BLOCK << 1) + (last14 ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf2, buf2 + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf2, stored_len, last14) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
    _tr_stored_block$1(s, buf2, stored_len, last14);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last14 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last14 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last14) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf2, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf2[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table2 = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n] = c;
  }
  return table2;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf2, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t[(crc ^ buf2[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf2) => {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev2, data) => (prev2 << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last14) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last14);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf2, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf2.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf2, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf2, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev2 = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush3) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last14 = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush3 !== Z_FINISH$3 || flush3 === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last14 = flush3 === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last14);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last14 === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last14) {
    return BS_FINISH_DONE;
  }
  if (flush3 !== Z_NO_FLUSH$2 && flush3 !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush3 === Z_FINISH$3) && flush3 !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last14 = flush3 === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last14);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last14 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush3) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush3) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush3) => {
  let bflush;
  let prev2;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev2 = _win[scan];
      if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush3) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush3 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush3) => {
  if (deflateStateCheck(strm) || flush3 > Z_BLOCK$1 || flush3 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush3 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush3;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush3) <= rank(old_flush) && flush3 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush3 !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush3) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush3) : s.strategy === Z_RLE ? deflate_rle(s, flush3) : configuration_table[s.level].func(s, flush3);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush3 === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush3 !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush3 === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush3 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l = chunks.length; i2 < l; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l = chunks.length; i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf2, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf2 = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf2[i2++] = c;
    } else if (c < 2048) {
      buf2[i2++] = 192 | c >>> 6;
      buf2[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf2[i2++] = 224 | c >>> 12;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    } else {
      buf2[i2++] = 240 | c >>> 18;
      buf2[i2++] = 128 | c >>> 12 & 63;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    }
  }
  return buf2;
};
var buf2binstring = (buf2, len) => {
  if (len < 65534) {
    if (buf2.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf2.length === len ? buf2 : buf2.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf2[i2]);
  }
  return result;
};
var buf2string = (buf2, max) => {
  const len = max || buf2.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf2.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c = buf2[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf2[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf2, max) => {
  max = max || buf2.length;
  if (max > buf2.length) {
    max = buf2.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf2[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf2[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last14;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from33;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last14 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from33 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from33 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from33++];
                        } while (--op);
                        from33 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from33 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from33++];
                        } while (--op);
                        from33 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from33++];
                          } while (--op);
                          from33 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from33 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from33++];
                        } while (--op);
                        from33 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from33++];
                      output[_out++] = from_source[from33++];
                      output[_out++] = from_source[from33++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from33++];
                      if (len > 1) {
                        output[_out++] = from_source[from33++];
                      }
                    }
                  } else {
                    from33 = _out - dist;
                    do {
                      output[_out++] = output[from33++];
                      output[_out++] = output[from33++];
                      output[_out++] = output[from33++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from33++];
                      if (len > 1) {
                        output[_out++] = output[from33++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last14 && _out < end);
  len = bits2 >> 3;
  _in -= len;
  bits2 -= len << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last14 ? 5 + (last14 - _in) : 5 - (_in - last14);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits2;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes6, table2, table_index, work, opts) => {
  const bits2 = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base30 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes6; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits2;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes6; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base30 = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base30 = lbase;
    extra = lext;
    match = 257;
  } else {
    base30 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base30[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE2 = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src18, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src18.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src18.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src18.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush3) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from33;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    next + copy
                  ),
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush3 === Z_BLOCK || flush3 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush3 === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n = here_bits + 7;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from33 = state.wsize - copy;
            } else {
              from33 = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from33 = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from33++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE2;
        case DONE2:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush3 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush3 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString17 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString17.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString17.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

// node_modules/ipfs-core/src/components/get.js
var import_it_map6 = __toESM(require_it_map(), 1);
var import_it_to_buffer2 = __toESM(require_it_to_buffer(), 1);
var DEFAULT_COMPRESSION_LEVEL = 6;
function createGet2({ repo, preload: preload2 }) {
  async function* get3(ipfsPath3, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw (0, import_err_code39.default)(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = normalizeCidPath(ipfsPath3).split("/");
      } catch (err2) {
        throw (0, import_err_code39.default)(err2, "ERR_INVALID_PATH");
      }
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(ipfsPath3) || ipfsPath3;
    const file = await exporter2(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file" || file.type === "raw") {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push(
          [{
            header: {
              name: file.path,
              mode: file.type === "file" && file.unixfs.mode,
              mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
              size: file.size,
              type: "file"
            },
            body: file.content()
          }],
          pack(),
          (source) => (0, import_it_map6.default)(source, (buf2) => buf2.slice())
        );
      } else {
        args.push(
          file.content
        );
      }
      if (options.compress) {
        args.push(
          async function* (source) {
            const buf2 = await (0, import_it_to_buffer2.default)(source);
            yield pako.gzip(buf2, {
              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
            });
          }
        );
      }
      yield* pipe(...args);
      return;
    }
    if (file.type === "directory") {
      const args = [
        recursive(ipfsPathOrCid, repo.blocks, options),
        async function* (source) {
          for await (const entry of source) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === "file") {
              output.header.type = "file";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
              output.body = entry.content();
            } else if (entry.type === "raw") {
              output.header.type = "file";
              output.body = entry.content();
            } else if (entry.type === "directory") {
              output.header.type = "directory";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
            } else {
              throw (0, import_err_code39.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
            }
            yield output;
          }
        },
        pack(),
        (source) => (0, import_it_map6.default)(source, (buf2) => buf2.slice())
      ];
      if (options.compress) {
        if (!options.archive) {
          throw (0, import_err_code39.default)(new Error("file is not regular"), "ERR_INVALID_PATH");
        }
        if (options.compress) {
          args.push(
            async function* (source) {
              const buf2 = await (0, import_it_to_buffer2.default)(source);
              yield pako.gzip(buf2, {
                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
              });
            }
          );
        }
      }
      yield* pipe(...args);
      return;
    }
    throw (0, import_err_code39.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
  }
  return withTimeoutOption(get3);
}

// node_modules/ipfs-core/src/components/ls.js
var import_err_code40 = __toESM(require_err_code(), 1);
function createLs2({ repo, preload: preload2 }) {
  async function* ls(ipfsPath3, options = {}) {
    const legacyPath = normalizeCidPath(ipfsPath3);
    const pathComponents = legacyPath.split("/");
    if (options.preload !== false) {
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(legacyPath) || legacyPath;
    const file = await exporter2(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file") {
      yield mapFile(file);
      return;
    }
    if (file.type === "directory") {
      for await (const child of file.content()) {
        yield mapFile(child);
      }
      return;
    }
    throw (0, import_err_code40.default)(new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
  }
  return withTimeoutOption(ls);
}

// node_modules/ipfs-core/src/components/root.js
var RootAPI = class {
  constructor({ preload: preload2, repo, hashers, options }) {
    const addAll = createAddAll2({
      preload: preload2,
      repo,
      options,
      hashers
    });
    this.addAll = addAll;
    this.add = createAdd3({ addAll });
    this.cat = createCat({ repo, preload: preload2 });
    this.get = createGet2({ repo, preload: preload2 });
    this.ls = createLs2({ repo, preload: preload2 });
  }
};

// node_modules/ipfs-core/src/version.js
var ipfsCore = "0.16.1";
var commit = "d1f1e75b2060c5c2e64d133a7a6bbabd2641e5ef";
var interfaceIpfsCore = "^0.156.1";

// node_modules/ipfs-core/src/components/version.js
function createVersion({ repo }) {
  async function version4(_options = {}) {
    const repoVersion2 = await repo.version.get();
    return {
      version: ipfsCore,
      commit,
      repo: `${repoVersion2}`,
      "ipfs-core": ipfsCore,
      "interface-ipfs-core": interfaceIpfsCore
    };
  }
  return withTimeoutOption(version4);
}

// node_modules/ipfs-core/src/components/id.js
var import_err_code41 = __toESM(require_err_code(), 1);
var log16 = logger("ipfs:components:id");
function createId({ peerId, network }) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new NotStartedError();
      }
      if (peerId.publicKey == null) {
        throw (0, import_err_code41.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
      }
      return {
        id: peerId,
        publicKey: toString11(peerId.publicKey, "base64pad"),
        addresses: [],
        agentVersion: `js-ipfs/${ipfsCore}`,
        protocolVersion: "9000",
        protocols: []
      };
    }
    const { libp2p } = net;
    const peerIdToId = options.peerId ? options.peerId : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString11(peer.metadata.get("AgentVersion") || new Uint8Array());
    const protocolVersion = toString11(peer.metadata.get("ProtocolVersion") || new Uint8Array());
    const idStr = peer.id.toString();
    const publicKeyStr = peer.publicKey ? toString11(peer.publicKey, "base64pad") : "";
    return {
      id: peerIdToId,
      publicKey: publicKeyStr,
      addresses: (peer.addresses || []).map((ma) => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${idStr}`)) {
          return str;
        }
        return `${str}/p2p/${idStr}`;
      }).sort().map((ma) => multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);
  if (publicKey == null) {
    try {
      publicKey = await libp2p.getPublicKey(peerId, options);
    } catch (err2) {
      log16.error("Could not load public key for", peerId.toString(), err2);
    }
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || /* @__PURE__ */ new Map(),
    addresses: peer.addresses.map((addr) => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  if (libp2p.dht == null) {
    throw (0, import_err_code41.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
  }
  for await (const event of libp2p.dht.findPeer(peerId, options)) {
    if (event.name === "FINAL_PEER") {
      break;
    }
  }
  const peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    throw (0, import_err_code41.default)(new Error("Could not find peer"), "ERR_NOT_FOUND");
  }
  return peer;
}

// node_modules/just-safe-set/index.mjs
var objectSafeSet = set;
function set(obj, propsArg, value2) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value2;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}

// node_modules/ipfs-core/src/components/config/profiles.js
var profiles = {
  server: {
    description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      config2.Swarm = {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      };
      return config2;
    }
  },
  "local-discovery": {
    description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", true);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", true);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  test: {
    description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
      objectSafeSet(config2, "Addresses.Delegates", []);
      objectSafeSet(config2, "Bootstrap", []);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      });
      return config2;
    }
  },
  "default-networking": {
    description: "Restores default network settings. Inverse profile of the `test` profile.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API);
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
      objectSafeSet(config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
      objectSafeSet(config2, "Bootstrap", defaultConfig.Bootstrap);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  lowpower: {
    description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
    transform: (config2) => {
      const Swarm = config2.Swarm || {};
      const ConnMgr = Swarm.ConnMgr || {};
      ConnMgr.LowWater = 20;
      ConnMgr.HighWater = 40;
      Swarm.ConnMgr = ConnMgr;
      config2.Swarm = Swarm;
      return config2;
    }
  },
  "default-power": {
    description: 'Inverse of "lowpower" profile.',
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      config2.Swarm = defaultConfig.Swarm;
      return config2;
    }
  }
};

// node_modules/ipfs-core/src/components/config/index.js
var log17 = logger("ipfs:core:config");
function createConfig({ repo }) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get3),
    set: withTimeoutOption(set2),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get3(key, options) {
    if (!key) {
      return Promise.reject(new Error("key argument is required"));
    }
    return repo.config.get(key, options);
  }
  async function set2(key, value2, options) {
    return repo.config.set(key, value2, options);
  }
  async function replace(value2, options) {
    return repo.config.replace(value2, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const { dryRun } = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${profileName}' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return { original: oldCfg, updated: newCfg };
    } catch (err2) {
      log17(err2);
      throw new Error(`Could not apply profile '${profileName}' to config: ${err2.message}`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map((name22) => ({
    name: name22,
    description: profiles[name22].description
  }));
}

// node_modules/multiformats/esm/src/block.js
var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links2 = function* (source, base30) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value2] of Object.entries(source)) {
    const path2 = [
      ...base30,
      key
    ];
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (const [index, element] of value2.entries()) {
          const elementPath = [
            ...path2,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links2(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value2);
        if (cid) {
          yield [
            path2.join("/"),
            cid
          ];
        } else {
          yield* links2(value2, path2);
        }
      }
    }
  }
};
var tree = function* (source, base30) {
  if (source == null)
    return;
  for (const [key, value2] of Object.entries(source)) {
    const path2 = [
      ...base30,
      key
    ];
    yield path2.join("/");
    if (value2 != null && !(value2 instanceof Uint8Array) && typeof value2 === "object" && !CID.asCID(value2)) {
      if (Array.isArray(value2)) {
        for (const [index, element] of value2.entries()) {
          const elementPath = [
            ...path2,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value2, path2);
      }
    }
  }
};
var get = (source, path2) => {
  let node = source;
  for (const [index, key] of path2.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path2.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path2.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid, bytes: bytes2, value: value2 }) {
    if (!cid || !bytes2 || typeof value2 === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value2;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links2(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path2 = "/") {
    return get(this.value, path2.split("/").filter(Boolean));
  }
};
var createUnsafe = ({
  bytes: bytes2,
  cid,
  value: maybeValue,
  codec
}) => {
  const value2 = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value2 === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    cid,
    bytes: bytes2,
    value: value2
  });
};

// node_modules/@ipld/car/esm/lib/encoder.js
var import_varint13 = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode6({
    version: 1,
    roots
  });
  const varintBytes = import_varint13.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer5) {
  return {
    async setRoots(roots) {
      const bytes2 = createHeader(roots);
      await writer5.write(bytes2);
    },
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer5.write(new Uint8Array(import_varint13.default.encode(cid.bytes.length + bytes2.length)));
      await writer5.write(cid.bytes);
      if (bytes2.length) {
        await writer5.write(bytes2);
      }
    },
    async close() {
      await writer5.end();
    }
  };
}

// node_modules/@ipld/car/esm/lib/iterator-channel.js
function noop() {
}
function create14() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve7) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve7();
        };
      });
    }
    return drainer;
  };
  const writer5 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve7) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve7(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer: writer5,
    iterator
  };
}

// node_modules/@ipld/car/esm/lib/decoder.js
var import_varint14 = __toESM(require_varint(), 1);

// node_modules/@ipld/car/esm/lib/header-validator.js
var Kinds = {
  Null: (obj) => obj === null,
  Int: (obj) => Number.isInteger(obj),
  Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
  String: (obj) => typeof obj === "string",
  Bool: (obj) => typeof obj === "boolean",
  Bytes: (obj) => obj instanceof Uint8Array,
  Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
  List: (obj) => Array.isArray(obj),
  Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
};
var Types = {
  Int: Kinds.Int,
  "CarHeader > version": (obj) => Types.Int(obj),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
  "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
  CarHeader: (obj) => {
    const keys = obj && Object.keys(obj);
    return Kinds.Map(obj) && ["version"].every((k) => keys.includes(k)) && Object.entries(obj).every(([name22, value2]) => Types["CarHeader > " + name22] && Types["CarHeader > " + name22](value2));
  }
};
var CarHeader = Types.CarHeader;

// node_modules/@ipld/car/esm/lib/decoder.js
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
var V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
async function readVarint(reader6) {
  const bytes2 = await reader6.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i2 = import_varint14.default.decode(bytes2);
  reader6.seek(import_varint14.default.decode.bytes);
  return i2;
}
async function readV2Header(reader6) {
  const bytes2 = await reader6.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader6.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader(reader6, strictVersion) {
  const length23 = await readVarint(reader6);
  if (length23 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader6.exactly(length23);
  reader6.seek(length23);
  const block = decode8(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader6);
  reader6.seek(v2Header.dataOffset - reader6.pos);
  const v1Header = await readHeader(reader6, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader6) {
  const bytes2 = await reader6.upTo(8);
  import_varint14.default.decode(bytes2);
  const codeLength = import_varint14.default.decode.bytes;
  const length23 = import_varint14.default.decode(bytes2.subarray(import_varint14.default.decode.bytes));
  const lengthLength = import_varint14.default.decode.bytes;
  const mhLength = codeLength + lengthLength + length23;
  const multihash = await reader6.exactly(mhLength);
  reader6.seek(mhLength);
  return multihash;
}
async function readCid(reader6) {
  const first10 = await reader6.exactly(2);
  if (first10[0] === CIDV0_BYTES.SHA2_256 && first10[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader6.exactly(34);
    reader6.seek(34);
    const multihash2 = decode4(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version4 = await readVarint(reader6);
  if (version4 !== 1) {
    throw new Error(`Unexpected CID version (${version4})`);
  }
  const codec = await readVarint(reader6);
  const bytes2 = await readMultihash(reader6);
  const multihash = decode4(bytes2);
  return CID.create(version4, codec, multihash);
}
async function readBlockHead(reader6) {
  const start = reader6.pos;
  let length23 = await readVarint(reader6);
  if (length23 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length23 += reader6.pos - start;
  const cid = await readCid(reader6);
  const blockLength = length23 - Number(reader6.pos - start);
  return {
    cid,
    length: length23,
    blockLength
  };
}
async function readBlock(reader6) {
  const { cid, blockLength } = await readBlockHead(reader6);
  const bytes2 = await reader6.exactly(blockLength);
  reader6.seek(blockLength);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader6) {
  const offset = reader6.pos;
  const { cid, length: length23, blockLength } = await readBlockHead(reader6);
  const index = {
    cid,
    length: length23,
    blockLength,
    offset,
    blockOffset: reader6.pos
  };
  reader6.seek(index.blockLength);
  return index;
}
function createDecoder(reader6) {
  const headerPromise = (async () => {
    const header = await readHeader(reader6);
    if (header.version === 2) {
      const v1length = reader6.pos - header.dataOffset;
      reader6 = limitReader(reader6, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader6.upTo(8)).length > 0) {
        yield await readBlock(reader6);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader6.upTo(8)).length > 0) {
        yield await readBlockIndex(reader6);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length23) {
      return bytes2.subarray(pos, pos + Math.min(length23, bytes2.length - pos));
    },
    async exactly(length23) {
      if (length23 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length23);
    },
    seek(length23) {
      pos += length23;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read19 = async (length23) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length23) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length23) {
      if (currentChunk.length - offset < length23) {
        await read19(length23);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length23));
    },
    async exactly(length23) {
      if (currentChunk.length - offset < length23) {
        await read19(length23);
      }
      if (currentChunk.length - offset < length23) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length23);
    },
    seek(length23) {
      pos += length23;
      offset += length23;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader6, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length23) {
      let bytes2 = await reader6.upTo(length23);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length23) {
      const bytes2 = await reader6.exactly(length23);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length23) {
      bytesRead += length23;
      reader6.seek(length23);
    },
    get pos() {
      return reader6.pos;
    }
  };
}

// node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class {
  constructor(roots, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots);
    this._ended = false;
  }
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer5 = new CarWriter(roots, encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer: writer5,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer5 = new CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer: writer5,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots) {
    const reader6 = bytesReader(bytes2);
    await readHeader(reader6);
    const newHeader = createHeader(roots);
    if (Number(reader6.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader6.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create14();
  const { writer: writer5, iterator } = iw;
  const encoder2 = createEncoder(writer5);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// node_modules/multiformats/esm/src/traversal.js
var walk = async ({ cid, load, seen }) => {
  seen = seen || /* @__PURE__ */ new Set();
  const b58Cid = cid.toString(base58btc2);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await load(cid);
  seen.add(b58Cid);
  if (block === null) {
    return;
  }
  for (const [, cid2] of block.links()) {
    await walk({
      cid: cid2,
      load,
      seen
    });
  }
};

// node_modules/ipfs-core/src/components/dag/export.js
var log18 = logger("ipfs:components:dag:import");
var NO_LINKS_CODECS = [
  code6,
  code7
];
function createExport({ repo, preload: preload2, codecs: codecs2 }) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload2(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${root}`);
    }
    log18(`Exporting ${cid} as car`);
    const { writer: writer5, out } = await CarWriter.create([cid]);
    let err2 = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer5, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs2);
        await walk({ cid, load });
      } catch (e) {
        err2 = e;
      } finally {
        writer5.close();
      }
    })();
    for await (const chunk of out) {
      if (err2) {
        break;
      }
      yield chunk;
    }
    if (err2) {
      throw err2;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer5, options, codecs2) {
  return async (cid) => {
    const codec = await codecs2.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);
    }
    const bytes2 = await repo.blocks.get(cid, options);
    log18(`Adding block ${cid} to car`);
    await writer5.put({ cid, bytes: bytes2 });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({ bytes: bytes2, cid, codec });
  };
}

// node_modules/ipfs-core/src/components/dag/get.js
var import_it_first = __toESM(require_it_first(), 1);
var import_it_last5 = __toESM(require_it_last(), 1);
var import_err_code42 = __toESM(require_err_code(), 1);
function createGet3({ codecs: codecs2, repo, preload: preload2 }) {
  const get3 = async function get4(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    if (options.path) {
      const entry = options.localResolve ? await (0, import_it_first.default)(resolve(cid, options.path, codecs2, repo, options)) : await (0, import_it_last5.default)(resolve(cid, options.path, codecs2, repo, options));
      const result = entry;
      if (!result) {
        throw (0, import_err_code42.default)(new Error("Not found"), "ERR_NOT_FOUND");
      }
      return result;
    }
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    return {
      value: node,
      remainderPath: ""
    };
  };
  return withTimeoutOption(get3);
}

// node_modules/@ipld/car/esm/lib/iterator.js
var CarIteratorBase = class {
  constructor(version4, roots, iterable) {
    this._version = version4;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
};
var CarBlockIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(bytes2) {
    const { version: version4, roots, iterator } = await fromBytes2(bytes2);
    return new CarBlockIterator(version4, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version4, roots, iterator } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version4, roots, iterator);
  }
};
var CarCIDIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      async next() {
        const next = await iterable.next();
        if (next.done) {
          return next;
        }
        return {
          done: false,
          value: next.value.cid
        };
      }
    };
  }
  static async fromBytes(bytes2) {
    const { version: version4, roots, iterator } = await fromBytes2(bytes2);
    return new CarCIDIterator(version4, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version4, roots, iterator } = await fromIterable(asyncIterable);
    return new CarCIDIterator(version4, roots, iterator);
  }
};
async function fromBytes2(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader6) {
  const decoder = createDecoder(reader6);
  const { version: version4, roots } = await decoder.header();
  return {
    version: version4,
    roots,
    iterator: decoder.blocks()
  };
}

// node_modules/ipfs-core/src/components/dag/import.js
var import_it_peekable4 = __toESM(require_it_peekable(), 1);
var import_it_drain5 = __toESM(require_it_drain(), 1);
var import_it_map7 = __toESM(require_it_map(), 1);
var log19 = logger("ipfs:components:dag:import");
function createImport({ repo }) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = { signal: options.signal, timeout: options.timeout };
      const peekable = (0, import_it_peekable4.default)(sources);
      const { value: value2, done } = await peekable.peek();
      if (done) {
        return;
      }
      if (value2) {
        peekable.push(value2);
      }
      let cars;
      if (value2 instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots) {
            let pinErrorMsg = "";
            try {
              if (await repo.blocks.has(cid)) {
                log19(`Pinning root ${cid}`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = "blockstore: block not found";
              }
            } catch (err2) {
              pinErrorMsg = err2.message;
            }
            yield { root: { cid, pinErrorMsg } };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(dagImport);
}
async function importCar(repo, options, source) {
  const reader6 = await CarBlockIterator.fromIterable(source);
  const roots = await reader6.getRoots();
  await (0, import_it_drain5.default)(
    repo.blocks.putMany(
      (0, import_it_map7.default)(reader6, ({ cid: key, bytes: value2 }) => {
        log19(`Import block ${key}`);
        return { key, value: value2 };
      }),
      { signal: options.signal }
    )
  );
  return roots;
}

// node_modules/ipfs-core/src/components/dag/put.js
function createPut2({ repo, codecs: codecs2, hashers, preload: preload2 }) {
  async function put(dagNode, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const storeCodec = await codecs2.getCodec(options.storeCodec || "dag-cbor");
      if (!storeCodec) {
        throw new Error(`Unknown storeCodec ${options.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      }
      if (options.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        const inputCodec = await codecs2.getCodec(options.inputCodec);
        if (!inputCodec) {
          throw new Error(`Unknown inputCodec ${options.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        }
        dagNode = inputCodec.decode(dagNode);
      }
      const cidVersion = options.version != null ? options.version : 1;
      const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
      if (!hasher) {
        throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      }
      const buf2 = storeCodec.encode(dagNode);
      const hash3 = await hasher.digest(buf2);
      const cid = CID.create(cidVersion, storeCodec.code, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.pin) {
        await repo.pins.pinRecursively(cid);
      }
      if (options.preload !== false) {
        preload2(cid);
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/src/components/dag/resolve.js
function createResolve3({ repo, codecs: codecs2, preload: preload2 }) {
  async function dagResolve(ipfsPath3, options = {}) {
    const {
      cid
    } = toCidAndPath(ipfsPath3);
    if (options.preload !== false) {
      preload2(cid);
    }
    return resolvePath(repo, codecs2, ipfsPath3, options);
  }
  return withTimeoutOption(dagResolve);
}

// node_modules/ipfs-core/src/components/dag/index.js
var DagAPI = class {
  constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
    this.export = createExport({ repo, preload: preload2, codecs: codecs2 });
    this.get = createGet3({ codecs: codecs2, repo, preload: preload2 });
    this.import = createImport({ repo });
    this.resolve = createResolve3({ repo, codecs: codecs2, preload: preload2 });
    this.put = createPut2({ repo, codecs: codecs2, hashers, preload: preload2 });
  }
};

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var reduceValue = (_, v) => v;
var tcpUri = (str, port, parts2, opts) => {
  if (opts != null && opts.assumeHttp === false)
    return `tcp://${str}:${port}`;
  let protocol4 = "tcp";
  let explicitPort = `:${port}`;
  const last14 = parts2[parts2.length - 1];
  if (last14.protocol === "tcp") {
    protocol4 = port === "443" ? "https" : "http";
    explicitPort = port === "443" || port === "80" ? "" : explicitPort;
  }
  return `${protocol4}://${str}${explicitPort}`;
};
var Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i2, parts2) => parts2.length === 1 && parts2[0].protocol === "ip6" ? content : `[${content}]`,
  tcp: (str, content, i2, parts2, opts) => parts2.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts2, opts),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: (str) => `http://${str}`,
  https: (str) => `https://${str}`,
  ws: (str) => `ws://${str}`,
  wss: (str) => `wss://${str}`,
  "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
  "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
  "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts2 = ma.toString().split("/").slice(1);
  return ma.tuples().map((tuple) => ({
    protocol: parts2.shift() ?? "",
    content: tuple[1] != null ? parts2.shift() ?? "" : ""
  })).reduce((str, part, i2, parts3) => {
    const reduce2 = Reducers[part.protocol];
    if (reduce2 == null) {
      throw new Error(`Unsupported protocol ${part.protocol}`);
    }
    return reduce2(str, part.content, i2, parts3, opts);
  }, "");
}

// node_modules/array-shuffle/index.js
function arrayShuffle(array) {
  if (!Array.isArray(array)) {
    throw new TypeError(`Expected an array, got ${typeof array}`);
  }
  array = [...array];
  for (let index = array.length - 1; index > 0; index--) {
    const newIndex = Math.floor(Math.random() * (index + 1));
    [array[index], array[newIndex]] = [array[newIndex], array[index]];
  }
  return array;
}

// node_modules/ipfs-core-config/src/preload.browser.js
var import_http2 = __toESM(require_http());
var log20 = logger("ipfs:preload");
var Queue2 = PQueue.default ? PQueue.default : PQueue;
var httpQueue2 = new Queue2({ concurrency: 4 });
function preload(url2, options = {}) {
  log20(url2);
  return httpQueue2.add(async () => {
    const res = await import_http2.default.post(url2, { signal: options.signal });
    const reader6 = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader6.read();
        if (done)
          return;
      }
    } finally {
      reader6.releaseLock();
    }
  });
}

// node_modules/ipfs-core/src/preload.js
var import_hashlru3 = __toESM(require_hashlru(), 1);
var log21 = logger("ipfs:preload");
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1e3;
  if (!options.enabled || !options.addresses.length) {
    log21("preload disabled");
    const api2 = () => {
    };
    return Object.assign(api2, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map((str) => multiaddrToUri(str));
  const cache19 = (0, import_hashlru3.default)(options.cache);
  const api = async (cid) => {
    try {
      if (stopped) {
        throw new Error(`preload ${cid} but preloader is not started`);
      }
      const path2 = cid.toString();
      if (cache19.has(path2)) {
        return;
      }
      cache19.set(path2, true);
      const fallbackApiUris = arrayShuffle(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${path2}`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path2)}`, { signal: controller.signal });
          success = true;
        } catch (err2) {
          if (err2.type !== "aborted")
            log21.error(err2);
        } finally {
          requests = requests.filter((r) => r !== controller);
        }
        if (success)
          break;
      }
      log21(`${success ? "" : "un"}successfully preloaded ${path2} in ${Date.now() - now}ms`);
    } catch (err2) {
      log21.error(err2);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log21(`aborting ${requests.length} pending preload request(s)`);
    requests.forEach((r) => r.abort());
    requests = [];
  };
  return api;
}

// node_modules/ipfs-core/src/mfs-preload.js
var log22 = logger("ipfs:mfs-preload");
function createMfsPreloader({ preload: preload2, files, options = {} }) {
  options.interval = options.interval || 30 * 1e3;
  if (!options.enabled) {
    log22("MFS preload disabled");
    const noop5 = async () => {
    };
    return { start: noop5, stop: noop5 };
  }
  let rootCid = "";
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat("/");
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log22(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
        await preload2(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err2) {
      log22.error("failed to preload MFS root", err2);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    async start() {
      const stats = await files.stat("/");
      rootCid = stats.cid.toString();
      log22(`monitoring MFS root ${stats.cid}`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    stop() {
      clearTimeout(timeoutId);
    }
  };
}

// node_modules/p-timeout/index.js
var TimeoutError3 = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "TimeoutError";
  }
};
var AbortError4 = class extends Error {
  constructor(message6) {
    super();
    this.name = "AbortError";
    this.message = message6;
  }
};
var getDOMException2 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError4(errorMessage) : new DOMException(errorMessage);
var getAbortedReason2 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException2(reason);
};
function pTimeout2(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message6,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason2(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason2(signal));
      });
    }
    const timeoutError = new TimeoutError3();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message6 === false) {
        resolve7();
      } else if (message6 instanceof Error) {
        reject(message6);
      } else {
        timeoutError.message = message6 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default = observable;

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve7) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve7();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name22, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name22
    });
    return await new Promise((resolve7) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve7(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name22
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions2 = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions2, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name22) => makeWorkerLockRequest(name22, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name22) => makeWorkerLockRequest(name22, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve7) => {
    res = resolve7;
  });
  void queue.add(async () => await pTimeout2((async () => {
    return await new Promise((resolve7) => {
      res(() => {
        resolve7();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name22, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name22, options),
      writeLock: implementation.writeLock(name22, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions3 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions3, options);
  if (implementation == null) {
    implementation = browser_default(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/ipfs-core/src/components/files/utils/create-lock.js
var lock;
function createLock(repoOwner = false) {
  if (lock) {
    return lock;
  }
  const mutex = createMortice({
    singleProcess: repoOwner
  });
  lock = {
    readLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.readLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    },
    writeLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.writeLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    }
  };
  return lock;
}

// node_modules/ipfs-core/src/components/files/utils/with-mfs-root.js
var import_err_code43 = __toESM(require_err_code(), 1);
var log23 = logger("ipfs:mfs:utils:with-mfs-root");
async function loadMfsRoot(context, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code43.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  await context.repo.datastore.open();
  let cid;
  try {
    const buf2 = await context.repo.datastore.get(MFS_ROOT_KEY);
    cid = CID.decode(buf2);
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
    log23("Creating new MFS root");
    const buf2 = encode4({
      Data: new UnixFS({ type: "directory" }).marshal(),
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    cid = CID.createV0(hash3);
    await context.repo.blocks.put(cid, buf2);
    if (options && options.signal && options.signal.aborted) {
      throw (0, import_err_code43.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
    }
    await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  }
  log23(`Loaded MFS root /ipfs/${cid}`);
  return cid;
}

// node_modules/ipfs-core/src/components/files/utils/to-path-components.js
function toPathComponents3(path2 = "") {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
}

// node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js
var import_err_code44 = __toESM(require_err_code(), 1);
var IPFS_PREFIX2 = "ipfs";
var toMfsPath = async (context, path2, options) => {
  const root = await loadMfsRoot(context, options);
  let output = {
    entryType: "file"
  };
  let ipfsPath3 = "";
  if (CID.asCID(path2)) {
    ipfsPath3 = `/ipfs/${path2}`;
  } else {
    ipfsPath3 = path2.toString();
  }
  ipfsPath3 = ipfsPath3.trim();
  ipfsPath3 = ipfsPath3.replace(/(\/\/+)/g, "/");
  if (ipfsPath3.endsWith("/") && ipfsPath3.length > 1) {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  if (!ipfsPath3) {
    throw (0, import_err_code44.default)(new Error("paths must not be empty"), "ERR_NO_PATH");
  }
  if (ipfsPath3.substring(0, 1) !== "/") {
    throw (0, import_err_code44.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (ipfsPath3.substring(ipfsPath3.length - 1) === "/") {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  const pathComponents = toPathComponents3(ipfsPath3);
  if (pathComponents[0] === IPFS_PREFIX2) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${pathComponents.join("/")}`;
    } else {
      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    }
    output = {
      type: "ipfs",
      depth: pathComponents.length - 2,
      entryType: "file",
      mfsPath: `/${pathComponents.join("/")}`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${IPFS_PREFIX2}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
    const mfsDirectory = `/${IPFS_PREFIX2}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    output = {
      type: "mfs",
      depth: pathComponents.length,
      entryType: "file",
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
  try {
    const res = await exporter2(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${res.path}`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
      output.unixfs = res.unixfs;
    }
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};

// node_modules/ipfs-core/src/components/files/stat.js
var import_err_code45 = __toESM(require_err_code(), 1);
var mergeOptions4 = merge_options_default.bind({ ignoreUndefined: true });
var log24 = logger("ipfs:mfs:stat");
var defaultOptions4 = {
  withLocal: false
};
function createStat3(context) {
  async function mfsStat(path2, options = {}) {
    options = mergeOptions4(defaultOptions4, options);
    log24(`Fetching stats for ${path2}`);
    const {
      type,
      cid,
      mfsPath
    } = await toMfsPath(context, path2, options);
    const exportPath = type === "ipfs" && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter2(exportPath, context.repo.blocks);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code45.default)(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
      }
      throw err2;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${file.cid.code}`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
var statters = {
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  file: (file) => {
    const stat = {
      cid: file.cid,
      type: "file",
      size: file.unixfs.fileSize(),
      cumulativeSize: encode4(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: (file) => {
    const stat = {
      cid: file.cid,
      type: "directory",
      size: 0,
      cumulativeSize: encode4(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: "file",
      blocks: 0,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  identity: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  }
};

// node_modules/ipfs-core/src/components/files/chmod.js
var import_err_code52 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/src/components/files/utils/to-trail.js
var log25 = logger("ipfs:mfs:utils:to-trail");
async function toTrail(context, path2) {
  log25(`Creating trail for path ${path2}`);
  const output = [];
  for await (const fsEntry of walkPath(path2, context.repo.blocks)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.size,
      type: fsEntry.type
    });
  }
  return output;
}

// node_modules/ipfs-core/src/components/files/utils/persist.js
var persist2 = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};

// node_modules/ipfs-core/src/components/files/utils/hamt-constants.js
var hamtHashCode = murmur3128.code;
var hamtBucketBits = 8;
async function hamtHashFn2(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}

// node_modules/ipfs-core/src/components/files/utils/dir-sharded.js
var Dir2 = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name22, value2) {
  }
  get(name22) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var DirSharded2 = class extends Dir2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: hamtHashFn2,
      bits: hamtBucketBits
    });
  }
  async put(name22, value2) {
    await this._bucket.put(name22, value2);
  }
  get(name22) {
    return this._bucket.get(name22);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  async *flush(blockstore) {
    yield* flush2(this._bucket, blockstore, this, this.options);
  }
};
async function* flush2(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush2(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value2.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value2.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode4(prepare(node));
  const cid = await persist2(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    node,
    size
  };
}

// node_modules/ipfs-core/src/components/files/utils/hamt-utils.js
var import_it_last6 = __toESM(require_it_last(), 1);
var log26 = logger("ipfs:mfs:core:utils:hamt-utils");
var updateHamtDirectory = async (context, links3, bucket, options) => {
  if (!options.parent.Data) {
    throw new Error("Could not update HAMT directory because parent had no data");
  }
  const data = Uint8Array.from(bucket._children.bitField().reverse());
  const node = UnixFS.unmarshal(options.parent.Data);
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mode: node.mode,
    mtime: node.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const parent2 = {
    Data: dir.marshal(),
    Links: links3.sort((a, b) => (a.Name || "").localeCompare(b.Name || ""))
  };
  const buf2 = encode4(parent2);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: parent2,
    cid,
    size: links3.reduce((sum, link) => sum + (link.Tsize || 0), buf2.length)
  };
};
var recreateHamtLevel = async (context, links3, rootBucket, parentBucket, positionAtParent) => {
  const bucket = new Bucket({
    hash: rootBucket._options.hash,
    bits: rootBucket._options.bits
  }, parentBucket, positionAtParent);
  parentBucket._putObjectAt(positionAtParent, bucket);
  await addLinksToHamtBucket2(context, links3, bucket, rootBucket);
  return bucket;
};
var recreateInitialHamtLevel = async (links3) => {
  const bucket = createHAMT({
    hashFn: hamtHashFn2,
    bits: hamtBucketBits
  });
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        const pos = parseInt(linkName, 16);
        const subBucket = new Bucket({
          hash: bucket._options.hash,
          bits: bucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        return Promise.resolve();
      }
      return bucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
  return bucket;
};
var addLinksToHamtBucket2 = async (context, links3, bucket, rootBucket) => {
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        log26("Populating sub bucket", linkName);
        const pos = parseInt(linkName, 16);
        const block = await context.repo.blocks.get(link.Hash);
        const node = decode6(block);
        const subBucket = new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        await addLinksToHamtBucket2(context, node.Links, subBucket, rootBucket);
        return Promise.resolve();
      }
      return rootBucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
};
var toPrefix2 = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var generatePath = async (context, fileName, rootNode) => {
  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
  const position = await rootBucket._findNewBucketAndPos(fileName);
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let currentBucket = position.bucket;
  while (currentBucket !== rootBucket) {
    path2.push({
      bucket: currentBucket,
      prefix: toPrefix2(currentBucket._posAtParent)
    });
    currentBucket = currentBucket._parent;
  }
  path2.reverse();
  path2[0].node = rootNode;
  for (let i2 = 0; i2 < path2.length; i2++) {
    const segment = path2[i2];
    if (!segment.node) {
      throw new Error("Could not generate HAMT path");
    }
    const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
    if (!link) {
      log26(`Link ${segment.prefix}${fileName} will be added`);
      continue;
    }
    if (link.Name === `${segment.prefix}${fileName}`) {
      log26(`Link ${segment.prefix}${fileName} will be replaced`);
      continue;
    }
    log26(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const node = decode6(block);
    if (!path2[i2 + 1]) {
      log26(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(fileName);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node
      });
      continue;
    }
    const nextSegment = path2[i2 + 1];
    await addLinksToHamtBucket2(context, node.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = node;
  }
  await rootBucket.put(fileName, true);
  path2.reverse();
  return {
    rootBucket,
    path: path2
  };
};
var createShard = async (context, contents, options = {}) => {
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options.mtime,
    mode: options.mode
  }, options);
  for (let i2 = 0; i2 < contents.length; i2++) {
    await shard._bucket.put(contents[i2].name, {
      size: contents[i2].size,
      cid: contents[i2].cid
    });
  }
  const res = await (0, import_it_last6.default)(shard.flush(context.repo.blocks));
  if (!res) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};

// node_modules/ipfs-core/src/components/files/utils/add-link.js
var import_err_code46 = __toESM(require_err_code(), 1);
var import_it_last7 = __toESM(require_it_last(), 1);
var log27 = logger("ipfs:mfs:core:utils:add-link");
async function addLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code46.default)(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (parentCid.code !== code) {
      throw (0, import_err_code46.default)(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
    }
    log27(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode6(block);
  }
  if (!parent2) {
    throw (0, import_err_code46.default)(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
  }
  if (!options.cid) {
    throw (0, import_err_code46.default)(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
  }
  if (!options.name) {
    throw (0, import_err_code46.default)(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
  }
  if (!options.size && options.size !== 0) {
    throw (0, import_err_code46.default)(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
  }
  if (!parent2.Data) {
    throw (0, import_err_code46.default)(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log27("Adding link to sharded directory");
    return addToShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  if (parent2.Links.length >= options.shardSplitThreshold) {
    log27("Converting directory to sharded directory");
    return convertToShardedDirectory(context, {
      ...options,
      parent: parent2,
      mtime: meta.mtime,
      mode: meta.mode
    });
  }
  log27(`Adding ${options.name} (${options.cid}) to regular directory`);
  return addToDirectory(context, {
    ...options,
    parent: parent2
  });
}
var convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map((link) => ({
    name: link.Name || "",
    size: link.Tsize || 0,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options);
  log27(`Converted directory to sharded directory ${result.cid}`);
  return result;
};
var addToDirectory = async (context, options) => {
  const parentLinks = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  parentLinks.push({
    Name: options.name,
    Tsize: options.size,
    Hash: options.cid
  });
  if (!options.parent.Data) {
    throw (0, import_err_code46.default)(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
  }
  const node = UnixFS.unmarshal(options.parent.Data);
  let data;
  if (node.mtime) {
    const ms = Date.now();
    const secs = Math.floor(ms / 1e3);
    node.mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
    data = node.marshal();
  } else {
    data = options.parent.Data;
  }
  options.parent = prepare({
    Data: data,
    Links: parentLinks
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const buf2 = encode4(options.parent);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: options.parent,
    cid,
    size: buf2.length
  };
};
var addToShardedDirectory = async (context, options) => {
  const {
    shard,
    path: path2
  } = await addFileToShardedDirectory(context, options);
  const result = await (0, import_it_last7.default)(shard.flush(context.repo.blocks));
  if (!result) {
    throw new Error("No result from flushing shard");
  }
  const block = await context.repo.blocks.get(result.cid);
  const node = decode6(block);
  const parentLinks = options.parent.Links.filter((link) => {
    return (link.Name || "").substring(0, 2) !== path2[0].prefix;
  });
  const newLink = node.Links.find((link) => (link.Name || "").substring(0, 2) === path2[0].prefix);
  if (!newLink) {
    throw new Error(`No link found with prefix ${path2[0].prefix}`);
  }
  parentLinks.push(newLink);
  return updateHamtDirectory(context, parentLinks, path2[0].bucket, options);
};
var addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  };
  if (!options.parent.Data) {
    throw (0, import_err_code46.default)(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
  }
  const rootBucket = await recreateInitialHamtLevel(options.parent.Links);
  const node = UnixFS.unmarshal(options.parent.Data);
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mode: node.mode
  }, options);
  shard._bucket = rootBucket;
  if (node.mtime) {
    shard.mtime = {
      secs: Math.round(Date.now() / 1e3)
    };
  }
  const position = await rootBucket._findNewBucketAndPos(file.name);
  const path2 = toBucketPath2(position);
  path2[0].node = options.parent;
  let index = 0;
  while (index < path2.length) {
    const segment = path2[index];
    index++;
    const node2 = segment.node;
    if (!node2) {
      throw new Error("Segment had no node");
    }
    const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
    if (!link) {
      log27(`Link ${segment.prefix}${file.name} will be added`);
      index = path2.length;
      break;
    }
    if (link.Name === `${segment.prefix}${file.name}`) {
      log27(`Link ${segment.prefix}${file.name} will be replaced`);
      index = path2.length;
      break;
    }
    if ((link.Name || "").length > 2) {
      log27(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
      index = path2.length;
      break;
    }
    log27(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const subShard = decode6(block);
    if (!path2[index]) {
      log27(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(file.name);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node: subShard
      });
      break;
    }
    const nextSegment = path2[index];
    await addLinksToHamtBucket2(context, subShard.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = subShard;
  }
  await shard._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  });
  return {
    shard,
    path: path2
  };
};
var toBucketPath2 = (position) => {
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let bucket = position.bucket._parent;
  let positionInBucket = position.bucket._posAtParent;
  while (bucket) {
    path2.push({
      bucket,
      prefix: toPrefix2(positionInBucket)
    });
    positionInBucket = bucket._posAtParent;
    bucket = bucket._parent;
  }
  path2.reverse();
  return path2;
};

// node_modules/ipfs-core/src/components/files/utils/update-tree.js
var log28 = logger("ipfs:mfs:utils:update-tree");
var defaultOptions5 = {
  shardSplitThreshold: 1e3
};
async function updateTree(context, trail, options) {
  options = Object.assign({}, defaultOptions5, options);
  log28("Trail", trail);
  trail = trail.slice().reverse();
  let index = 0;
  let child;
  for await (const block of context.repo.blocks.getMany(trail.map((node) => node.cid))) {
    const node = decode6(block);
    const cid2 = trail[index].cid;
    const name22 = trail[index].name;
    index++;
    if (!child) {
      child = {
        cid: cid2,
        name: name22,
        size: block.length
      };
      continue;
    }
    const result = await addLink(context, {
      parent: node,
      name: child.name,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    child = {
      cid: result.cid,
      name: name22,
      size: result.size
    };
  }
  const { cid } = child;
  log28(`Final CID ${cid}`);
  return cid;
}

// node_modules/ipfs-core/src/components/files/utils/update-mfs-root.js
var import_err_code47 = __toESM(require_err_code(), 1);
var log29 = logger("ipfs:mfs:utils:update-mfs-root");
async function updateMfsRoot(context, cid, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code47.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  log29(`New MFS root will be ${cid}`);
  await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  return cid;
}

// node_modules/ipfs-core/src/components/files/chmod.js
var import_it_last8 = __toESM(require_it_last(), 1);

// node_modules/ipfs-core/src/components/files/mkdir.js
var import_err_code48 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/src/components/files/utils/create-node.js
async function createNode2(context, type, options) {
  const metadata = new UnixFS({
    type,
    mode: options.mode,
    mtime: options.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const node = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf2 = encode4(node);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    cid,
    node
  };
}

// node_modules/ipfs-core/src/components/files/mkdir.js
var mergeOptions5 = merge_options_default.bind({ ignoreUndefined: true });
var log30 = logger("ipfs:mfs:mkdir");
var defaultOptions6 = {
  parents: false,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3,
  flush: true
};
function createMkdir(context) {
  async function mfsMkdir(path2, options = {}) {
    const opts = mergeOptions5(defaultOptions6, options);
    if (!path2) {
      throw new Error("no path given to Mkdir");
    }
    path2 = path2.trim();
    if (path2 === "/") {
      if (opts.parents) {
        return;
      }
      throw (0, import_err_code48.default)(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
    }
    if (path2.substring(0, 1) !== "/") {
      throw (0, import_err_code48.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    log30(`Creating ${path2}`);
    const pathComponents = toPathComponents3(path2);
    if (pathComponents[0] === "ipfs") {
      throw (0, import_err_code48.default)(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
    }
    const root = await loadMfsRoot(context, opts);
    let parent2;
    const trail = [];
    const emptyDir = await createNode2(context, "directory", opts);
    for (let i2 = 0; i2 <= pathComponents.length; i2++) {
      const subPathComponents = pathComponents.slice(0, i2);
      const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
      try {
        parent2 = await exporter2(subPath, context.repo.blocks);
        if (parent2.type !== "file" && parent2.type !== "directory") {
          throw (0, import_err_code48.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (i2 === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw (0, import_err_code48.default)(new Error("file already exists"), "ERR_ALREADY_EXISTS");
        }
        trail.push({
          name: parent2.name,
          cid: parent2.cid
        });
      } catch (err2) {
        if (err2.code === "ERR_NOT_FOUND") {
          if (i2 < pathComponents.length && !opts.parents) {
            throw (0, import_err_code48.default)(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err2;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
var addEmptyDir = async (context, childName, emptyDir, parent2, trail, options) => {
  log30(`Adding empty dir called ${childName} to ${parent2.cid}`);
  const result = await addLink(context, {
    parent: parent2.node,
    parentCid: parent2.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};

// node_modules/ipfs-core/src/components/files/cp.js
var import_err_code49 = __toESM(require_err_code(), 1);
var mergeOptions6 = merge_options_default.bind({ ignoreUndefined: true });
var log31 = logger("ipfs:mfs:cp");
var defaultOptions7 = {
  parents: false,
  flush: true,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3
};
function createCp(context) {
  async function mfsCp(from33, to, opts = {}) {
    const options = mergeOptions6(defaultOptions7, opts);
    if (!Array.isArray(from33)) {
      from33 = [from33];
    }
    const sources = await Promise.all(
      from33.map((path2) => toMfsPath(context, path2, options))
    );
    let destination = await toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw (0, import_err_code49.default)(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
    }
    const missing = sources.find((source) => !source.exists);
    if (missing) {
      throw (0, import_err_code49.default)(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log31("Destination exists");
      if (sources.length === 1 && !destinationIsDirectory) {
        throw (0, import_err_code49.default)(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
      }
    } else {
      log31("Destination does not exist");
      if (sources.length > 1) {
        if (!options.parents) {
          throw (0, import_err_code49.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
        }
        await createMkdir(context)(destination.path, options);
        destination = await toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
        try {
          await createStat3(context)(parentFolder, options);
        } catch (err2) {
          if (err2.code !== "ERR_NOT_FOUND") {
            throw err2;
          }
          if (!options.parents) {
            throw (0, import_err_code49.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await createMkdir(context)(parentFolder, options);
          destination = await toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source = sources.pop();
      if (!source) {
        throw (0, import_err_code49.default)(new Error("could not find source"), "ERR_INVALID_PARAMS");
      }
      const destinationName = destinationIsDirectory ? source.name : destination.name;
      log31(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
      return copyToFile(context, source, destinationName, trail, options);
    }
    log31("Multiple sources, wrapping in a directory");
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption(mfsCp);
}
var isDirectory = (destination) => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
};
var copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent2 = destinationTrail.pop();
  if (!parent2) {
    throw (0, import_err_code49.default)(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
  }
  parent2 = await addSourceToParent(context, source, destination, parent2, options);
  destinationTrail.push(parent2);
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source = sources[i2];
    destination = await addSourceToParent(context, source, source.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var addSourceToParent = async (context, source, childName, parent2, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid);
  const {
    node,
    cid,
    size
  } = await addLink(context, {
    parentCid: parent2.cid,
    size: sourceBlock.length,
    cid: source.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.node = node;
  parent2.cid = cid;
  parent2.size = size;
  return parent2;
};

// node_modules/ipfs-core/src/components/files/rm.js
var import_err_code51 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/src/components/files/utils/remove-link.js
var import_err_code50 = __toESM(require_err_code(), 1);
var log32 = logger("ipfs:mfs:core:utils:remove-link");
async function removeLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code50.default)(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    log32(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode6(block);
  }
  if (!parent2) {
    throw (0, import_err_code50.default)(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
  }
  if (!options.name) {
    throw (0, import_err_code50.default)(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
  }
  if (!parent2.Data) {
    throw (0, import_err_code50.default)(new Error("Parent node had no data"), "ERR_INVALID_NODE");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log32(`Removing ${options.name} from sharded directory`);
    return removeFromShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  log32(`Removing link ${options.name} regular directory`);
  return removeFromDirectory(context, {
    ...options,
    parent: parent2
  });
}
var removeFromDirectory = async (context, options) => {
  options.parent.Links = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  const parentBlock = await encode4(options.parent);
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const hash3 = await hasher.digest(parentBlock);
  const parentCid = CID.create(options.cidVersion, code, hash3);
  await context.repo.blocks.put(parentCid, parentBlock);
  log32(`Updated regular directory ${parentCid}`);
  return {
    node: options.parent,
    cid: parentCid
  };
};
var removeFromShardedDirectory = async (context, options) => {
  const {
    rootBucket,
    path: path2
  } = await generatePath(context, options.name, options.parent);
  await rootBucket.del(options.name);
  const {
    node
  } = await updateShard(context, path2, options.name, options);
  return updateHamtDirectory(context, node.Links, rootBucket, options);
};
var updateShard = async (context, positions, name22, options) => {
  const last14 = positions.pop();
  if (!last14) {
    throw (0, import_err_code50.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const {
    bucket,
    prefix,
    node
  } = last14;
  if (!node) {
    throw (0, import_err_code50.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const link = node.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
  if (!link) {
    throw (0, import_err_code50.default)(new Error(`No link found with prefix ${prefix} for file ${name22}`), "ERR_NOT_FOUND");
  }
  if (link.Name === `${prefix}${name22}`) {
    log32(`Removing existing link ${link.Name}`);
    const links3 = node.Links.filter((nodeLink) => {
      return nodeLink.Name !== link.Name;
    });
    await bucket.del(name22);
    return updateHamtDirectory(context, links3, bucket, options);
  }
  log32(`Descending into sub-shard ${link.Name} for ${prefix}${name22}`);
  const result = await updateShard(context, positions, name22, options);
  let cid = result.cid;
  let size = result.size;
  let newName = prefix;
  if (result.node.Links.length === 1) {
    log32(`Removing subshard for ${prefix}`);
    const link2 = result.node.Links[0];
    newName = `${prefix}${(link2.Name || "").substring(2)}`;
    cid = link2.Hash;
    size = link2.Tsize || 0;
  }
  log32(`Updating shard ${prefix} with name ${newName}`);
  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);
};
var updateShardParent = (context, bucket, parent2, oldName, newName, size, cid, options) => {
  const parentLinks = parent2.Links.filter((link) => {
    return link.Name !== oldName;
  });
  parentLinks.push({
    Name: newName,
    Tsize: size,
    Hash: cid
  });
  return updateHamtDirectory(context, parentLinks, bucket, options);
};

// node_modules/ipfs-core/src/components/files/rm.js
var mergeOptions7 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions8 = {
  recursive: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  flush: true,
  shardSplitThreshold: 1e3
};
function createRm4(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions7(defaultOptions8, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(
      paths.map((path2) => toMfsPath(context, path2, options))
    );
    if (!sources.length) {
      throw (0, import_err_code51.default)(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
    }
    sources.forEach((source) => {
      if (source.path === "/") {
        throw (0, import_err_code51.default)(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
      }
    });
    for (const source of sources) {
      await removePath(context, source.path, options);
    }
  }
  return withTimeoutOption(mfsRm);
}
var removePath = async (context, path2, options) => {
  const mfsPath = await toMfsPath(context, path2, options);
  const trail = await toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent2 = trail[trail.length - 1];
  if (!parent2) {
    throw (0, import_err_code51.default)(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
  }
  if (child.type === "directory" && !options.recursive) {
    throw (0, import_err_code51.default)(new Error(`${path2} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
  }
  const {
    cid
  } = await removeLink(context, {
    parentCid: parent2.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.cid = cid;
  const newRootCid = await updateTree(context, trail, options);
  await updateMfsRoot(context, newRootCid, options);
};

// node_modules/ipfs-core/src/components/files/chmod.js
var mergeOptions8 = merge_options_default.bind({ ignoreUndefined: true });
var log33 = logger("ipfs:mfs:touch");
var defaultOptions9 = {
  flush: true,
  shardSplitThreshold: 1e3,
  hashAlg: "sha2-256",
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory2) {
  let modification = 0;
  if (mode.includes("x") || mode.includes("X") && (isDirectory2 || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes("w")) {
    modification += 2;
  }
  if (mode.includes("r")) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes("u")) {
    ugo += modification << 6;
  }
  if (references.includes("g")) {
    ugo += modification << 3;
  }
  if (references.includes("o")) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes("t")) {
    modification += parseInt("1000", 8);
  }
  if (mode.includes("s")) {
    if (references.includes("u")) {
      modification += parseInt("4000", 8);
    }
    if (references.includes("g")) {
      modification += parseInt("2000", 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory2) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${input}`);
  }
  let [
    ,
    references,
    operator,
    mode
  ] = match;
  if (references === "a" || !references) {
    references = "ugo";
  }
  let modification = calculateModification(mode, originalMode, isDirectory2);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === "=") {
    if (references.includes("u")) {
      originalMode = originalMode & parseInt("7077", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("g")) {
      originalMode = originalMode & parseInt("7707", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("o")) {
      originalMode = originalMode & parseInt("7770", 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === "+") {
    return modification | originalMode;
  }
  if (operator === "-") {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === "string") {
    const strMode = `${mode}`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(",").reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod(context) {
  async function mfsChmod(path2, mode, options = {}) {
    const opts = mergeOptions8(defaultOptions9, options);
    log33(`Fetching stats for ${path2}`);
    const {
      cid,
      mfsDirectory,
      name: name22
    } = await toMfsPath(context, path2, opts);
    if (cid.code !== code) {
      throw (0, import_err_code52.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
    }
    if (opts.recursive) {
      const root = await pipe(
        async function* () {
          for await (const entry of recursive(cid, context.repo.blocks)) {
            if (entry.type !== "file" && entry.type !== "directory") {
              throw (0, import_err_code52.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            }
            entry.unixfs.mode = calculateMode(mode, entry.unixfs);
            const node2 = prepare({
              Data: entry.unixfs.marshal(),
              Links: entry.node.Links
            });
            yield {
              path: entry.path,
              content: node2
            };
          }
        },
        (source) => importer2(source, context.repo.blocks, {
          ...opts,
          pin: false,
          dagBuilder: async function* (source2, block2, opts2) {
            for await (const entry of source2) {
              yield async function() {
                const node2 = entry.content;
                const buf2 = encode4(node2);
                const cid2 = await persist2(buf2, block2, opts2);
                if (!node2.Data) {
                  throw (0, import_err_code52.default)(new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
                }
                const unixfs = UnixFS.unmarshal(node2.Data);
                return {
                  cid: cid2,
                  size: buf2.length,
                  path: entry.path,
                  unixfs
                };
              };
            }
          }
        }),
        (nodes) => (0, import_it_last8.default)(nodes)
      );
      if (!root) {
        throw (0, import_err_code52.default)(new Error(`Could not chmod ${path2}`), "ERR_COULD_NOT_CHMOD");
      }
      await createRm4(context)(path2, opts);
      await createCp(context)(`/ipfs/${root.cid}`, path2, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid);
    const node = decode6(block);
    if (!node.Data) {
      throw (0, import_err_code52.default)(new Error(`${cid} had no data`), "ERR_INVALID_NODE");
    }
    const metadata = UnixFS.unmarshal(node.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = encode4({
      Data: metadata.marshal(),
      Links: node.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions9.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash3 = await hasher.digest(updatedBlock);
    const updatedCid = CID.create(opts.cidVersion, code, hash3);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = CID.decode(parent2.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode6(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name22,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      hashAlg,
      cidVersion: cid.version,
      shardSplitThreshold: Infinity
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsChmod);
}

// node_modules/ipfs-core/src/components/files/flush.js
var mergeOptions9 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions10 = {};
function createFlush(context) {
  async function mfsFlush(path2, options = {}) {
    options = mergeOptions9(defaultOptions10, options);
    const { cid } = await createStat3(context)(path2, options);
    return cid;
  }
  return withTimeoutOption(mfsFlush);
}

// node_modules/ipfs-core/src/components/files/mv.js
var mergeOptions10 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions11 = {
  parents: false,
  flush: true,
  cidVersion: 0,
  hashAlg: "sha2-256",
  shardSplitThreshold: 1e3
};
function createMv(context) {
  async function mfsMv(from33, to, options = {}) {
    const opts = mergeOptions10(defaultOptions11, options);
    await createCp(context)(from33, to, opts);
    await createRm4(context)(from33, {
      ...opts,
      recursive: true
    });
  }
  return withTimeoutOption(mfsMv);
}

// node_modules/ipfs-core/src/components/files/touch.js
var import_err_code53 = __toESM(require_err_code(), 1);
var mergeOptions11 = merge_options_default.bind({ ignoreUndefined: true });
var log34 = logger("ipfs:mfs:touch");
var defaultOptions12 = {
  flush: true,
  shardSplitThreshold: 1e3,
  cidVersion: 0,
  hashAlg: "sha2-256"
};
function createTouch(context) {
  async function mfsTouch(path2, options = {}) {
    const settings = mergeOptions11(defaultOptions12, options);
    settings.mtime = settings.mtime || new Date();
    log34(`Touching ${path2} mtime: ${settings.mtime}`);
    const {
      cid,
      mfsDirectory,
      name: name22,
      exists: exists2
    } = await toMfsPath(context, path2, settings);
    const hashAlg = options.hashAlg || defaultOptions12.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists2) {
      const metadata = new UnixFS({
        type: "file",
        mtime: settings.mtime
      });
      updatedBlock = encode4({ Data: metadata.marshal(), Links: [] });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid.code !== code) {
        throw (0, import_err_code53.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      cidVersion = cid.version;
      const block = await context.repo.blocks.get(cid);
      const node = decode6(block);
      if (!node.Data) {
        throw (0, import_err_code53.default)(new Error(`${path2} had no data`), "ERR_INVALID_NODE");
      }
      const metadata = UnixFS.unmarshal(node.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = encode4({
        Data: metadata.marshal(),
        Links: node.Links
      });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = parent2.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode6(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name22,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, settings);
    await updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption(mfsTouch);
}

// node_modules/ipfs-core/src/components/files/read.js
var import_err_code54 = __toESM(require_err_code(), 1);
var mergeOptions12 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions13 = {
  offset: 0,
  length: Infinity
};
function createRead(context) {
  function mfsRead(path2, options = {}) {
    options = mergeOptions12(defaultOptions13, options);
    return {
      [Symbol.asyncIterator]: async function* read19() {
        const mfsPath = await toMfsPath(context, path2, options);
        const result = await exporter2(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== "file") {
          throw (0, import_err_code54.default)(new Error(`${path2} was not a file`), "ERR_NOT_FILE");
        }
        if (!result.content) {
          throw (0, import_err_code54.default)(new Error(`Could not load content stream from ${path2}`), "ERR_NO_CONTENT");
        }
        for await (const buf2 of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf2;
        }
      }
    };
  }
  return withTimeoutOption(mfsRead);
}

// node_modules/ipfs-core/src/components/files/utils/to-async-iterator.js
var import_err_code55 = __toESM(require_err_code(), 1);
var log35 = logger("ipfs:mfs:utils:to-async-iterator");
function toAsyncIterator(content) {
  if (!content) {
    throw (0, import_err_code55.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (typeof content === "string" || content instanceof String) {
    log35("Content was a string");
    content = fromString3(content.toString());
  }
  if (content.length) {
    log35("Content was array-like");
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log35("Content was an async iterator");
    return content;
  }
  if (content[Symbol.iterator]) {
    log35("Content was an iterator");
    return content;
  }
  if (global.Blob && content instanceof global.Blob) {
    log35("Content was an HTML5 Blob");
    let index = 0;
    const iterator = {
      next: () => {
        if (index > content.size) {
          return {
            done: true
          };
        }
        return new Promise((resolve7, reject) => {
          const chunk = content.slice(index, MFS_MAX_CHUNK_SIZE);
          index += MFS_MAX_CHUNK_SIZE;
          const reader6 = new global.FileReader();
          const handleLoad = (ev) => {
            reader6.removeEventListener("loadend", handleLoad, false);
            if (ev.error) {
              return reject(ev.error);
            }
            resolve7({
              done: false,
              value: new Uint8Array(reader6.result)
            });
          };
          reader6.addEventListener("loadend", handleLoad);
          reader6.readAsArrayBuffer(chunk);
        });
      }
    };
    return {
      [Symbol.asyncIterator]: () => {
        return iterator;
      }
    };
  }
  throw (0, import_err_code55.default)(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
}

// node_modules/ipfs-core/src/components/files/write.js
var import_err_code56 = __toESM(require_err_code(), 1);
var import_it_last9 = __toESM(require_it_last(), 1);
var mergeOptions13 = merge_options_default.bind({ ignoreUndefined: true });
var log36 = logger("ipfs:mfs:write");
var defaultOptions14 = {
  offset: 0,
  length: Infinity,
  create: false,
  truncate: false,
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  parents: false,
  progress: (bytes2, path2) => {
  },
  strategy: "trickle",
  flush: true,
  leafType: "raw",
  shardSplitThreshold: 1e3
};
function createWrite(context) {
  async function mfsWrite(path2, content, opts = {}) {
    const options = mergeOptions13(defaultOptions14, opts);
    let source;
    let destination;
    let parent2;
    log36("Reading source, destination and parent");
    await createLock().readLock(async () => {
      source = await toAsyncIterator(content);
      destination = await toMfsPath(context, path2, options);
      parent2 = await toMfsPath(context, destination.mfsDirectory, options);
    })();
    log36("Read source, destination and parent");
    if (!options.parents && !parent2.exists) {
      throw (0, import_err_code56.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (source == null) {
      throw (0, import_err_code56.default)(new Error("could not create source"), "ERR_NO_SOURCE");
    }
    if (destination == null) {
      throw (0, import_err_code56.default)(new Error("could not create destination"), "ERR_NO_DESTINATION");
    }
    if (!options.create && !destination.exists) {
      throw (0, import_err_code56.default)(new Error("file does not exist"), "ERR_NO_EXIST");
    }
    if (destination.entryType !== "file") {
      throw (0, import_err_code56.default)(new Error("not a file"), "ERR_NOT_A_FILE");
    }
    return updateOrImport(context, path2, source, destination, options);
  }
  return withTimeoutOption(mfsWrite);
}
var updateOrImport = async (context, path2, source, destination, options) => {
  const child = await write(context, source, destination, options);
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents3(path2);
    const fileName = pathComponents.pop();
    if (fileName == null) {
      throw (0, import_err_code56.default)(new Error("source does not exist"), "ERR_NO_EXIST");
    }
    let parentExists = false;
    try {
      await createStat3(context)(`/${pathComponents.join("/")}`, options);
      parentExists = true;
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        throw err2;
      }
    }
    if (!parentExists) {
      await createMkdir(context)(`/${pathComponents.join("/")}`, options);
    }
    const updatedPath = await toMfsPath(context, path2, options);
    const trail = await toTrail(context, updatedPath.mfsDirectory);
    const parent2 = trail[trail.length - 1];
    if (!parent2) {
      throw (0, import_err_code56.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (!parent2.type || !parent2.type.includes("directory")) {
      throw (0, import_err_code56.default)(new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
    }
    const parentBlock = await context.repo.blocks.get(parent2.cid);
    const parentNode = decode6(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  })();
};
var write = async (context, source, destination, options) => {
  if (destination.exists) {
    log36(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
  } else {
    log36(`Writing file offset ${options.offset} length ${options.length}`);
  }
  const sources = [];
  if (options.offset > 0) {
    if (destination.unixfs) {
      log36(`Writing first ${options.offset} bytes of original file`);
      sources.push(
        () => {
          return destination.content({
            offset: 0,
            length: options.offset
          });
        }
      );
      if (destination.unixfs.fileSize() < options.offset) {
        const extra = options.offset - destination.unixfs.fileSize();
        log36(`Writing zeros for extra ${extra} bytes`);
        sources.push(
          asyncZeroes(extra)
        );
      }
    } else {
      log36(`Writing zeros for first ${options.offset} bytes`);
      sources.push(
        asyncZeroes(options.offset)
      );
    }
  }
  sources.push(
    limitAsyncStreamBytes(source, options.length)
  );
  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      const fileSize = destination.unixfs.fileSize();
      if (fileSize > bytesWritten) {
        log36(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
        return destination.content({
          offset: bytesWritten
        });
      } else {
        log36("Not writing last bytes from original file");
      }
    }
    return {
      [Symbol.asyncIterator]: async function* () {
      }
    };
  });
  let mode;
  if (options.mode !== void 0 && options.mode !== null) {
    mode = parseMode(options.mode);
  } else if (destination && destination.unixfs) {
    mode = destination.unixfs.mode;
  }
  let mtime;
  if (options.mtime != null) {
    mtime = parseMtime(options.mtime);
  } else if (destination && destination.unixfs) {
    mtime = destination.unixfs.mtime;
  }
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const result = await (0, import_it_last9.default)(importer2([{
    content,
    mode,
    mtime
  }], context.repo.blocks, {
    progress: options.progress,
    hasher,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }));
  if (!result) {
    throw (0, import_err_code56.default)(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
  }
  log36(`Wrote ${result.cid}`);
  return {
    cid: result.cid,
    size: result.size
  };
};
var limitAsyncStreamBytes = (stream, limit) => {
  return async function* _limitAsyncStreamBytes() {
    let emitted = 0;
    for await (const buf2 of stream) {
      emitted += buf2.length;
      if (emitted > limit) {
        yield buf2.slice(0, limit - emitted);
        return;
      }
      yield buf2;
    }
  };
};
var asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {
  const buf2 = new Uint8Array(chunkSize);
  async function* _asyncZeroes() {
    while (true) {
      yield buf2.slice();
    }
  }
  return limitAsyncStreamBytes(_asyncZeroes(), count);
};
var catAsyncIterators = async function* (sources) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    yield* sources[i2]();
  }
};
var countBytesStreamed = async function* (source, notify) {
  let wrote = 0;
  for await (const buf2 of source) {
    wrote += buf2.length;
    yield buf2;
  }
  for await (const buf2 of notify(wrote)) {
    wrote += buf2.length;
    yield buf2;
  }
};

// node_modules/ipfs-core/src/components/files/ls.js
var import_it_map8 = __toESM(require_it_map(), 1);
var toOutput = (fsEntry) => {
  const output = {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type: fsEntry.type === "directory" ? "directory" : "file",
    size: fsEntry.size
  };
  if (fsEntry.type === "file" || fsEntry.type === "directory") {
    output.mode = fsEntry.unixfs.mode;
    output.mtime = fsEntry.unixfs.mtime;
  }
  return output;
};
function createLs3(context) {
  async function* mfsLs(path2, options = {}) {
    const mfsPath = await toMfsPath(context, path2, options);
    const fsEntry = await exporter2(mfsPath.mfsPath, context.repo.blocks);
    if (fsEntry.type === "directory") {
      yield* (0, import_it_map8.default)(fsEntry.content(options), toOutput);
      return;
    }
    yield toOutput(fsEntry);
  }
  return withTimeoutOption(mfsLs);
}

// node_modules/ipfs-core/src/components/files/index.js
var readOperations = {
  stat: createStat3
};
var writeOperations = {
  chmod: createChmod,
  cp: createCp,
  flush: createFlush,
  mkdir: createMkdir,
  mv: createMv,
  rm: createRm4,
  touch: createTouch
};
var unwrappedOperations = {
  write: createWrite,
  read: createRead,
  ls: createLs3
};
var wrap = ({
  options,
  mfs,
  operations,
  lock: lock3
}) => {
  Object.keys(operations).forEach((key) => {
    mfs[key] = lock3(operations[key](options));
  });
};
var defaultOptions15 = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {
    repoOwner
  } = Object.assign({}, defaultOptions15 || {}, options);
  const lock3 = createLock(repoOwner);
  const readLock = (operation) => {
    return lock3.readLock(operation);
  };
  const writeLock = (operation) => {
    return lock3.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach((key) => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles({ repo, preload: preload2, hashers, options: constructorOptions }) {
  const methods7 = createMfs({
    repo,
    repoOwner: constructorOptions.repoOwner !== false,
    hashers
  });
  const withPreload = (fn) => {
    const wrapped = (...args) => {
      const paths = args.filter((arg) => ipfsPath(arg) || isCID(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path2) => preload2(path2));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods7,
    chmod: methods7.chmod,
    cp: withPreload(methods7.cp),
    mkdir: methods7.mkdir,
    stat: withPreload(methods7.stat),
    rm: methods7.rm,
    read: withPreload(methods7.read),
    touch: methods7.touch,
    write: methods7.write,
    mv: withPreload(methods7.mv),
    flush: methods7.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods7.ls(...args)) {
        yield { ...file, size: file.size || 0 };
      }
    })
  };
}

// node_modules/ipfs-core/src/components/key/export.js
function createExport2({ keychain }) {
  const exportKey2 = (name22, password) => keychain.exportKey(name22, password);
  return withTimeoutOption(exportKey2);
}

// node_modules/ipfs-core/src/components/key/gen.js
var DEFAULT_KEY_TYPE = "Ed25519";
var DEFAULT_KEY_SIZE = 2048;
function createGen({ keychain }) {
  const gen = (name22, options = { type: DEFAULT_KEY_TYPE, size: DEFAULT_KEY_SIZE }) => {
    return keychain.createKey(name22, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
  };
  return withTimeoutOption(gen);
}

// node_modules/ipfs-core/src/components/key/import.js
function createImport2({ keychain }) {
  const importKey2 = (name22, pem, password) => {
    return keychain.importKey(name22, pem, password);
  };
  return withTimeoutOption(importKey2);
}

// node_modules/ipfs-core/src/components/key/info.js
function createInfo({ keychain }) {
  const info = (name22) => keychain.findKeyByName(name22);
  return withTimeoutOption(info);
}

// node_modules/ipfs-core/src/components/key/list.js
function createList2({ keychain }) {
  const list = () => keychain.listKeys();
  return withTimeoutOption(list);
}

// node_modules/ipfs-core/src/components/key/rename.js
function createRename({ keychain }) {
  const rename = async (oldName, newName) => {
    const key = await keychain.renameKey(oldName, newName);
    return {
      was: oldName,
      now: key.name,
      id: key.id,
      overwrite: false
    };
  };
  return withTimeoutOption(rename);
}

// node_modules/ipfs-core/src/components/key/rm.js
function createRm5({ keychain }) {
  const rm = (name22) => keychain.removeKey(name22);
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/src/components/key/index.js
var KeyAPI = class {
  constructor({ keychain }) {
    this.gen = createGen({ keychain });
    this.list = createList2({ keychain });
    this.rm = createRm5({ keychain });
    this.rename = createRename({ keychain });
    this.export = createExport2({ keychain });
    this.import = createImport2({ keychain });
    this.info = createInfo({ keychain });
  }
};

// node_modules/ipfs-core/src/components/object/get.js
function createGet4({ repo, preload: preload2 }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid, options);
    return decode6(block);
  }
  return withTimeoutOption(get3);
}

// node_modules/ipfs-core/src/components/object/data.js
function createData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  async function data(multihash, options = {}) {
    const node = await get3(multihash, options);
    return node.Data || new Uint8Array(0);
  }
  return withTimeoutOption(data);
}

// node_modules/ipfs-core/src/components/object/links.js
function findLinks(node, links3 = []) {
  for (const key in node) {
    const val = node[key];
    if (key === "/" && Object.keys(node).length === 1) {
      try {
        links3.push({
          Name: "",
          Tsize: 0,
          Hash: CID.parse(val)
        });
        continue;
      } catch (_) {
      }
    }
    const cid = CID.asCID(val);
    if (cid) {
      links3.push({
        Name: "",
        Tsize: 0,
        Hash: cid
      });
      continue;
    }
    if (Array.isArray(val)) {
      findLinks(val, links3);
    }
    if (val && typeof val === "object") {
      findLinks(val, links3);
    }
  }
  return links3;
}
function createLinks({ repo, codecs: codecs2 }) {
  async function links3(cid, options = {}) {
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    switch (cid.code) {
      case code6:
        return [];
      case code:
        return node.Links;
      case code2:
      case code3:
        return findLinks(node);
      default:
        throw new Error(`Cannot resolve links from codec ${cid.code}`);
    }
  }
  return withTimeoutOption(links3);
}

// node_modules/ipfs-core/src/components/object/new.js
function createNew({ repo, preload: preload2 }) {
  async function _new(options = {}) {
    let data;
    if (options.template) {
      if (options.template === "unixfs-dir") {
        data = new UnixFS({ type: "directory" }).marshal();
      } else {
        throw new Error("unknown template");
      }
    }
    const buf2 = encode4({
      Data: data,
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    const cid = CID.createV0(hash3);
    await repo.blocks.put(cid, buf2, {
      signal: options.signal
    });
    if (options.preload !== false) {
      preload2(cid);
    }
    return cid;
  }
  return withTimeoutOption(_new);
}

// node_modules/ipfs-core/src/components/object/put.js
function createPut3({ repo, preload: preload2 }) {
  async function put(obj, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const buf2 = encode4(obj);
      const hash3 = await sha256.digest(buf2);
      const cid = CID.createV1(code, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      release();
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/src/components/object/stat.js
function createStat4({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  async function stat(cid, options = {}) {
    const node = await get3(cid, options);
    const serialized = encode4(node);
    const blockSize = serialized.length;
    const linkLength = node.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
    return {
      Hash: cid,
      NumLinks: node.Links.length,
      BlockSize: blockSize,
      LinksSize: blockSize - (node.Data || []).length,
      DataSize: (node.Data || []).length,
      CumulativeSize: blockSize + linkLength
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/src/components/object/patch/add-link.js
function createAddLink({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function addLink2(cid, link, options = {}) {
    const node = await get3(cid, options);
    return put({
      ...node,
      Links: node.Links.concat([link])
    }, options);
  }
  return withTimeoutOption(addLink2);
}

// node_modules/ipfs-core/src/components/object/patch/append-data.js
init_concat();
function createAppendData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function appendData(cid, data, options = {}) {
    const node = await get3(cid, options);
    const newData = concat4([node.Data || [], data]);
    return put({
      ...node,
      Data: newData
    }, options);
  }
  return withTimeoutOption(appendData);
}

// node_modules/ipfs-core/src/components/object/patch/rm-link.js
function createRmLink({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function rmLink(cid, link, options = {}) {
    const node = await get3(cid, options);
    const name22 = (typeof link === "string" ? link : link.Name) || "";
    node.Links = node.Links.filter((l) => l.Name !== name22);
    return put(node, options);
  }
  return withTimeoutOption(rmLink);
}

// node_modules/ipfs-core/src/components/object/patch/set-data.js
function createSetData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function setData(cid, data, options = {}) {
    const node = await get3(cid, options);
    return put({
      ...node,
      Data: data
    }, options);
  }
  return withTimeoutOption(setData);
}

// node_modules/ipfs-core/src/components/object/patch/index.js
var ObjectPatchAPI = class {
  constructor({ repo, preload: preload2 }) {
    this.addLink = createAddLink({ repo, preload: preload2 });
    this.appendData = createAppendData({ repo, preload: preload2 });
    this.rmLink = createRmLink({ repo, preload: preload2 });
    this.setData = createSetData({ repo, preload: preload2 });
  }
};

// node_modules/ipfs-core/src/components/object/index.js
var ObjectAPI = class {
  constructor({ repo, codecs: codecs2, preload: preload2 }) {
    this.data = createData({ repo, preload: preload2 });
    this.get = createGet4({ repo, preload: preload2 });
    this.links = createLinks({ repo, codecs: codecs2 });
    this.new = createNew({ repo, preload: preload2 });
    this.put = createPut3({ repo, preload: preload2 });
    this.stat = createStat4({ repo, preload: preload2 });
    this.patch = new ObjectPatchAPI({ repo, preload: preload2 });
  }
};

// node_modules/ipfs-core/src/components/repo/gc.js
var log37 = logger("ipfs:repo:gc");
function createGc({ repo, hashers }) {
  async function* gc2(options = {}) {
    const start = Date.now();
    let mfsRootCid;
    try {
      mfsRootCid = await loadMfsRoot({
        repo,
        hashers
      }, options);
      await repo.pins.pinRecursively(mfsRootCid);
      yield* repo.gc();
    } finally {
      if (mfsRootCid) {
        await repo.pins.unpin(mfsRootCid);
      }
    }
    log37(`Complete (${Date.now() - start}ms)`);
  }
  return withTimeoutOption(gc2);
}

// node_modules/ipfs-core/src/components/repo/stat.js
function createStat5({ repo }) {
  async function stat(options = {}) {
    const stats = await repo.stat();
    return {
      numObjects: BigInt(stats.numObjects.toString()),
      repoSize: BigInt(stats.repoSize.toString()),
      repoPath: stats.repoPath,
      version: `${stats.version}`,
      storageMax: BigInt(stats.storageMax.toString())
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-repo/src/constants.js
var repoVersion = 12;

// node_modules/ipfs-core/src/components/repo/version.js
function createVersion2({ repo }) {
  async function version4(options = {}) {
    try {
      await repo._checkInitialized(options);
    } catch (err2) {
      const match = [
        /Key not found in database \[\/version\]/,
        /ENOENT/,
        /repo is not initialized yet/
      ].some((m) => {
        return m.test(err2.message);
      });
      if (match) {
        return repoVersion;
      }
      throw err2;
    }
    return repo.version.get();
  }
  return withTimeoutOption(version4);
}

// node_modules/ipfs-core/src/components/repo/index.js
var RepoAPI = class {
  constructor({ repo, hashers }) {
    this.gc = createGc({ repo, hashers });
    this.stat = createStat5({ repo });
    this.version = createVersion2({ repo });
    this.setApiAddr = (addr) => repo.apiAddr.set(addr);
  }
};

// node_modules/ipfs-core/src/components/stats/bw.js
var import_err_code57 = __toESM(require_err_code(), 1);
function getBandwidthStats(libp2p, opts) {
  let stats;
  if (!libp2p.metrics) {
    stats = void 0;
  } else if (opts.peer) {
    stats = libp2p.metrics.forPeer(opts.peer);
  } else if (opts.proto) {
    stats = libp2p.metrics.forProtocol(opts.proto);
  } else {
    stats = libp2p.metrics.getGlobal();
  }
  if (!stats) {
    return {
      totalIn: BigInt(0),
      totalOut: BigInt(0),
      rateIn: 0,
      rateOut: 0
    };
  }
  const movingAverages = stats.getMovingAverages();
  const snapshot = stats.getSnapshot();
  return {
    totalIn: snapshot.dataReceived,
    totalOut: snapshot.dataSent,
    rateIn: movingAverages.dataReceived[6e4].movingAverage / 60,
    rateOut: movingAverages.dataSent[6e4].movingAverage / 60
  };
}
function createBw({ network }) {
  const bw = async function* (options = {}) {
    const { libp2p } = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats(libp2p, options);
      return;
    }
    const interval = options.interval || 1e3;
    let ms = -1;
    try {
      ms = typeof interval === "string" ? parse_duration_default(interval) || -1 : interval;
      if (!ms || ms < 0)
        throw new Error("invalid duration");
    } catch (err2) {
      throw (0, import_err_code57.default)(err2, "ERR_INVALID_POLL_INTERVAL");
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise((resolve7) => {
          timeoutId = setTimeout(resolve7, ms);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption(bw);
}

// node_modules/ipfs-core/src/components/stats/index.js
var StatsAPI = class {
  constructor({ repo, network }) {
    this.repo = createStat5({ repo });
    this.bw = createBw({ network });
    this.bitswap = createStat({ network });
  }
};

// node_modules/just-safe-get/index.mjs
var objectSafeGet = get2;
function get2(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}

// node_modules/ipfs-repo/src/index.js
var import_debug10 = __toESM(require_browser());
var import_err_code63 = __toESM(require_err_code());

// node_modules/ipfs-repo-migrations/migrations/migration-8/index.js
var import_debug2 = __toESM(require_browser(), 1);
var import_it_length = __toESM(require_it_length(), 1);
var log38 = (0, import_debug2.default)("ipfs:repo:migrator:migration-8");
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf2 = base322.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf2).multihash.bytes;
    const multihashStr = base322.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err2) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf2 = base322.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest15 = decode4(buf2);
    const multihash = base322.encode(CID.createV1(code6, digest15).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await (0, import_it_length.default)(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log38(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var migration = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToCid);
  }
};

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin.js
var import_minimal4 = __toESM(require_minimal2(), 1);
var $Reader2 = import_minimal4.default.Reader;
var $Writer2 = import_minimal4.default.Writer;
var $util2 = import_minimal4.default.util;
var $root2 = import_minimal4.default.roots["default"] || (import_minimal4.default.roots["default"] = {});
var ipfs = $root2.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode81(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode97(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root2.ipfs.pin.Set)
          return d;
        var m = new $root2.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
var import_fnv1a = __toESM(require_fnv1a(), 1);
var import_varint15 = __toESM(require_varint(), 1);

// node_modules/ipfs-repo-migrations/migrations/migration-9/utils.js
var PIN_DS_KEY = new Key("/local/pins");
var DEFAULT_FANOUT = 256;
var MAX_ITEMS = 8192;
var EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
var PinTypes2 = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey(cid) {
  return new Key(`/${base322.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
init_concat();

// node_modules/uint8arrays/esm/src/compare.js
function compare3(a, b) {
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] < b[i2]) {
      return -1;
    }
    if (a[i2] > b[i2]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
var PinSet = ipfs.pin.Set;
function readHeader2(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint15.default.decode(rootData);
  const vBytes = import_varint15.default.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed2, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed2, true);
  const encodedKey = fromString3(key.toString());
  const data = concat4([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString11(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader2(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode6(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name22) {
  const link = rootNode.Links.find((l) => l.Name === name22);
  if (!link) {
    throw new Error("No link found with name " + name22);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode6(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint15.default.encode(pbHeader.length);
    const headerBuf = concat4([header, pbHeader]);
    const fanoutLinks = [];
    for (let i2 = 0; i2 < DEFAULT_FANOUT; i2++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare3(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat4([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode4(child);
      const digest15 = await sha256.digest(buf2);
      const cid = CID.createV0(digest15);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode4(rootNode);
  const digest15 = await sha256.digest(buf2);
  const cid = CID.createV0(digest15);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}

// node_modules/ipfs-repo-migrations/migrations/migration-9/index.js
var import_it_length2 = __toESM(require_it_length(), 1);
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode6(pinRootBuf);
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.recursive)) + await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.recursive)) {
    counter++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode5(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.direct)) {
    counter++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode5(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(pinstore.queryKeys({}));
  for await (const { key, value: value2 } of pinstore.query({})) {
    counter++;
    const pin = decode7(value2);
    const cid2 = CID.create(
      pin.version || 0,
      pin.codec || code,
      decode4(base322.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes2.direct, directPins),
      await storeSet(blockstore, PinTypes2.recursive, recursivePins)
    ]
  };
  const buf2 = encode4(pinRoot);
  const digest15 = await sha256.digest(buf2);
  const cid = CID.createV0(digest15);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var migration2 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDAG);
  }
};

// node_modules/ipfs-repo-migrations/src/utils.js
var CONFIG_KEY = new Key("/config");
var VERSION_KEY = new Key("/version");
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}

// node_modules/ipfs-repo-migrations/migrations/migration-10/index.js
async function keysToBinary(name22, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name22} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name22}`);
  const upgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString3(key), value: value2 }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name22, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name22} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name22}`);
  const downgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: toString11(key), value: value2 }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap2(store) {
  if (store.child) {
    return unwrap2(store.child);
  }
  return store;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap2(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message6) => {
    onProgress(Math.round(migrated / datastores.length * 100), message6);
  };
  for (const { name: name22, store } of datastores) {
    await store.open();
    try {
      await fn(name22, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
var migration3 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch3(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err2) {
        error = err2;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve7, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err2, key, value2) => {
        if (err2 || key === void 0) {
          const handleEnd = (err22) => {
            if (err22) {
              reject(err22);
              return;
            }
            resolve7();
          };
          it.end(handleEnd);
          return;
        }
        batch3(fn(key, value2), next);
      };
      it.next(handleNext);
    }
  });
}

// node_modules/ipfs-repo-migrations/migrations/migration-11/index.js
var MFS_ROOT_KEY2 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY2)) {
    const root = await backends.root.get(MFS_ROOT_KEY2);
    await backends.datastore.put(MFS_ROOT_KEY2, root);
    await backends.root.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY2)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY2);
    await backends.root.put(MFS_ROOT_KEY2, root);
    await backends.datastore.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var migration4 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};

// node_modules/ipfs-repo-migrations/migrations/migration-12/index.js
var import_minimal10 = __toESM(require_minimal2(), 1);

// node_modules/ipfs-repo-migrations/migrations/migration-12/pb/proto-book.js
var import_minimal5 = __toESM(require_minimal2(), 1);
var $Reader3 = import_minimal5.default.Reader;
var $Writer3 = import_minimal5.default.Writer;
var $util3 = import_minimal5.default.util;
var $root3 = import_minimal5.default.roots["default"] || (import_minimal5.default.roots["default"] = {});
var Protocols = $root3.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Protocols2.prototype.protocols = $util3.emptyArray;
  Protocols2.encode = function encode81(m, w) {
    if (!w)
      w = $Writer3.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(10).string(m.protocols[i2]);
    }
    return w;
  };
  Protocols2.decode = function decode97(r, l) {
    if (!(r instanceof $Reader3))
      r = $Reader3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root3.Protocols)
      return d;
    var m = new $root3.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  return Protocols2;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-12/pb/address-book.js
var import_minimal6 = __toESM(require_minimal2(), 1);
var $Reader4 = import_minimal6.default.Reader;
var $Writer4 = import_minimal6.default.Writer;
var $util4 = import_minimal6.default.util;
var $root4 = import_minimal6.default.roots["default"] || (import_minimal6.default.roots["default"] = {});
var Addresses = $root4.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Addresses2.prototype.addrs = $util4.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode81(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i2 = 0; i2 < m.addrs.length; ++i2)
        $root4.Addresses.Address.encode(m.addrs[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root4.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode97(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root4.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root4.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Addresses)
      return d;
    var m = new $root4.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i2 = 0; i2 < d.addrs.length; ++i2) {
        if (typeof d.addrs[i2] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i2] = $root4.Addresses.Address.fromObject(d.addrs[i2]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root4.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root4.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root4.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address3(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Address3.prototype.multiaddr = $util4.newBuffer([]);
    Address3.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address3.prototype, "_isCertified", {
      get: $util4.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util4.oneOfSetter($oneOfFields)
    });
    Address3.encode = function encode81(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address3.decode = function decode97(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address3.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.Address)
        return d;
      var m = new $root4.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util4.base64.decode(d.multiaddr, m.multiaddr = $util4.newBuffer($util4.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address3.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util4.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util4.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address3.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
    };
    return Address3;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    CertifiedRecord.prototype.seq = $util4.Long ? $util4.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util4.newBuffer([]);
    CertifiedRecord.encode = function encode81(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode97(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.CertifiedRecord)
        return d;
      var m = new $root4.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util4.Long)
          (m.seq = $util4.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util4.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util4.base64.decode(d.raw, m.raw = $util4.newBuffer($util4.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util4.Long) {
          var n = new $util4.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util4.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util4.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util4.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util4.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-12/pb/peer.js
var import_minimal7 = __toESM(require_minimal2(), 1);
var $Reader5 = import_minimal7.default.Reader;
var $Writer5 = import_minimal7.default.Writer;
var $util5 = import_minimal7.default.util;
var $root5 = import_minimal7.default.roots["default"] || (import_minimal7.default.roots["default"] = {});
var Peer = $root5.Peer = (() => {
  function Peer3(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Peer3.prototype.addresses = $util5.emptyArray;
  Peer3.prototype.protocols = $util5.emptyArray;
  Peer3.prototype.metadata = $util5.emptyArray;
  Peer3.prototype.pubKey = null;
  Peer3.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer3.prototype, "_pubKey", {
    get: $util5.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer3.prototype, "_peerRecordEnvelope", {
    get: $util5.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Peer3.encode = function encode81(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root5.Address.encode(m.addresses[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(18).string(m.protocols[i2]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i2 = 0; i2 < m.metadata.length; ++i2)
        $root5.Metadata.encode(m.metadata[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer3.decode = function decode97(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root5.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root5.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Peer)
      return d;
    var m = new $root5.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i2] = $root5.Address.fromObject(d.addresses[i2]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i2 = 0; i2 < d.metadata.length; ++i2) {
        if (typeof d.metadata[i2] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i2] = $root5.Metadata.fromObject(d.metadata[i2]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util5.base64.decode(d.pubKey, m.pubKey = $util5.newBuffer($util5.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util5.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util5.newBuffer($util5.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root5.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root5.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util5.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util5.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  return Peer3;
})();
var Address = $root5.Address = (() => {
  function Address3(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Address3.prototype.multiaddr = $util5.newBuffer([]);
  Address3.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address3.prototype, "_isCertified", {
    get: $util5.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Address3.encode = function encode81(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address3.decode = function decode97(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Address)
      return d;
    var m = new $root5.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util5.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  return Address3;
})();
var Metadata2 = $root5.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata4.prototype.key = "";
  Metadata4.prototype.value = $util5.newBuffer([]);
  Metadata4.encode = function encode81(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata4.decode = function decode97(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root5.Metadata)
      return d;
    var m = new $root5.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util5.base64.decode(d.value, m.value = $util5.newBuffer($util5.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util5.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util5.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-12/pb/envelope.js
var import_minimal8 = __toESM(require_minimal2(), 1);
var $Reader6 = import_minimal8.default.Reader;
var $Writer6 = import_minimal8.default.Writer;
var $util6 = import_minimal8.default.util;
var $root6 = import_minimal8.default.roots["default"] || (import_minimal8.default.roots["default"] = {});
var Envelope = $root6.Envelope = (() => {
  function Envelope3(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Envelope3.prototype.publicKey = $util6.newBuffer([]);
  Envelope3.prototype.payloadType = $util6.newBuffer([]);
  Envelope3.prototype.payload = $util6.newBuffer([]);
  Envelope3.prototype.signature = $util6.newBuffer([]);
  Envelope3.encode = function encode81(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope3.decode = function decode97(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope3.fromObject = function fromObject(d) {
    if (d instanceof $root6.Envelope)
      return d;
    var m = new $root6.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util6.base64.decode(d.publicKey, m.publicKey = $util6.newBuffer($util6.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util6.base64.decode(d.payloadType, m.payloadType = $util6.newBuffer($util6.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util6.base64.decode(d.payload, m.payload = $util6.newBuffer($util6.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util6.base64.decode(d.signature, m.signature = $util6.newBuffer($util6.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util6.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util6.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util6.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util6.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util6.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util6.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util6.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util6.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal8.default.util.toJSONOptions);
  };
  return Envelope3;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-12/pb/peer-record.js
var import_minimal9 = __toESM(require_minimal2(), 1);
var $Reader7 = import_minimal9.default.Reader;
var $Writer7 = import_minimal9.default.Writer;
var $util7 = import_minimal9.default.util;
var $root7 = import_minimal9.default.roots["default"] || (import_minimal9.default.roots["default"] = {});
var PeerRecord = $root7.PeerRecord = (() => {
  function PeerRecord4(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  PeerRecord4.prototype.peerId = $util7.newBuffer([]);
  PeerRecord4.prototype.seq = $util7.Long ? $util7.Long.fromBits(0, 0, true) : 0;
  PeerRecord4.prototype.addresses = $util7.emptyArray;
  PeerRecord4.encode = function encode81(m, w) {
    if (!w)
      w = $Writer7.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root7.PeerRecord.AddressInfo.encode(m.addresses[i2], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord4.decode = function decode97(r, l) {
    if (!(r instanceof $Reader7))
      r = $Reader7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root7.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord4.fromObject = function fromObject(d) {
    if (d instanceof $root7.PeerRecord)
      return d;
    var m = new $root7.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util7.base64.decode(d.peerId, m.peerId = $util7.newBuffer($util7.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util7.Long)
        (m.seq = $util7.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util7.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i2] = $root7.PeerRecord.AddressInfo.fromObject(d.addresses[i2]);
      }
    }
    return m;
  };
  PeerRecord4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util7.newBuffer(d.peerId);
      }
      if ($util7.Long) {
        var n = new $util7.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util7.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util7.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util7.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root7.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
  };
  PeerRecord4.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    AddressInfo.prototype.multiaddr = $util7.newBuffer([]);
    AddressInfo.encode = function encode81(m, w) {
      if (!w)
        w = $Writer7.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode97(r, l) {
      if (!(r instanceof $Reader7))
        r = $Reader7.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root7.PeerRecord.AddressInfo)
        return d;
      var m = new $root7.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util7.base64.decode(d.multiaddr, m.multiaddr = $util7.newBuffer($util7.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util7.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util7.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord4;
})();

// node_modules/ipfs-repo-migrations/migrations/migration-12/index.js
import_minimal10.default.util.Long = void 0;
import_minimal10.default.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value2);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value2);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value: value2 });
    } else if (type === "keys") {
      peers[peerId].pubKey = value2;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = Peer.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, _prefix, peerId] = keyStr.split("/");
    peers[peerId] = Peer.decode(value2);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value: value2 } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value2);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
var migration5 = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};

// node_modules/ipfs-repo-migrations/migrations/index.js
var emptyMigration = {
  description: "Empty migration.",
  migrate: () => {
  },
  revert: () => {
  },
  empty: true
};
var migrations_default = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration,
  migration2,
  migration3,
  migration4,
  migration5
];

// node_modules/ipfs-repo-migrations/src/repo/init.js
var import_debug3 = __toESM(require_browser(), 1);

// node_modules/ipfs-repo-migrations/src/errors.js
var errors_exports3 = {};
__export(errors_exports3, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
var NonReversibleMigrationError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message6;
  }
};
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
var NotInitializedRepoError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message6;
  }
};
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
var RequiredParameterError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message6;
  }
};
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
var InvalidValueError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message6;
  }
};
InvalidValueError.code = "ERR_INVALID_VALUE";
var MissingRepoOptionsError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message6;
  }
};
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";

// node_modules/ipfs-repo-migrations/src/repo/init.js
var log39 = (0, import_debug3.default)("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log39(`Version entry present: ${versionCheck}`);
      log39(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log39("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}

// node_modules/ipfs-repo-migrations/src/repo/version.js
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString11(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version4, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString3(String(version4)));
  await store.close();
}

// node_modules/ipfs-repo-migrations/src/index.js
var import_debug4 = __toESM(require_browser());
var log40 = (0, import_debug4.default)("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path2);
  }
  try {
    for (const migration6 of migrations) {
      if (toVersion !== void 0 && migration6.version > toVersion) {
        break;
      }
      if (migration6.version <= currentVersion) {
        continue;
      }
      log40(`Migrating version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message6) => onProgress(migration6.version, percent.toFixed(2), message6);
          }
          await migration6.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration6.version - 1;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration6.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log40(`Migrating to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log40("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
async function revert(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path2);
  }
  log40(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration6 of reversedMigrationArray) {
      if (migration6.version <= toVersion) {
        break;
      }
      if (migration6.version > currentVersion) {
        continue;
      }
      log40(`Reverting migration version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message6) => onProgress(migration6.version, percent.toFixed(2), message6);
          }
          await migration6.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration6.version;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration6.version} exception was raised: ${e.message}`;
        throw e;
      }
      log40(`Reverting to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log40(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration6 of migrations) {
    if (migration6.version > toVersion) {
      break;
    }
    if (migration6.version > fromVersion) {
      if (checkReversibility && !migration6.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration6.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var errors = errors_exports3;

// node_modules/ipfs-repo/src/index.js
var import_bytes55 = __toESM(require_bytes());

// node_modules/ipfs-repo/src/version.js
var import_debug5 = __toESM(require_browser(), 1);

// node_modules/ipfs-repo/src/errors.js
var LockExistsError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
};
LockExistsError.code = "ERR_LOCK_EXISTS";
var NotFoundError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
};
NotFoundError.code = "ERR_NOT_FOUND";
var InvalidRepoVersionError = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
};
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
var ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
var ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
var ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";

// node_modules/ipfs-repo/src/utils/level.js
async function hasWithFallback2(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}

// node_modules/ipfs-repo/src/version.js
var log41 = (0, import_debug5.default)("ipfs:repo:version");
var versionKey = new Key("version");
function version2(store) {
  return {
    async exists() {
      return hasWithFallback2(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf2 = await getWithFallback2(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString11(buf2), 10);
    },
    set(version4) {
      return store.put(versionKey, fromString3(String(version4)));
    },
    async check(expected) {
      const version4 = await this.get();
      log41("comparing version: %s and %s", version4, expected);
      const compatibleVersion = version4 === 6 && expected === 7 || expected === 6 && version4 === 7;
      return version4 === expected || compatibleVersion;
    }
  };
}

// node_modules/ipfs-repo/src/config.js
var import_err_code58 = __toESM(require_err_code(), 1);
var Queue3 = PQueue.default ? PQueue.default : PQueue;
var configKey = new Key("config");
function config(store) {
  const setQueue = new Queue3({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString11(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value2 = objectSafeGet(config2, key);
      if (value2 === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value2;
    },
    set(key, value2, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code58.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value2 === void 0 || value2 instanceof Uint8Array) {
        throw (0, import_err_code58.default)(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value: value2
      }, options.signal));
    },
    replace(value2, options = {}) {
      if (!value2 || value2 instanceof Uint8Array) {
        throw (0, import_err_code58.default)(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value: value2
      }, options.signal));
    },
    async exists() {
      return hasWithFallback2(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value2 = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value2);
      }
      return _saveAll(config2);
    }
    return _saveAll(value2);
  }
  function _saveAll(config2) {
    const buf2 = fromString3(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}

// node_modules/sort-keys/node_modules/is-plain-obj/index.js
function isPlainObject(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
}

// node_modules/sort-keys/index.js
function sortKeys(object, options = {}) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare4 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare4);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value2 = object2[key];
      let newValue;
      if (deep && Array.isArray(value2)) {
        newValue = deepSortArray(value2);
      } else {
        newValue = deep && isPlainObject(value2) ? _sortKeys(value2) : value2;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}

// node_modules/ipfs-repo/src/spec.js
var specKey = new Key("datastore_spec");
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString11(buf2));
    },
    async set(spec2) {
      return store.put(specKey, fromString3(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}

// node_modules/ipfs-repo/src/api-addr.js
var apiFile = new Key("api");
function apiAddr(store) {
  return {
    async get() {
      const value2 = await store.get(apiFile);
      return value2 && value2.toString();
    },
    set(value2) {
      return store.put(apiFile, fromString3(value2.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}

// node_modules/ipfs-repo/src/idstore.js
var import_it_filter4 = __toESM(require_it_filter(), 1);
var import_it_drain6 = __toESM(require_it_drain(), 1);
var import_err_code59 = __toESM(require_err_code(), 1);
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await (0, import_it_drain6.default)(store.putMany(async function* () {
            for await (const { key, value: value2 } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value: value2 };
              }
              output.push({ key, value: value2 });
            }
          }()));
          output.end();
        } catch (err2) {
          output.end(err2);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_filter4.default)(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch3 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.delete(cid);
        },
        commit: (options) => {
          return batch3.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw (0, import_err_code59.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}

// node_modules/ipfs-repo/src/locks/memory.js
var import_debug6 = __toESM(require_browser());
var log42 = (0, import_debug6.default)("ipfs:repo:lock:memory");
var lockFile = "repo.lock";
var LOCKS = {};
async function lock2(dir) {
  const file = dir + "/" + lockFile;
  log42("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log42(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
var MemoryLock = {
  lock: lock2,
  locked
};

// node_modules/ipfs-repo/src/default-options.js
var default_options_default = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};

// node_modules/ipfs-repo/src/default-datastore.js
var default_datastore_default = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};

// node_modules/ipfs-repo/src/pin-manager.js
var import_err_code61 = __toESM(require_err_code(), 1);
var import_debug8 = __toESM(require_browser(), 1);
var import_it_first2 = __toESM(require_it_first(), 1);

// node_modules/ipfs-repo/src/utils/blockstore.js
var import_err_code60 = __toESM(require_err_code(), 1);
function cidToKey2(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw (0, import_err_code60.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base322.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode4(base322.decode(`b${key.toString().toLowerCase().substring(1)}`));
}

// node_modules/ipfs-repo/src/utils/walk-dag.js
var import_debug7 = __toESM(require_browser(), 1);
var log43 = (0, import_debug7.default)("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err2) {
    log43("Could not walk DAG for CID", cid.toString(), err2);
    throw err2;
  }
}

// node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _emitEvictions(cache19) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache19) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache19) {
    const item = cache19.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value2) {
    this.cache.set(key, value2);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value2, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value: value2,
        expiry
      });
    } else {
      this._set(key, { value: value2, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value2] of this) {
      yield value2;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value2] of this._entriesAscending()) {
      yield [key, value2.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value2] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value2, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/ipfs-repo/src/pin-manager.js
var CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code61.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var PinManager = class {
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = (0, import_debug8.default)("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey2(cid), encode5(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey2(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey2(cid), encode5(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode7(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode7(entry.value);
      const version4 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version4, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode7(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode7(entry.value);
      const version4 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version4, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types2 = [
          PinTypes.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types2);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types2, options) {
    if (!Array.isArray(types2)) {
      types2 = [types2];
    }
    const all12 = types2.includes(PinTypes.all);
    const direct = types2.includes(PinTypes.direct);
    const recursive2 = types2.includes(PinTypes.recursive);
    const indirect = types2.includes(PinTypes.indirect);
    if (recursive2 || direct || all12) {
      const result = await (0, import_it_first2.default)(this.pinstore.query({
        prefix: cidToKey2(cid).toString(),
        filters: [(entry) => {
          if (all12) {
            return true;
          }
          const pin = decode7(entry.value);
          return types2.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode7(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all12 || indirect) {
      const parentCid = await (0, import_it_first2.default)(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options = {}) {
    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
};

// node_modules/ipfs-repo/src/pinned-blockstore.js
var import_it_map9 = __toESM(require_it_map(), 1);
var import_err_code62 = __toESM(require_err_code(), 1);
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_map9.default)(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw (0, import_err_code62.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}

// node_modules/ipfs-repo/src/gc.js
var import_debug9 = __toESM(require_browser(), 1);
var import_it_parallel_batch3 = __toESM(require_it_parallel_batch(), 1);
var import_it_merge3 = __toESM(require_it_merge(), 1);
var import_it_map10 = __toESM(require_it_map(), 1);
var import_it_filter5 = __toESM(require_it_filter(), 1);
var log44 = (0, import_debug9.default)("ipfs:repo:gc");
var ERR_NOT_FOUND4 = notFoundError().code;
var BLOCK_RM_CONCURRENCY2 = 256;
var MFS_ROOT_KEY3 = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log44("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log44(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY3);
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND4) {
        log44("No blocks in MFS");
        return;
      }
      throw err2;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = (0, import_it_merge3.default)(
    (0, import_it_map10.default)(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    (0, import_it_map10.default)(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of (0, import_it_merge3.default)(pinsSource, mfsSource)) {
    output.add(base322.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base322.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err2) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err2.message}`)
          };
        }
        return { cid };
      } catch (err2) {
        const msg = `Could delete block with CID ${cid}`;
        log44(msg, err2);
        return { err: new Error(msg + `: ${err2.message}`) };
      }
    };
  };
  yield* pipe(
    (0, import_it_parallel_batch3.default)((0, import_it_map10.default)(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY2),
    (source) => (0, import_it_filter5.default)(source, Boolean)
  );
  log44(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}

// node_modules/ipfs-repo/src/index.js
var log45 = (0, import_debug10.default)("ipfs:repo");
var noLimit = Number.MAX_SAFE_INTEGER;
var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
var Repo = class {
  constructor(path2, loadCodec, backends, options) {
    if (typeof path2 !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = merge_options_default(default_options_default, options);
    this.closed = true;
    this.path = path2;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version2(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path2,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  async init(config2) {
    log45("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err2) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw (0, import_err_code63.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log45("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log45("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log45("creating datastore");
      await this.datastore.open();
      log45("creating blocks");
      await this.blocks.open();
      log45("creating keystore");
      await this.keys.open();
      log45("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log45("all opened");
    } catch (err2) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err22) {
          log45("error removing lock", err22);
        }
      }
      throw err2;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err2) {
      if (err2.message !== "Already open") {
        throw err2;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw (0, import_err_code63.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log45("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code63.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err2;
    }
    if (!config2) {
      throw (0, import_err_code63.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  async close() {
    if (this.closed) {
      throw (0, import_err_code63.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log45("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err2) {
      if (err2.code !== ERR_REPO_NOT_INITIALIZED && !err2.message.startsWith("ENOENT")) {
        throw err2;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log45("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version4, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version4,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw (0, import_err_code63.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log45(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log45(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get("Datastore.StorageMax");
      return BigInt((0, import_bytes55.default)(max));
    } catch (err2) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value: value2 } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value2.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size };
  }
};
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path2, loadCodec, backends, options) {
  return new Repo(path2, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}

// node_modules/datastore-level/node_modules/it-filter/dist/src/index.js
async function* filter5(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/datastore-level/node_modules/it-map/dist/src/index.js
async function* map11(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}

// node_modules/datastore-level/node_modules/it-take/dist/src/index.js
async function* take2(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}

// node_modules/it-sort/node_modules/it-all/dist/src/index.js
async function all4(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/it-sort/dist/src/index.js
async function* sort(source, sorter) {
  const arr = await all4(source);
  yield* arr.sort(sorter);
}

// node_modules/datastore-level/src/index.js
var import_level3 = __toESM(require_browser3());
var LevelDatastore = class extends BaseDatastore {
  constructor(path2, opts = {}) {
    super();
    this.db = typeof path2 === "string" ? new import_level3.Level(path2, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path2;
    this.opts = {
      createIfMissing: true,
      compression: false,
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err2) {
      throw errors_exports.dbOpenFailedError(err2);
    }
  }
  async put(key, value2) {
    try {
      await this.db.put(key.toString(), value2);
    } catch (err2) {
      throw errors_exports.dbWriteFailedError(err2);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        throw errors_exports.notFoundError(err2);
      throw errors_exports.dbWriteFailedError(err2);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        return false;
      throw err2;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err2) {
      throw errors_exports.dbDeleteFailedError(err2);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value2) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value: value2
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter5(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter5(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take2(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = map11(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter5(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter5(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take2(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    const iterator = this.db.iterator(iteratorOpts);
    if (iterator[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator);
    }
    if (iterator.next != null && iterator.end != null) {
      return oldLevelIteratorToIterator(iterator);
    }
    throw new Error("Level returned incompatible iterator");
  }
};
async function* levelIteratorToIterator(li) {
  for await (const [key, value2] of li) {
    yield { key: new Key(key, false), value: value2 };
  }
  await li.close();
}
function oldLevelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve7, reject) => {
          li.next((err2, key, value2) => {
            if (err2)
              return reject(err2);
            if (key == null) {
              return li.end((err3) => {
                if (err3)
                  return reject(err3);
                resolve7({ done: true, value: void 0 });
              });
            }
            resolve7({ done: false, value: { key: new Key(key, false), value: value2 } });
          });
        }),
        return: () => new Promise((resolve7, reject) => {
          li.end((err2) => {
            if (err2)
              return reject(err2);
            resolve7({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}

// node_modules/blockstore-datastore-adapter/src/index.js
var import_it_drain8 = __toESM(require_it_drain());
var import_err_code64 = __toESM(require_err_code());

// node_modules/blockstore-core/src/base.js
var import_it_drain7 = __toESM(require_it_drain());
var import_it_filter7 = __toESM(require_it_filter());
var import_it_take4 = __toESM(require_it_take());
var import_it_all5 = __toESM(require_it_all());
var sortAll2 = (iterable, sorter) => {
  return async function* () {
    const values = await (0, import_it_all5.default)(iterable);
    yield* values.sort(sorter);
  }();
};
var BaseBlockstore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value: value2 } of source) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain7.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain7.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = (0, import_it_filter7.default)(it, () => i2++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = (0, import_it_filter7.default)(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
};

// node_modules/blockstore-datastore-adapter/src/index.js
function cidToKey3(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw (0, import_err_code64.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base322.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID.createV1(code6, decode4(base322.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base322.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad2.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc2.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc2.decode("z" + input);
  } else {
    decoder = (input) => base322.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i2 = 1; i2 < prefix.length; i2++) {
    try {
      bytes2 = decoder(prefix.substring(0, i2));
    } catch (err2) {
      if (err2.message !== "Unexpected end of data") {
        throw err2;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base322.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter14) => (pair2) => {
        return filter14({ key: keyToCid2(pair2.key), value: pair2.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order({ key: keyToCid2(a.key), value: a.value }, { key: keyToCid2(b.key), value: b.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter14) => (key) => {
        return filter14(keyToCid2(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order(keyToCid2(a), keyToCid2(b));
      }
    ) : void 0
  };
}
var BlockstoreDatastoreAdapter = class extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const { key, value: value2 } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid2(key), value: value2 };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid2(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey3(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value2, options) {
    await this.child.put(cidToKey3(cid), value2, options);
  }
  async *putMany(blocks, options) {
    const output = pushable({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await (0, import_it_drain8.default)(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey3(block.key);
            const exists2 = await store.has(key, options);
            if (!exists2) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err2) {
        output.end(err2);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey3(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey3(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable({
      objectMode: true
    });
    (0, import_it_drain8.default)(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey3(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err2) => {
      out.end(err2);
    });
    return out;
  }
};

// node_modules/ipfs-core-config/src/repo.browser.js
function createRepo2(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(
      new LevelDatastore(`${repoPath}/blocks`, {
        prefix: "",
        version: 2
      })
    ),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}

// node_modules/ipfs-core/src/components/libp2p.js
var import_err_code131 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var import_err_code65 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity_exports17 = {};
__export(identity_exports17, {
  identity: () => identity17
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/vendor/base-x.js
function base14(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src11 = base14;
var _brrp__multiformats_scope_baseX11 = src11;
var base_x_default11 = _brrp__multiformats_scope_baseX11;

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bytes.js
var empty11 = new Uint8Array(0);
var equals24 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce11 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString17 = (str) => new TextEncoder().encode(str);
var toString18 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base.js
var Encoder11 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder11 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or12(this, decoder);
  }
};
var ComposedDecoder11 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or12(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or12 = (left, right) => new ComposedDecoder11({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec11 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder11(name22, prefix, baseEncode);
    this.decoder = new Decoder11(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from19 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec11(name22, prefix, encode81, decode97);
var baseX11 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default11(alphabet16, name22);
  return from19({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce11(decode97(text))
  });
};
var decode57 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode48 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464811 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from19({
    prefix,
    name: name22,
    encode(input) {
      return encode48(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode57(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity17 = from19({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString18(buf2),
  decode: (str) => fromString17(str)
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base2.js
var base2_exports9 = {};
__export(base2_exports9, {
  base2: () => base210
});
var base210 = rfc464811({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base8.js
var base8_exports9 = {};
__export(base8_exports9, {
  base8: () => base89
});
var base89 = rfc464811({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base10_exports9 = {};
__export(base10_exports9, {
  base10: () => base109
});
var base109 = baseX11({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base16.js
var base16_exports9 = {};
__export(base16_exports9, {
  base16: () => base169,
  base16upper: () => base16upper9
});
var base169 = rfc464811({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper9 = rfc464811({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base32.js
var base32_exports9 = {};
__export(base32_exports9, {
  base32: () => base3211,
  base32hex: () => base32hex11,
  base32hexpad: () => base32hexpad11,
  base32hexpadupper: () => base32hexpadupper11,
  base32hexupper: () => base32hexupper11,
  base32pad: () => base32pad11,
  base32padupper: () => base32padupper11,
  base32upper: () => base32upper11,
  base32z: () => base32z11
});
var base3211 = rfc464811({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper11 = rfc464811({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad11 = rfc464811({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper11 = rfc464811({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex11 = rfc464811({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper11 = rfc464811({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad11 = rfc464811({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper11 = rfc464811({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z11 = rfc464811({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base36.js
var base36_exports9 = {};
__export(base36_exports9, {
  base36: () => base369,
  base36upper: () => base36upper9
});
var base369 = baseX11({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper9 = baseX11({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base58.js
var base58_exports9 = {};
__export(base58_exports9, {
  base58btc: () => base58btc11,
  base58flickr: () => base58flickr11
});
var base58btc11 = baseX11({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr11 = baseX11({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base64.js
var base64_exports9 = {};
__export(base64_exports9, {
  base64: () => base6410,
  base64pad: () => base64pad10,
  base64url: () => base64url10,
  base64urlpad: () => base64urlpad10
});
var base6410 = rfc464811({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad10 = rfc464811({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url10 = rfc464811({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad10 = rfc464811({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports9 = {};
__export(base256emoji_exports9, {
  base256emoji: () => base256emoji9
});
var alphabet9 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars9 = alphabet9.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes9 = alphabet9.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode49(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars9[c];
    return p;
  }, "");
}
function decode58(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes9[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji9 = from19({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode49,
  decode: decode58
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports9 = {};
__export(sha2_browser_exports9, {
  sha256: () => sha2569,
  sha512: () => sha5129
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/vendor/varint.js
var encode_110 = encode50;
var MSB10 = 128;
var REST10 = 127;
var MSBALL10 = ~REST10;
var INT10 = Math.pow(2, 31);
function encode50(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT10) {
    out[offset++] = num & 255 | MSB10;
    num /= 128;
  }
  while (num & MSBALL10) {
    out[offset++] = num & 255 | MSB10;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode50.bytes = offset - oldOffset + 1;
  return out;
}
var decode59 = read10;
var MSB$110 = 128;
var REST$110 = 127;
function read10(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read10.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$110);
  read10.bytes = counter - offset;
  return res;
}
var N110 = Math.pow(2, 7);
var N210 = Math.pow(2, 14);
var N310 = Math.pow(2, 21);
var N410 = Math.pow(2, 28);
var N510 = Math.pow(2, 35);
var N610 = Math.pow(2, 42);
var N710 = Math.pow(2, 49);
var N810 = Math.pow(2, 56);
var N910 = Math.pow(2, 63);
var length12 = function(value2) {
  return value2 < N110 ? 1 : value2 < N210 ? 2 : value2 < N310 ? 3 : value2 < N410 ? 4 : value2 < N510 ? 5 : value2 < N610 ? 6 : value2 < N710 ? 7 : value2 < N810 ? 8 : value2 < N910 ? 9 : 10;
};
var varint16 = {
  encode: encode_110,
  decode: decode59,
  encodingLength: length12
};
var _brrp_varint10 = varint16;
var varint_default10 = _brrp_varint10;

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/varint.js
var decode60 = (data, offset = 0) => {
  const code22 = varint_default10.decode(data, offset);
  return [code22, varint_default10.decode.bytes];
};
var encodeTo10 = (int, target, offset = 0) => {
  varint_default10.encode(int, target, offset);
  return target;
};
var encodingLength10 = (int) => {
  return varint_default10.encodingLength(int);
};

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/digest.js
var create15 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength10(code22);
  const digestOffset = sizeOffset + encodingLength10(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo10(code22, bytes2, 0);
  encodeTo10(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest10(code22, size, digest15, bytes2);
};
var decode61 = (multihash) => {
  const bytes2 = coerce11(multihash);
  const [code22, sizeOffset] = decode60(bytes2);
  const [size, digestOffset] = decode60(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest10(code22, size, digest15, bytes2);
};
var equals25 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals24(a.bytes, data.bytes);
  }
};
var Digest10 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/hasher.js
var from20 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher9(name22, code22, encode81);
var Hasher9 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create15(this.code, result) : result.then((digest15) => create15(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha9 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha2569 = from20({
  name: "sha2-256",
  code: 18,
  encode: sha9("SHA-256")
});
var sha5129 = from20({
  name: "sha2-512",
  code: 19,
  encode: sha9("SHA-512")
});

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var identity_exports18 = {};
__export(identity_exports18, {
  identity: () => identity18
});
var code15 = 0;
var name15 = "identity";
var encode51 = coerce11;
var digest9 = (input) => create15(code15, encode51(input));
var identity18 = { code: code15, name: name15, encode: encode51, digest: digest9 };

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/codecs/json.js
var textEncoder12 = new TextEncoder();
var textDecoder11 = new TextDecoder();

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/cid.js
var format9 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV010(
        bytes2,
        baseCache9(link),
        base30 || base58btc11.encoder
      );
    default:
      return toStringV110(
        bytes2,
        baseCache9(link),
        base30 || base3211.encoder
      );
  }
};
var cache10 = /* @__PURE__ */ new WeakMap();
var baseCache9 = (cid) => {
  const baseCache16 = cache10.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache10.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID10 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE10) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE10) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID10.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create15(code22, digest15);
        return CID10.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID10.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals25(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format9(this, base30);
  }
  toJSON() {
    return { "/": format9(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID10) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID10(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID10(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol10] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode61(multihash);
      return CID10.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE10) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`
          );
        } else {
          return new CID10(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID10(version4, code22, digest15.bytes);
        return new CID10(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID10.create(0, DAG_PB_CODE10, digest15);
  }
  static createV1(code22, digest15) {
    return CID10.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID10.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID10.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce11(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest10(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID10.createV0(digest15) : CID10.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode60(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE10;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes10(source, base30);
    const cid = CID10.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache9(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes10 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc11;
      return [
        base58btc11.prefix,
        decoder.decode(`${base58btc11.prefix}${source}`)
      ];
    }
    case base58btc11.prefix: {
      const decoder = base30 || base58btc11;
      return [base58btc11.prefix, decoder.decode(source)];
    }
    case base3211.prefix: {
      const decoder = base30 || base3211;
      return [base3211.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV010 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc11.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV110 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE10 = 112;
var SHA_256_CODE10 = 18;
var encodeCID10 = (version4, code22, multihash) => {
  const codeOffset = encodingLength10(version4);
  const hashOffset = codeOffset + encodingLength10(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo10(version4, bytes2, 0);
  encodeTo10(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol10 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/node_modules/multiformats/src/basics.js
var bases9 = { ...identity_exports17, ...base2_exports9, ...base8_exports9, ...base10_exports9, ...base16_exports9, ...base32_exports9, ...base36_exports9, ...base58_exports9, ...base64_exports9, ...base256emoji_exports9 };
var hashes9 = { ...sha2_browser_exports9, ...identity_exports18 };

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array9(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe9(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array9(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec11(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string8 = createCodec11("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii8 = createCodec11("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe9(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES8 = {
  utf8: string8,
  "utf-8": string8,
  hex: bases9.base16,
  latin1: ascii8,
  ascii: ascii8,
  binary: ascii8,
  ...bases9
};
var bases_default8 = BASES8;

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/from-string.js
function fromString18(string14, encoding = "utf8") {
  const base30 = bases_default8[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array9(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/equals.js
function equals26(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/utils.js
var import_reader3 = __toESM(require_reader(), 1);
var import_reader_buffer3 = __toESM(require_reader_buffer(), 1);
var import_writer4 = __toESM(require_writer(), 1);
var import_writer_buffer3 = __toESM(require_writer_buffer(), 1);
var import_minimal11 = __toESM(require_minimal(), 1);
function configure3() {
  import_minimal11.default._configure();
  import_reader3.default._configure(import_reader_buffer3.default);
  import_writer4.default._configure(import_writer_buffer3.default);
}
configure3();
var methods5 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader3(obj) {
  for (const method of methods5) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader4(buf2) {
  return patchReader3(new import_reader3.default(buf2));
}
function patchWriter3(obj) {
  for (const method of methods5) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer3() {
  return patchWriter3(import_writer4.default.create());
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage4(buf2, codec) {
  const r = reader4(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage4(message6, codec) {
  const w = writer3();
  codec.encode(message6, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES4;
(function(CODEC_TYPES6) {
  CODEC_TYPES6[CODEC_TYPES6["VARINT"] = 0] = "VARINT";
  CODEC_TYPES6[CODEC_TYPES6["BIT64"] = 1] = "BIT64";
  CODEC_TYPES6[CODEC_TYPES6["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES6[CODEC_TYPES6["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES4 || (CODEC_TYPES4 = {}));
function createCodec12(name22, type, encode81, decode97) {
  return {
    name: name22,
    type,
    encode: encode81,
    decode: decode97
  };
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/codecs/message.js
function message4(encode81, decode97) {
  return createCodec12("message", CODEC_TYPES4.LENGTH_DELIMITED, encode81, decode97);
}

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope2;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message4((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (opts.writeDefaults === true || obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (opts.writeDefaults === true || obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (opts.writeDefaults === true || obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader6.bytes();
              break;
            case 2:
              obj.payloadType = reader6.bytes();
              break;
            case 3:
              obj.payload = reader6.bytes();
              break;
            case 5:
              obj.signature = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage4(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf2) => {
    return decodeMessage4(buf2, Envelope3.codec());
  };
})(Envelope2 || (Envelope2 = {}));

// node_modules/byte-access/dist/src/index.js
function accessor(buf2) {
  if (buf2 instanceof Uint8Array) {
    return {
      get(index) {
        return buf2[index];
      },
      set(index, value2) {
        buf2[index] = value2;
      }
    };
  }
  return {
    get(index) {
      return buf2.get(index);
    },
    set(index, value2) {
      buf2.set(index, value2);
    }
  };
}

// node_modules/longbits/dist/src/index.js
var TWO_32 = 4294967296;
var LongBits = class {
  constructor(hi = 0, lo = 0) {
    this.hi = hi;
    this.lo = lo;
  }
  toBigInt(unsigned2) {
    if (unsigned2 === true) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  toNumber(unsigned2) {
    return Number(this.toBigInt(unsigned2));
  }
  zzDecode() {
    const mask = -(this.lo & 1);
    const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    const hi = (this.hi >>> 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  zzEncode() {
    const mask = this.hi >> 31;
    const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    const lo = (this.lo << 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  toBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    while (this.hi > 0) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
      this.hi >>>= 7;
    }
    while (this.lo > 127) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = this.lo >>> 7;
    }
    access.set(offset++, this.lo);
  }
  static fromBigInt(value2) {
    if (value2 === 0n) {
      return new LongBits();
    }
    const negative = value2 < 0;
    if (negative) {
      value2 = -value2;
    }
    let hi = Number(value2 >> 32n) | 0;
    let lo = Number(value2 - (BigInt(hi) << 32n)) | 0;
    if (negative) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > TWO_32) {
        lo = 0;
        if (++hi > TWO_32) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromNumber(value2) {
    if (value2 === 0) {
      return new LongBits();
    }
    const sign5 = value2 < 0;
    if (sign5) {
      value2 = -value2;
    }
    let lo = value2 >>> 0;
    let hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign5) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    const bits2 = new LongBits();
    let i2 = 0;
    if (buf2.length - offset > 4) {
      for (; i2 < 4; ++i2) {
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
      bits2.lo = (bits2.lo | (access.get(offset) & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (access.get(offset) & 127) >> 4) >>> 0;
      if (access.get(offset++) < 128) {
        return bits2;
      }
      i2 = 0;
    } else {
      for (; i2 < 4; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    if (buf2.length - offset > 4) {
      for (; i2 < 5; ++i2) {
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    } else if (offset < buf2.byteLength) {
      for (; i2 < 5; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    throw RangeError("invalid varint encoding");
  }
};

// node_modules/uint8-varint/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array10(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe10(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array10(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/uint8-varint/dist/src/index.js
var N111 = Math.pow(2, 7);
var N211 = Math.pow(2, 14);
var N311 = Math.pow(2, 21);
var N411 = Math.pow(2, 28);
var N511 = Math.pow(2, 35);
var N611 = Math.pow(2, 42);
var N711 = Math.pow(2, 49);
var N811 = Math.pow(2, 56);
var N911 = Math.pow(2, 63);
var unsigned = {
  encodingLength(value2) {
    if (value2 < N111) {
      return 1;
    }
    if (value2 < N211) {
      return 2;
    }
    if (value2 < N311) {
      return 3;
    }
    if (value2 < N411) {
      return 4;
    }
    if (value2 < N511) {
      return 5;
    }
    if (value2 < N611) {
      return 6;
    }
    if (value2 < N711) {
      return 7;
    }
    if (value2 < N811) {
      return 8;
    }
    if (value2 < N911) {
      return 9;
    }
    return 10;
  },
  encode(value2, buf2, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf2 == null) {
      buf2 = allocUnsafe10(unsigned.encodingLength(value2));
    }
    LongBits.fromNumber(value2).toBytes(buf2, offset);
    return buf2;
  },
  decode(buf2, offset = 0) {
    return LongBits.fromBytes(buf2, offset).toNumber(true);
  }
};

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _a2;
var RecordEnvelope = class {
  constructor(init) {
    const { peerId, payloadType, payload, signature } = init;
    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope2.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  equals(other) {
    return equals26(this.marshal(), other.marshal());
  }
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey2(this.peerId.publicKey);
    return await key.verify(signData.subarray(), this.signature);
  }
};
_a2 = RecordEnvelope;
RecordEnvelope.createFromProtobuf = async (data) => {
  const envelopeData = Envelope2.decode(data);
  const peerId = await peerIdFromKeys(envelopeData.publicKey);
  return new RecordEnvelope({
    peerId,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
};
RecordEnvelope.seal = async (record, peerId) => {
  if (peerId.privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const key = await unmarshalPrivateKey3(peerId.privateKey);
  const signature = await key.sign(signData.subarray());
  return new RecordEnvelope({
    peerId,
    payloadType,
    payload,
    signature
  });
};
RecordEnvelope.openAndCertify = async (data, domain) => {
  const envelope = await RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw (0, import_err_code65.default)(new Error("envelope signature is not valid for the given domain"), codes2.ERR_SIGNATURE_NOT_VALID);
  }
  return envelope;
};
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString18(domain);
  const domainLength = unsigned.encode(domainUint8Array.byteLength);
  const payloadTypeLength = unsigned.encode(payloadType.length);
  const payloadLength = unsigned.encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort5 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort5);
  return a.sort(sort5).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord2;
(function(PeerRecord4) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message4((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader6, length23) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length23 == null ? reader6.len : reader6.pos + length23;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader6.bytes();
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage4(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf2) => {
      return decodeMessage4(buf2, AddressInfo2.codec());
    };
  })(AddressInfo = PeerRecord4.AddressInfo || (PeerRecord4.AddressInfo = {}));
  let _codec;
  PeerRecord4.codec = () => {
    if (_codec == null) {
      _codec = message4((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (opts.writeDefaults === true || obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(26);
            PeerRecord4.AddressInfo.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader6.bytes();
              break;
            case 2:
              obj.seq = reader6.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord4.AddressInfo.codec().decode(reader6, reader6.uint32()));
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord4.encode = (obj) => {
    return encodeMessage4(obj, PeerRecord4.codec());
  };
  PeerRecord4.decode = (buf2) => {
    return decodeMessage4(buf2, PeerRecord4.codec());
  };
})(PeerRecord2 || (PeerRecord2 = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord3 = class {
  constructor(init) {
    this.domain = PeerRecord3.DOMAIN;
    this.codec = PeerRecord3.CODEC;
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord2.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  equals(other) {
    if (!(other instanceof PeerRecord3)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
PeerRecord3.createFromProtobuf = (buf2) => {
  const peerRecord = PeerRecord2.decode(buf2);
  const peerId = peerIdFromBytes(peerRecord.peerId);
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new PeerRecord3({ peerId, multiaddrs, seqNumber });
};
PeerRecord3.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
PeerRecord3.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;

// node_modules/@libp2p/interface-registrar/dist/src/index.js
var topologySymbol = Symbol.for("@libp2p/topology");
function isTopology(other) {
  return other != null && Boolean(other[topologySymbol]);
}

// node_modules/@libp2p/topology/dist/src/index.js
var noop2 = () => {
};
var TopologyImpl = class {
  constructor(init) {
    this.min = init.min ?? 0;
    this.max = init.max ?? Infinity;
    this.peers = /* @__PURE__ */ new Set();
    this.onConnect = init.onConnect ?? noop2;
    this.onDisconnect = init.onDisconnect ?? noop2;
  }
  get [Symbol.toStringTag]() {
    return topologySymbol.toString();
  }
  get [topologySymbol]() {
    return true;
  }
  async setRegistrar(registrar) {
    this.registrar = registrar;
  }
  disconnect(peerId) {
    this.onDisconnect(peerId);
  }
};
function createTopology(init) {
  return new TopologyImpl(init);
}

// node_modules/@libp2p/interfaces/dist/src/events.js
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventEmitter_listeners;
var EventEmitter2 = class extends EventTarget {
  constructor() {
    super(...arguments);
    _EventEmitter_listeners.set(this, /* @__PURE__ */ new Map());
  }
  listenerCount(type) {
    const listeners = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      list = [];
      __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_EventEmitter_listeners = /* @__PURE__ */ new WeakMap();
var CustomEventPolyfill = class extends Event {
  constructor(message6, data) {
    super(message6, data);
    this.detail = data?.detail;
  }
};
var CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
var MessageCache = class {
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    this.gossip = gossip;
    this.msgs = /* @__PURE__ */ new Map();
    this.history = [];
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i2 = 0; i2 < historyCapacity; i2++) {
      this.history[i2] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry && !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  get(msgId2) {
    return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
  }
  getWithIWantCount(msgIdStr, p) {
    const msg = this.msgs.get(msgIdStr);
    if (!msg) {
      return null;
    }
    const count = (msg.iwantCounts.get(p) ?? 0) + 1;
    msg.iwantCounts.set(p, count);
    return { msg: msg.message, count };
  }
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < this.gossip; i2++) {
      this.history[i2].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if (msg && msg.validated && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (!msgIds) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    const { message: message6, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message6, originatingPeers };
  }
  shift() {
    const last14 = this.history[this.history.length - 1];
    last14.forEach((entry) => {
      this.msgs.delete(entry.msgIdStr);
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
var import_rpc = __toESM(require_rpc3(), 1);
var { RPC } = import_rpc.default;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
var second = 1e3;
var minute2 = 60 * second;
var FloodsubID = "/floodsub/1.0.0";
var GossipsubIDv10 = "/meshsub/1.0.0";
var GossipsubIDv11 = "/meshsub/1.1.0";
var GossipsubD = 6;
var GossipsubDlo = 4;
var GossipsubDhi = 12;
var GossipsubDscore = 4;
var GossipsubDout = 2;
var GossipsubHistoryLength = 5;
var GossipsubHistoryGossip = 3;
var GossipsubDlazy = 6;
var GossipsubGossipFactor = 0.25;
var GossipsubGossipRetransmission = 3;
var GossipsubHeartbeatInitialDelay = 100;
var GossipsubHeartbeatInterval = second;
var GossipsubFanoutTTL = minute2;
var GossipsubPrunePeers = 16;
var GossipsubPruneBackoff = minute2;
var GossipsubPruneBackoffTicks = 15;
var GossipsubConnectionTimeout = 30 * second;
var GossipsubDirectConnectTicks = 300;
var GossipsubDirectConnectInitialDelay = second;
var GossipsubOpportunisticGraftTicks = 60;
var GossipsubOpportunisticGraftPeers = 2;
var GossipsubGraftFloodThreshold = 10 * second;
var GossipsubMaxIHaveLength = 5e3;
var GossipsubMaxIHaveMessages = 10;
var GossipsubIWantFollowupTime = 3 * second;
var GossipsubSeenTTL = 2 * minute2;
var TimeCacheDuration = 120 * 1e3;
var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/create-gossip-rpc.js
function createGossipRpc(messages3 = [], control) {
  return {
    subscriptions: [],
    messages: messages3,
    control: control ? {
      graft: control.graft || [],
      prune: control.prune || [],
      ihave: control.ihave || [],
      iwant: control.iwant || []
    } : void 0
  };
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
function messageIdToString(msgId2) {
  return toString11(msgId2, "base64");
}

// node_modules/@libp2p/interface-pubsub/dist/src/index.js
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var MessageAcceptance;
(function(MessageAcceptance2) {
  MessageAcceptance2["Accept"] = "accept";
  MessageAcceptance2["Ignore"] = "ignore";
  MessageAcceptance2["Reject"] = "reject";
})(MessageAcceptance || (MessageAcceptance = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case MessageAcceptance.Ignore:
      return RejectReason.Ignore;
    case MessageAcceptance.Reject:
      return RejectReason.Reject;
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId) {
        throw Error("Must provide PeerId");
      }
      if (peerId.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: peerId.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/constants.js
var ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
var import_err_code66 = __toESM(require_err_code(), 1);
var defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
var defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw (0, import_err_code66.default)(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw (0, import_err_code66.default)(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw (0, import_err_code66.default)(new Error("missing application specific score function"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw (0, import_err_code66.default)(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw (0, import_err_code66.default)(new Error("invalid IPColocationFactorThreshold; must be at least 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw (0, import_err_code66.default)(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw (0, import_err_code66.default)(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw (0, import_err_code66.default)(new Error("invalid DecayInterval; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw (0, import_err_code66.default)(new Error("invalid DecayToZero; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw (0, import_err_code66.default)(new Error("invalid topic weight; must be >= 0"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw (0, import_err_code66.default)(new Error("invalid TimeInMeshQuantum; must be non zero"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw (0, import_err_code66.default)(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw (0, import_err_code66.default)(new Error("invalid TimeInMeshQuantum; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw (0, import_err_code66.default)(new Error("invalid TimeInMeshCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw (0, import_err_code66.default)(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw (0, import_err_code66.default)(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw (0, import_err_code66.default)(new Error("invalid FirstMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw (0, import_err_code66.default)(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw (0, import_err_code66.default)(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw (0, import_err_code66.default)(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw (0, import_err_code66.default)(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw (0, import_err_code66.default)(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
var import_err_code67 = __toESM(require_err_code(), 1);
var defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
var import_denque = __toESM(require_denque(), 1);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
var MessageDeliveries = class {
  constructor() {
    this.records = /* @__PURE__ */ new Map();
    this.queue = new import_denque.default();
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeen: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
};

// node_modules/@libp2p/components/dist/src/index.js
var import_err_code68 = __toESM(require_err_code());

// node_modules/@libp2p/interfaces/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}

// node_modules/@libp2p/components/dist/src/index.js
function isInitializable(obj) {
  return obj != null && typeof obj.init === "function";
}
var Components = class {
  constructor(init = {}) {
    this.started = false;
    if (init.peerId != null) {
      this.setPeerId(init.peerId);
    }
    if (init.addressManager != null) {
      this.setAddressManager(init.addressManager);
    }
    if (init.peerStore != null) {
      this.setPeerStore(init.peerStore);
    }
    if (init.upgrader != null) {
      this.setUpgrader(init.upgrader);
    }
    if (init.metrics != null) {
      this.setMetrics(init.metrics);
    }
    if (init.registrar != null) {
      this.setRegistrar(init.registrar);
    }
    if (init.connectionManager != null) {
      this.setConnectionManager(init.connectionManager);
    }
    if (init.transportManager != null) {
      this.setTransportManager(init.transportManager);
    }
    if (init.connectionGater != null) {
      this.setConnectionGater(init.connectionGater);
    }
    if (init.contentRouting != null) {
      this.setContentRouting(init.contentRouting);
    }
    if (init.peerRouting != null) {
      this.setPeerRouting(init.peerRouting);
    }
    if (init.datastore != null) {
      this.setDatastore(init.datastore);
    }
    if (init.connectionProtector != null) {
      this.setConnectionProtector(init.connectionProtector);
    }
    if (init.dht != null) {
      this.setDHT(init.dht);
    }
    if (init.pubsub != null) {
      this.setPubSub(init.pubsub);
    }
    if (init.dialer != null) {
      this.setDialer(init.dialer);
    }
  }
  isStarted() {
    return this.started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this.started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this.started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  setPeerId(peerId) {
    this.peerId = peerId;
    return peerId;
  }
  getPeerId() {
    if (this.peerId == null) {
      throw (0, import_err_code68.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerId;
  }
  setMetrics(metrics) {
    this.metrics = metrics;
    if (isInitializable(metrics)) {
      metrics.init(this);
    }
    return metrics;
  }
  getMetrics() {
    return this.metrics;
  }
  setAddressManager(addressManager) {
    this.addressManager = addressManager;
    if (isInitializable(addressManager)) {
      addressManager.init(this);
    }
    return addressManager;
  }
  getAddressManager() {
    if (this.addressManager == null) {
      throw (0, import_err_code68.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.addressManager;
  }
  setPeerStore(peerStore) {
    this.peerStore = peerStore;
    if (isInitializable(peerStore)) {
      peerStore.init(this);
    }
    return peerStore;
  }
  getPeerStore() {
    if (this.peerStore == null) {
      throw (0, import_err_code68.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerStore;
  }
  setUpgrader(upgrader) {
    this.upgrader = upgrader;
    if (isInitializable(upgrader)) {
      upgrader.init(this);
    }
    return upgrader;
  }
  getUpgrader() {
    if (this.upgrader == null) {
      throw (0, import_err_code68.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this.upgrader;
  }
  setRegistrar(registrar) {
    this.registrar = registrar;
    if (isInitializable(registrar)) {
      registrar.init(this);
    }
    return registrar;
  }
  getRegistrar() {
    if (this.registrar == null) {
      throw (0, import_err_code68.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this.registrar;
  }
  setConnectionManager(connectionManager) {
    this.connectionManager = connectionManager;
    if (isInitializable(connectionManager)) {
      connectionManager.init(this);
    }
    return connectionManager;
  }
  getConnectionManager() {
    if (this.connectionManager == null) {
      throw (0, import_err_code68.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionManager;
  }
  setTransportManager(transportManager) {
    this.transportManager = transportManager;
    if (isInitializable(transportManager)) {
      transportManager.init(this);
    }
    return transportManager;
  }
  getTransportManager() {
    if (this.transportManager == null) {
      throw (0, import_err_code68.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.transportManager;
  }
  setConnectionGater(connectionGater) {
    this.connectionGater = connectionGater;
    if (isInitializable(connectionGater)) {
      connectionGater.init(this);
    }
    return connectionGater;
  }
  getConnectionGater() {
    if (this.connectionGater == null) {
      throw (0, import_err_code68.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionGater;
  }
  setContentRouting(contentRouting) {
    this.contentRouting = contentRouting;
    if (isInitializable(contentRouting)) {
      contentRouting.init(this);
    }
    return contentRouting;
  }
  getContentRouting() {
    if (this.contentRouting == null) {
      throw (0, import_err_code68.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.contentRouting;
  }
  setPeerRouting(peerRouting) {
    this.peerRouting = peerRouting;
    if (isInitializable(peerRouting)) {
      peerRouting.init(this);
    }
    return peerRouting;
  }
  getPeerRouting() {
    if (this.peerRouting == null) {
      throw (0, import_err_code68.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerRouting;
  }
  setDatastore(datastore) {
    this.datastore = datastore;
    if (isInitializable(datastore)) {
      datastore.init(this);
    }
    return datastore;
  }
  getDatastore() {
    if (this.datastore == null) {
      throw (0, import_err_code68.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this.datastore;
  }
  setConnectionProtector(connectionProtector) {
    this.connectionProtector = connectionProtector;
    if (isInitializable(connectionProtector)) {
      connectionProtector.init(this);
    }
    return connectionProtector;
  }
  getConnectionProtector() {
    return this.connectionProtector;
  }
  setDHT(dht) {
    this.dht = dht;
    if (isInitializable(dht)) {
      dht.init(this);
    }
    return dht;
  }
  getDHT() {
    if (this.dht == null) {
      throw (0, import_err_code68.default)(new Error("dht not set"), "ERR_SERVICE_MISSING");
    }
    return this.dht;
  }
  setPubSub(pubsub) {
    this.pubsub = pubsub;
    if (isInitializable(pubsub)) {
      pubsub.init(this);
    }
    return pubsub;
  }
  getPubSub() {
    if (this.pubsub == null) {
      throw (0, import_err_code68.default)(new Error("pubsub not set"), "ERR_SERVICE_MISSING");
    }
    return this.pubsub;
  }
  setDialer(dialer) {
    this.dialer = dialer;
    if (isInitializable(dialer)) {
      dialer.init(this);
    }
    return dialer;
  }
  getDialer() {
    if (this.dialer == null) {
      throw (0, import_err_code68.default)(new Error("dialer not set"), "ERR_SERVICE_MISSING");
    }
    return this.dialer;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
var log46 = logger("libp2p:gossipsub:score");
var PeerScore = class {
  constructor(params, metrics, opts) {
    this.params = params;
    this.metrics = metrics;
    this.peerStats = /* @__PURE__ */ new Map();
    this.peerIPs = /* @__PURE__ */ new Map();
    this.scoreCache = /* @__PURE__ */ new Map();
    this.deliveryRecords = new MessageDeliveries();
    this.components = new Components();
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
  }
  init(components) {
    this.components = components;
  }
  get size() {
    return this.peerStats.size;
  }
  start() {
    if (this._backgroundInterval) {
      log46("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
    log46("started");
  }
  stop() {
    if (!this._backgroundInterval) {
      log46("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    log46("stopped");
  }
  background() {
    this.refreshScores();
    this.updateIPs();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPs(id, pstats.ips);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      ips: [],
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
    const ips = this.getIPs(id);
    this.setIPs(id, ips, pstats.ips);
    pstats.ips = ips;
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPs(id, pstats.ips);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from33, msgIdStr, topic) {
    this.markFirstMessageDelivery(from33, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log46("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from33, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p) => {
      if (p !== from33.toString()) {
        this.markDuplicateMessageDelivery(p, topic);
      }
    });
  }
  rejectInvalidMessage(from33, topic) {
    this.markInvalidMessageDelivery(from33, topic);
  }
  rejectMessage(from33, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from33, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log46("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from33, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from33, topic);
    drec.peers.forEach((p) => {
      this.markInvalidMessageDelivery(p, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from33, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from33)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from33);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from33);
        this.markDuplicateMessageDelivery(from33, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from33, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  markInvalidMessageDelivery(from33, topic) {
    const pstats = this.peerStats.get(from33);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  markFirstMessageDelivery(from33, topic) {
    const pstats = this.peerStats.get(from33);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  markDuplicateMessageDelivery(from33, topic, validatedTime) {
    const pstats = this.peerStats.get(from33);
    if (pstats) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  getIPs(id) {
    return this.components.getConnectionManager().getConnections(peerIdFromString(id)).map((c) => c.remoteAddr.toOptions().host);
  }
  setIPs(id, newIPs, oldIPs) {
    addNewIPs:
      for (const ip of newIPs) {
        for (const xip of oldIPs) {
          if (ip === xip) {
            continue addNewIPs;
          }
        }
        let peers = this.peerIPs.get(ip);
        if (!peers) {
          peers = /* @__PURE__ */ new Set();
          this.peerIPs.set(ip, peers);
        }
        peers.add(id);
      }
    removeOldIPs:
      for (const ip of oldIPs) {
        for (const xip of newIPs) {
          if (ip === xip) {
            continue removeOldIPs;
          }
        }
        const peers = this.peerIPs.get(ip);
        if (!peers) {
          continue;
        }
        peers.delete(id);
        if (!peers.size) {
          this.peerIPs.delete(ip);
        }
      }
  }
  removeIPs(id, ips) {
    ips.forEach((ip) => {
      const peers = this.peerIPs.get(ip);
      if (!peers) {
        return;
      }
      peers.delete(id);
      if (!peers.size) {
        this.peerIPs.delete(ip);
      }
    });
  }
  updateIPs() {
    this.peerStats.forEach((pstats, id) => {
      const newIPs = this.getIPs(id);
      this.setIPs(id, newIPs, pstats.ips);
      pstats.ips = newIPs;
    });
  }
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
var IWantTracer = class {
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.promises = /* @__PURE__ */ new Map();
    this.requestMsByMsg = /* @__PURE__ */ new Map();
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  addPromise(from33, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (!expireByPeer) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from33)) {
      expireByPeer.set(from33, now + this.gossipsubIWantFollowupMs);
      if (this.metrics) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p) => {
        if (expire < now) {
          result.set(p, (result.get(p) ?? 0) + 1);
          expireByPeer.delete(p);
          brokenPromises++;
        }
      });
      if (!expireByPeer.size) {
        this.promises.delete(msgId2);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  deliverMessage(msgIdStr) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer) {
      this.promises.delete(msgIdStr);
      if (this.metrics) {
        this.metrics.iwantPromiseResolved.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
      } else {
        break;
      }
    }
  }
  trackMessage(msgIdStr) {
    if (this.metrics) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
var SimpleTimeCache = class {
  constructor(opts) {
    this.entries = /* @__PURE__ */ new Map();
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  put(key, value2) {
    this.entries.set(key, { value: value2, validUntilMs: Date.now() + this.validityMs });
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value2 = this.entries.get(key);
    return value2 && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Unsub"] = "unsubscribed";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    meshPeerInclusionEvents: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_total",
      help: "Number of times we include peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    meshPeerChurnEvents: register.gauge({
      name: "gossipsub_peer_churn_events_total",
      help: "Number of times we remove peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      buckets: [0.01, 0.1, 1]
    }),
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    asyncValidationResult: register.gauge({
      name: "gossipsub_async_validation_result_total",
      help: "Message validation result for each topic",
      labelNames: ["topic", "acceptance"]
    }),
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    msgPublishPeers: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    msgPublishPeersByGroup: register.gauge({
      name: "gossipsub_msg_publish_peers_by_group",
      help: "Total count of peers (by group) that we publish a msg to",
      labelNames: ["topic", "peerGroup"]
    }),
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    msgReceivedStatus: register.gauge({
      name: "gossipsub_msg_received_status_total",
      help: "Tracks distribution of recv msgs by duplicate, invalid, valid",
      labelNames: ["topic", "status"]
    }),
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["topic", "error"]
    }),
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores",
      labelNames: ["topic", "p"]
    }),
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerInclusionEvents.inc({ topic, reason }, count);
    },
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerChurnEvents.inc({ topic, reason }, count);
    },
    onReportValidationMcacheHit(hit) {
      this.asyncValidationMcacheHit.inc({ hit: hit ? "hit" : "miss" });
    },
    onReportValidation(topicStr, acceptance) {
      const topic = this.toTopic(topicStr);
      this.asyncValidationResult.inc({ topic, acceptance });
    },
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeers.inc({ topic }, tosendCount);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "direct" }, tosendGroupCount.direct);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "floodsub" }, tosendGroupCount.floodsub);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "mesh" }, tosendGroupCount.mesh);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "fanout" }, tosendGroupCount.fanout);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedStatus.inc({ topic, status });
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ topic, error }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control) {
        const ihave = rpc.control.ihave?.length ?? 0;
        const iwant = rpc.control.iwant?.length ?? 0;
        const graft = rpc.control.graft?.length ?? 0;
        const prune = rpc.control.prune?.length ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh?.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
init_concat();

// node_modules/@libp2p/crypto/dist/src/aes/ciphers-browser.js
var import_aes = __toESM(require_aes(), 1);
var import_forge6 = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var import_pbkdf2 = __toESM(require_pbkdf2(), 1);
var import_util6 = __toESM(require_util(), 1);
var hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize, hash3) {
  if (hash3 !== "sha1" && hash3 !== "sha2-256" && hash3 !== "sha2-512") {
    const types2 = Object.keys(hashName).join(" / ");
    throw new CodeError(`Hash '${hash3}' is unknown or not supported. Must be ${types2}`, "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash3];
  const dek = (0, import_pbkdf2.default)(password, salt, iterations, keySize, hasher);
  return import_util6.default.encode64(dek, null);
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
var SignPrefix = fromString3("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes(8),
        topic,
        signature: void 0,
        key: void 0
      };
      const bytes2 = concat4([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes2);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString11(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey2(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals15(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey2(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
      };
      const bytes2 = concat4([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes2, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString11(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey2(publicKey)
        }
      };
    }
  }
}

// node_modules/@libp2p/pubsub/dist/src/utils.js
var import_err_code69 = __toESM(require_err_code());
var msgId = (key, seqno) => {
  const seqnoBytes = fromString3(seqno.toString(16).padStart(16, "0"), "base16");
  const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
  msgId2.set(key, 0);
  msgId2.set(seqnoBytes, key.length);
  return msgId2;
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return await sha256.encode(msg.data);
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}

// node_modules/abortable-iterator/dist/src/abort-error.js
var AbortError5 = class extends Error {
  constructor(message6, code22) {
    super(message6 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code22 ?? "ABORT_ERR";
  }
};

// node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/abortable-iterator/dist/src/index.js
function abortableSource(source, signal, options) {
  const opts = options ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError5(abortMessage, abortCode);
        }
        const abort = new Promise((resolve7, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError5(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err2) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err2.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          await opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err3) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err3);
                }
              });
            }
          } catch (err3) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err3);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err2;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}
function abortableSink(sink, signal, options) {
  return (source) => sink(abortableSource(source, signal, options));
}
function abortableDuplex(duplex, signal, options) {
  return {
    sink: abortableSink(duplex.sink, signal, {
      ...options,
      onAbort: void 0
    }),
    source: abortableSource(duplex.source, signal, options)
  };
}

// node_modules/it-length-prefixed/dist/src/alloc.js
function allocUnsafe11(len) {
  if (globalThis?.Buffer?.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
}

// node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length23) => {
  const lengthLength = unsigned.encodingLength(length23);
  const lengthBuf = allocUnsafe11(lengthLength);
  unsigned.encode(length23, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode52(options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  const encoder2 = async function* (source) {
    for await (const chunk of source) {
      const length23 = encodeLength(chunk.byteLength);
      if (length23 instanceof Uint8Array) {
        yield length23;
      } else {
        yield* length23;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
  };
  return encoder2;
}
encode52.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/decode.js
var import_err_code70 = __toESM(require_err_code(), 1);
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf2) => {
  const length23 = unsigned.decode(buf2);
  defaultDecoder.bytes = unsigned.encodingLength(length23);
  return length23;
};
defaultDecoder.bytes = 0;
function decode62(options) {
  const decoder = async function* (source) {
    const buffer2 = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    for await (const buf2 of source) {
      buffer2.append(buf2);
      while (buffer2.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer2);
            if (dataLength < 0) {
              throw (0, import_err_code70.default)(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            }
            if (dataLength > maxDataLength) {
              throw (0, import_err_code70.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer2.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err2) {
            if (err2 instanceof RangeError) {
              if (buffer2.byteLength > maxLengthLength) {
                throw (0, import_err_code70.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              }
              break;
            }
            throw err2;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer2.byteLength < dataLength) {
            break;
          }
          const data = buffer2.sublist(0, dataLength);
          buffer2.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (buffer2.byteLength > 0) {
      throw (0, import_err_code70.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }
  };
  return decoder;
}
decode62.fromReader = (reader6, options) => {
  let byteLength2 = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader6.next(byteLength2);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err2) {
        if (err2.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err2;
      } finally {
        byteLength2 = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength2 = l;
  };
  return decode62({
    ...options ?? {},
    onLength
  })(varByteSource);
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
var OutboundStream = class {
  constructor(rawStream, errCallback, opts) {
    this.rawStream = rawStream;
    this.pushable = pushable({ objectMode: false });
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), encode52(), this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.stat.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  close() {
    this.closeController.abort();
    this.pushable.return();
    this.rawStream.close();
  }
};
var InboundStream = class {
  constructor(rawStream) {
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.source = abortableSource(pipe(this.rawStream, decode62()), this.closeController.signal, { returnOnAbort: true });
  }
  close() {
    this.closeController.abort();
    this.rawStream.close();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
var GossipSub = class extends EventEmitter2 {
  constructor(options = {}) {
    super();
    this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
    this.peers = /* @__PURE__ */ new Set();
    this.streamsInbound = /* @__PURE__ */ new Map();
    this.streamsOutbound = /* @__PURE__ */ new Map();
    this.outboundInflightQueue = pushable({ objectMode: true });
    this.direct = /* @__PURE__ */ new Set();
    this.floodsubPeers = /* @__PURE__ */ new Set();
    this.acceptFromWhitelist = /* @__PURE__ */ new Map();
    this.topics = /* @__PURE__ */ new Map();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.mesh = /* @__PURE__ */ new Map();
    this.fanout = /* @__PURE__ */ new Map();
    this.fanoutLastpub = /* @__PURE__ */ new Map();
    this.gossip = /* @__PURE__ */ new Map();
    this.control = /* @__PURE__ */ new Map();
    this.peerhave = /* @__PURE__ */ new Map();
    this.iasked = /* @__PURE__ */ new Map();
    this.backoff = /* @__PURE__ */ new Map();
    this.outbound = /* @__PURE__ */ new Map();
    this.topicValidators = /* @__PURE__ */ new Map();
    this.heartbeatTicks = 0;
    this.components = new Components();
    this.directPeerInitial = null;
    this.status = { code: GossipStatusCode.stopped };
    this.heartbeatTimer = null;
    this.runHeartbeat = () => {
      const timer = this.metrics?.heartbeatDuration.startTimer();
      this.heartbeat().catch((err2) => {
        this.log("Error running heartbeat", err2);
      }).finally(() => {
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            this.metrics?.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    };
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = logger(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
      }
    }
    if (options.fastMsgIdFn) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister) {
      if (!options.metricsTopicStrToLabel) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
      for (const protocol4 of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol: protocol4 }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
  }
  getPeers() {
    return [...this.peers.keys()].map((str) => peerIdFromString(str));
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  async init(components) {
    this.components = components;
    this.score.init(components);
  }
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.getPeerId());
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source) => {
      for await (const { peerId, connection } of source) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e) => this.log.error("outbound inflight queue error", e));
    await Promise.all(this.opts.directPeers.map(async (p) => {
      await this.components.getPeerStore().addressBook.add(p.id, p.addrs);
    }));
    const registrar = this.components.getRegistrar();
    await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    })));
    const topology = createTopology({
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this)
    });
    const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
      }).catch((err2) => {
        this.log(err2);
      });
    }, GossipsubDirectConnectInitialDelay);
    this.log("started");
  }
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    const registrar = this.components.getRegistrar();
    registrarTopologyIds.forEach((id) => registrar.unregister(id));
    this.outboundInflightQueue.end();
    for (const outboundStream of this.streamsOutbound.values()) {
      outboundStream.close();
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      inboundStream.close();
    }
    this.streamsInbound.clear();
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial)
      clearTimeout(this.directPeerInitial);
    this.log("stopped");
  }
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  onIncomingStream({ stream, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.stat.direction);
    this.createInboundStream(peerId, stream);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  onPeerConnected(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    this.addPeer(peerId, connection.stat.direction);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream);
      const protocol4 = stream.protocol;
      if (protocol4 === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol: protocol4 }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e) {
      this.log.error("createOutboundStream error", e);
    }
  }
  async createInboundStream(peerId, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close();
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream);
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err2) => this.log(err2));
  }
  addPeer(peerId, direction) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId);
      this.peers.add(id);
      this.score.addPeer(id);
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close();
    inboundStream?.close();
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id) === true) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic ? Array.from(peersInTopic) : [];
  }
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
  }
  getTopics() {
    return Array.from(this.subscriptions);
  }
  async pipePeerReadStream(peerId, stream) {
    try {
      await pipe(stream, async (source) => {
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = RPC.decode(rpcBytes);
            this.metrics?.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              await this.handleReceivedRpc(peerId, rpc);
            } else {
              this.handleReceivedRpc(peerId, rpc).catch((err2) => this.log(err2));
            }
          } catch (e) {
            this.log(e);
          }
        }
      });
    } catch (err2) {
      this.log.error(err2);
      this.onPeerDisconnected(peerId);
    }
  }
  async handleReceivedRpc(from33, rpc) {
    if (!this.acceptFrom(from33.toString())) {
      this.log("received message from unacceptable peer %p", from33);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    this.log("rpc from %p", from33);
    if (rpc.subscriptions && rpc.subscriptions.length > 0) {
      rpc.subscriptions.forEach((subOpt) => {
        this.handleReceivedSubscription(from33, subOpt);
      });
      this.dispatchEvent(new CustomEvent("subscription-change", {
        detail: {
          peerId: from33,
          subscriptions: rpc.subscriptions.filter((sub) => sub.topic !== null).map((sub) => {
            return {
              topic: sub.topic ?? "",
              subscribe: Boolean(sub.subscribe)
            };
          })
        }
      }));
    }
    if (rpc.messages) {
      for (const message6 of rpc.messages) {
        const handleReceivedMessagePromise = this.handleReceivedMessage(from33, message6).catch((err2) => this.log(err2));
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
    }
    if (rpc.control) {
      await this.handleControlMessage(from33.toString(), rpc.control);
    }
  }
  handleReceivedSubscription(from33, subOpt) {
    if (subOpt.topic == null) {
      return;
    }
    this.log("subscription update from %p topic %s", from33, subOpt.topic);
    let topicSet = this.topics.get(subOpt.topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(subOpt.topic, topicSet);
    }
    if (subOpt.subscribe) {
      topicSet.add(from33.toString());
    } else {
      topicSet.delete(from33.toString());
    }
  }
  async handleReceivedMessage(from33, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from33, rpcMsg);
    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code);
    switch (validationResult.code) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from33.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from33.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from33.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from33.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.getPeerId().equals(from33);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from33,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from33.toString());
        }
    }
  }
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e) {
      this.log("Invalid message, transform failed", e);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr)
      this.fastMsgIdCache?.put(fastMsgIdStr, msgIdStr);
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(msg.topic, msg, propagationSource);
      } catch (e) {
        const errCode107 = e.code;
        if (errCode107 === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = MessageAcceptance.Ignore;
        if (errCode107 === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = MessageAcceptance.Reject;
        else
          acceptance = MessageAcceptance.Ignore;
      }
      if (acceptance !== MessageAcceptance.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  getScore(peerId) {
    return this.score.score(peerId);
  }
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe })),
      messages: []
    });
  }
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
    if (!iwant.length && !ihave.length && !prune.length) {
      return;
    }
    this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
  }
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  handleIHave(id, ihave) {
    if (!ihave.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (!iwant.size) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    this.gossipTracer.addPromise(id, iwantList);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  handleIWant(id, iwant) {
    if (!iwant.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs && messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (!ihave.size) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (!topicID) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
        return;
      }
      const expire = this.backoff.get(topicID)?.get(id);
      if (typeof expire === "number" && now < expire) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
        return;
      }
      if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
        return;
      }
      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
        return;
      }
      this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
      this.score.graft(id, topicID);
      peersInMesh.add(id);
      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
    });
    if (!prune.length) {
      return [];
    }
    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)));
  }
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers && peers.length) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          continue;
        }
        await this.pxConnect(peers);
      }
    }
  }
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  doAddBackoff(id, topic, interval) {
    let backoff = this.backoff.get(topic);
    if (!backoff) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + interval;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
    });
  }
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (!pi.peerID) {
        return;
      }
      const p = peerIdFromBytes(pi.peerID).toString();
      if (this.peers.has(p)) {
        return;
      }
      if (!pi.signedPeerRecord) {
        toconnect.push(p);
        return;
      }
      try {
        const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
        const eid = envelope.peerId;
        if (!envelope.peerId.equals(p)) {
          this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p", eid, p);
          return;
        }
        if (!await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p);
      } catch (e) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (!toconnect.length) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString(id);
    const connection = await this.components.getConnectionManager().openConnection(peerId);
    for (const multicodec of this.multicodecs) {
      for (const topology of this.components.getRegistrar().getTopologies(multicodec)) {
        topology.onConnect(peerId, connection);
      }
    }
  }
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic).catch((err2) => {
      this.log(err2);
    });
  }
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0);
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  async leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers) {
      await Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        return await this.sendPrune(id, topic);
      }));
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    const rpc = createGossipRpc([rawMsg]);
    tosend.forEach((id) => {
      this.sendRpc(id, rpc);
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  async publish(topic, data) {
    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    if (this.seenCache.has(msgIdStr)) {
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
    if (tosend.size === 0 && !this.opts.allowPublishToZeroPeers && !willSendToSelf) {
      throw Error("PublishError.InsufficientPeers");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.publishedMessageIds.put(msgIdStr);
    const rpc = createGossipRpc([rawMsg]);
    for (const id of tosend) {
      const sent = this.sendRpc(id, rpc);
      if (!sent) {
        tosend.delete(id);
      }
    }
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0);
    if (willSendToSelf) {
      tosend.add(this.components.getPeerId().toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.getPeerId(),
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
    };
  }
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    if (acceptance === MessageAcceptance.Accept) {
      const cacheEntry = this.mcache.validate(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource.toString(), msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource.toString(), originatingPeers);
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    } else {
      const cacheEntry = this.mcache.remove(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource.toString(), msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    }
  }
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    const out = createGossipRpc([], { graft });
    this.sendRpc(id, out);
  }
  async sendPrune(id, topic) {
    const prune = [await this.makePrune(id, topic, this.opts.doPX)];
    const out = createGossipRpc([], { prune });
    this.sendRpc(id, out);
  }
  sendRpc(id, rpc) {
    const outboundStream = this.streamsOutbound.get(id);
    if (!outboundStream) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc).finish();
    try {
      outboundStream.push(rpcBytes);
    } catch (e) {
      this.log.error(`Cannot send rpc to ${id}`, e);
      if (ctrl) {
        this.control.set(id, ctrl);
      }
      if (ihave) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc, rpcBytes.length);
    return true;
  }
  piggybackControl(id, outRpc, ctrl) {
    const tograft = (ctrl.graft || []).filter(({ topicID }) => (topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
    const toprune = (ctrl.prune || []).filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
    if (!tograft.length && !toprune.length) {
      return;
    }
    if (outRpc.control) {
      outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);
      outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);
    } else {
      outRpc.control = { graft: tograft, prune: toprune, ihave: [], iwant: [] };
    }
  }
  piggybackGossip(id, outRpc, ihave) {
    if (!outRpc.control) {
      outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };
    }
    outRpc.control.ihave = ihave;
  }
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning) {
        prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
        toprune.delete(id);
      }
      const outRpc = createGossipRpc([], { graft, prune });
      this.sendRpc(id, outRpc);
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
      const outRpc = createGossipRpc([], { prune });
      this.sendRpc(id, outRpc);
    }
  }
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (!messageIDs.length) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (!candidateToGossip.size)
      return;
    let target = this.opts.Dlazy;
    const factor = GossipsubGossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { ihave }));
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { graft: control.graft, prune: control.prune }));
    }
  }
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) || [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  async makePrune(id, topic, doPX) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoff = this.opts.pruneBackoff / 1e3;
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = peerIdFromString(peerId);
      return {
        peerID: id2.toBytes(),
        signedPeerRecord: await this.components.getPeerStore().addressBook.getRawEnvelope(id2)
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s = scores.get(id);
      if (s === void 0) {
        s = this.score.score(id);
        scores.set(id, s);
      }
      return s;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if ((!backoff || !backoff.has(id)) && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = (id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (!topics) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (!topics) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p) => {
          graftPeer(p, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a, b) => getScore(b) - getScore(a));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i2) => {
            const p = peersArray[i2];
            for (let j = i2; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i2 = 1; i2 < D && ihave > 0; i2++) {
              if (this.outbound.get(peersArray[i2])) {
                rotate(i2);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i2 = D; i2 < peersArray.length && ineed > 0; i2++) {
            if (this.outbound.get(peersArray[i2])) {
              rotate(i2);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p) => {
          prunePeer(p, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  getRandomGossipPeers(topic, count, filter14 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (!peersInTopic) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (!peerStreams) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter14(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
};
GossipSub.multicodec = GossipsubIDv11;

// node_modules/ipfs-core-config/src/libp2p-pubsub-routers.browser.js
var routers = () => ({
  gossipsub: new GossipSub({
    allowPublishToZeroPeers: true,
    fallbackToFloodsub: true,
    emitSelf: true,
    maxInboundStreams: 64,
    maxOutboundStreams: 128
  })
});

// node_modules/@libp2p/delegated-peer-routing/dist/src/index.js
var import_err_code71 = __toESM(require_err_code());
var import_any_signal3 = __toESM(require_any_signal());
var log47 = logger("libp2p-delegated-peer-routing");
var DEFAULT_TIMEOUT = 3e4;
var CONCURRENT_HTTP_REQUESTS = 4;
var DelegatedPeerRouting = class {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS
    });
    const { protocol: protocol4, host, port } = client.getEndpointConfig();
    log47(`enabled DelegatedPeerRouting via ${protocol4}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async findPeer(id, options = {}) {
    log47("findPeer starts: %p", id);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findPeer(id, options)) {
        if (event.name === "FINAL_PEER") {
          const peerInfo = {
            id: event.peer.id,
            multiaddrs: event.peer.multiaddrs,
            protocols: []
          };
          return peerInfo;
        }
      }
    } catch (err2) {
      log47.error("findPeer errored: %o", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log47("findPeer finished: %p", id);
    }
    throw (0, import_err_code71.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options = {}) {
    let cidOrPeerId;
    const cid = CID.asCID(key);
    if (cid != null) {
      cidOrPeerId = cid;
    } else {
      cidOrPeerId = peerIdFromBytes(key);
    }
    log47("getClosestPeers starts: %s", cidOrPeerId);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.query(cidOrPeerId, options)) {
        if (event.name === "PEER_RESPONSE") {
          yield* event.closer.map((closer) => ({
            id: closer.id,
            multiaddrs: closer.multiaddrs,
            protocols: []
          }));
        }
      }
    } catch (err2) {
      log47.error("getClosestPeers errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log47("getClosestPeers finished: %b", key);
    }
  }
};

// node_modules/@libp2p/delegated-content-routing/dist/src/index.js
var import_it_drain9 = __toESM(require_it_drain());
var import_err_code72 = __toESM(require_err_code());
var import_any_signal4 = __toESM(require_any_signal());
var log48 = logger("libp2p:delegated-content-routing");
var DEFAULT_TIMEOUT2 = 3e4;
var CONCURRENT_HTTP_REQUESTS2 = 4;
var CONCURRENT_HTTP_REFS_REQUESTS = 2;
var DelegatedContentRouting = class {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS2
    });
    this.httpQueueRefs = new PQueue({
      concurrency: CONCURRENT_HTTP_REFS_REQUESTS
    });
    const { protocol: protocol4, host, port } = client.getEndpointConfig();
    log48(`enabled DelegatedContentRouting via ${protocol4}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.httpQueueRefs.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    log48("findProviders starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findProvs(key, options)) {
        if (event.name === "PROVIDER") {
          yield* event.providers.map((prov) => {
            const peerInfo = {
              id: prov.id,
              protocols: [],
              multiaddrs: prov.multiaddrs
            };
            return peerInfo;
          });
        }
      }
    } catch (err2) {
      log48.error("findProviders errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log48("findProviders finished: %c", key);
    }
  }
  async provide(key, options = {}) {
    log48("provide starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueueRefs.add(async () => {
      await this.client.block.stat(key, options);
      await (0, import_it_drain9.default)(this.client.dht.provide(key, options));
    });
    log48("provide finished: %c", key);
  }
  async put(key, value2, options = {}) {
    log48("put value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueue.add(async () => {
      await (0, import_it_drain9.default)(this.client.dht.put(key, value2, options));
    });
    log48("put value finished: %b", key);
  }
  async get(key, options = {}) {
    log48("get value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    return await this.httpQueue.add(async () => {
      for await (const event of this.client.dht.get(key, options)) {
        if (event.name === "VALUE") {
          log48("get value finished: %b", key);
          return event.value;
        }
      }
      throw (0, import_err_code72.default)(new Error("Not found"), "ERR_NOT_FOUND");
    });
  }
};

// node_modules/ipfs-core-utils/src/multibases.js
var LOAD_BASE = (name22) => Promise.reject(new Error(`No base found for "${name22}"`));
var Multibases = class {
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base30 of options.bases) {
      this.addBase(base30);
    }
  }
  addBase(base30) {
    if (this._basesByName[base30.name] || this._basesByPrefix[base30.prefix]) {
      throw new Error(`Codec already exists for codec "${base30.name}"`);
    }
    this._basesByName[base30.name] = base30;
    this._basesByPrefix[base30.prefix] = base30;
  }
  removeBase(base30) {
    delete this._basesByName[base30.name];
    delete this._basesByPrefix[base30.prefix];
  }
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base30 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base30.name] == null && this._basesByPrefix[base30.prefix] == null) {
      this.addBase(base30);
    }
    return base30;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};

// node_modules/ipfs-core-utils/src/multicodecs.js
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code22) {
    const table2 = typeof code22 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code22]) {
      return table2[code22];
    }
    const codec = await this._loadCodec(code22);
    if (table2[code22] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};

// node_modules/ipfs-core-utils/src/multihashes.js
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code22) {
    const table2 = typeof code22 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code22]) {
      return table2[code22];
    }
    const hasher = await this._loadHasher(code22);
    if (table2[code22] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};

// node_modules/ipfs-http-client/src/lib/core.js
var import_env = __toESM(require_env(), 1);
var import_http3 = __toESM(require_http(), 1);

// node_modules/ipfs-core-utils/src/to-url-string.js
function toUrlString(url2) {
  try {
    url2 = multiaddrToUri(multiaddr(url2));
  } catch (err2) {
  }
  url2 = url2.toString();
  return url2;
}

// node_modules/ipfs-core-utils/src/agent.browser.js
var agent_browser_default = () => {
};

// node_modules/ipfs-http-client/src/lib/core.js
var log49 = logger("ipfs-http-client:lib:error-handler");
var merge4 = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url2;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url2 = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url2 = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url2 = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url2 = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol4 = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url2 = new URL(`${protocol4}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url2.pathname = opts.apiPath;
  } else if (url2.pathname === "/" || url2.pathname === void 0) {
    url2.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default(url2);
    agent = opts.agent || new Agent({
      keepAlive: true,
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url2.host,
    protocol: url2.protocol.replace(":", ""),
    port: Number(url2.port),
    apiPath: url2.pathname,
    url: url2,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log49(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err2) {
    log49("Failed to parse error response", err2);
    msg = err2.message;
  }
  let error = new import_http3.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http3.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http3.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http3.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value2) => {
  return typeof value2 === "string" ? parse_duration_default(value2) : value2;
};
var Client = class extends import_http3.default {
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value2] of search) {
          if (value2 !== "undefined" && value2 !== "null" && key !== "signal") {
            out.append(kebabCase(key), value2);
          }
          if (key === "timeout" && !isNaN(value2)) {
            out.append(kebabCase(key), value2);
          }
        }
        return out;
      },
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch.call(this, resource, merge4(options2, {
        method: "POST"
      }));
    };
  }
};
var HTTPError = import_http3.default.HTTPError;

// node_modules/ipfs-http-client/src/lib/configure.js
var configure4 = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};

// node_modules/ipfs-http-client/src/lib/mode-to-string.js
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-http-client/src/lib/parse-mtime.js
var import_err_code73 = __toESM(require_err_code(), 1);
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code73.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/ipfs-http-client/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime2(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}

// node_modules/ipfs-http-client/src/bitswap/wantlist.js
var createWantlist2 = configure4((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlist;
});

// node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js
var createWantlistForPeer2 = configure4((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlistForPeer;
});

// node_modules/ipfs-http-client/src/bitswap/stat.js
var createStat6 = configure4((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

// node_modules/ipfs-http-client/src/bitswap/unwant.js
var createUnwant2 = configure4((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

// node_modules/ipfs-http-client/src/bitswap/index.js
function createBitswap(config2) {
  return {
    wantlist: createWantlist2(config2),
    wantlistForPeer: createWantlistForPeer2(config2),
    unwant: createUnwant2(config2),
    stat: createStat6(config2)
  };
}

// node_modules/ipfs-http-client/src/block/get.js
var createGet5 = configure4((api) => {
  async function get3(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get3;
});

// node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
var import_err_code74 = __toESM(require_err_code(), 1);
var import_it_peekable5 = __toESM(require_it_peekable(), 1);
var import_browser_readablestream_to_it4 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_all6 = __toESM(require_it_all(), 1);
async function normaliseContent2(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it4.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable5.default)(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return new Blob([Uint8Array.from(await (0, import_it_all6.default)(peekable))]);
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code74.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts2 = [];
  for await (const chunk of stream) {
    parts2.push(chunk);
  }
  return new Blob(parts2);
}

// node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
function normaliseInput4(input) {
  return normaliseCandidateMultiple(input, normaliseContent2, true);
}

// node_modules/ipfs-core-utils/src/mode-to-string.js
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-core-utils/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts2 = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path: path2, mode, mtime } of normaliseInput4(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path2 != null ? encodeURIComponent(path2) : void 0);
      const end = total + content.size;
      parts2.push({ name: path2, start: total, end });
      total = end;
    } else if (path2 != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path2), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts: parts2,
    headers,
    body: formData
  };
}

// node_modules/ipfs-http-client/src/lib/abort-signal.js
var import_any_signal5 = __toESM(require_any_signal(), 1);
function filter7(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal5.anySignal)(filter7(signals));
}

// node_modules/ipfs-http-client/src/block/put.js
var createPut4 = configure4((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err2) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err2;
    }
    return CID.parse(res.Key);
  }
  return put;
});

// node_modules/ipfs-http-client/src/block/rm.js
var createRm6 = configure4((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = {
    cid: CID.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

// node_modules/ipfs-http-client/src/block/stat.js
var createStat7 = configure4((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Key), size: data.Size };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/block/index.js
function createBlock(config2) {
  return {
    get: createGet5(config2),
    put: createPut4(config2),
    rm: createRm6(config2),
    stat: createStat7(config2)
  };
}

// node_modules/ipfs-http-client/src/bootstrap/add.js
var createAdd4 = configure4((api) => {
  async function add(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add;
});

// node_modules/ipfs-http-client/src/bootstrap/clear.js
var createClear2 = configure4((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear;
});

// node_modules/ipfs-http-client/src/bootstrap/list.js
var createList3 = configure4((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});

// node_modules/ipfs-http-client/src/bootstrap/reset.js
var createReset2 = configure4((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset;
});

// node_modules/ipfs-http-client/src/bootstrap/rm.js
var createRm7 = configure4((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});

// node_modules/ipfs-http-client/src/bootstrap/index.js
function createBootstrap(config2) {
  return {
    add: createAdd4(config2),
    clear: createClear2(config2),
    list: createList3(config2),
    reset: createReset2(config2),
    rm: createRm7(config2)
  };
}

// node_modules/ipfs-http-client/src/config/profiles/apply.js
var createApply = configure4((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

// node_modules/ipfs-http-client/src/lib/object-to-camel.js
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

// node_modules/ipfs-http-client/src/config/profiles/list.js
var createList4 = configure4((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});

// node_modules/ipfs-http-client/src/config/profiles/index.js
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList4(config2)
  };
}

// node_modules/ipfs-http-client/src/config/get.js
var createGet6 = configure4((api) => {
  const get3 = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get3;
});

// node_modules/ipfs-http-client/src/config/get-all.js
var createGetAll = configure4((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

// node_modules/ipfs-http-client/src/config/replace.js
var createReplace = configure4((api) => {
  const replace = async (config2, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString3(JSON.stringify(config2))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

// node_modules/ipfs-http-client/src/config/set.js
var createSet = configure4((api) => {
  const set2 = async (key, value2, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value2)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set2;
});
var encodeParam = (key, value2) => {
  switch (typeof value2) {
    case "boolean":
      return { arg: [key, value2.toString()], bool: true };
    case "string":
      return { arg: [key, value2] };
    default:
      return { arg: [key, JSON.stringify(value2)], json: true };
  }
};

// node_modules/ipfs-http-client/src/config/index.js
function createConfig2(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet6(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}

// node_modules/ipfs-http-client/src/dag/export.js
var createExport3 = configure4((api) => {
  async function* dagExport(root, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

// node_modules/ipfs-http-client/src/lib/resolve.js
var import_err_code75 = __toESM(require_err_code(), 1);
async function* resolve6(cid, path2, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw (0, import_err_code75.default)(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw (0, import_err_code75.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value2);
    if (cid2) {
      lastCid = cid2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
}

// node_modules/ipfs-http-client/src/dag/get.js
var import_it_first3 = __toESM(require_it_first(), 1);
var import_it_last10 = __toESM(require_it_last(), 1);
var import_err_code76 = __toESM(require_err_code(), 1);
var createGet7 = (codecs2, options) => {
  const fn = configure4((api, opts) => {
    const getBlock = createGet5(opts);
    const get3 = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await (0, import_it_first3.default)(resolve6(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last10.default)(resolve6(cid, options2.path, codecs2, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code76.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs2.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get3;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/dag/import.js
var createImport3 = configure4((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root: Root2 } of res.ndjson()) {
      if (Root2 !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root2;
        yield {
          root: {
            cid: CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

// node_modules/ipfs-http-client/src/dag/put.js
var createPut5 = (codecs2, options) => {
  const fn = configure4((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs2.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/dag/resolve.js
var createResolve4 = configure4((api) => {
  const resolve7 = async (ipfsPath3, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath3}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve7;
});

// node_modules/ipfs-http-client/src/dag/index.js
function createDag(codecs2, config2) {
  return {
    export: createExport3(config2),
    get: createGet7(codecs2, config2),
    import: createImport3(config2),
    put: createPut5(codecs2, config2),
    resolve: createResolve4(config2)
  };
}

// node_modules/ipfs-http-client/src/dht/response-types.js
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;

// node_modules/ipfs-http-client/src/dht/map-event.js
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      messageType: 0,
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      id: event.ID ?? peerIdFromString(event.ID),
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString3(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};

// node_modules/ipfs-http-client/src/dht/find-peer.js
var createFindPeer = configure4((api) => {
  async function* findPeer2(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer2;
});

// node_modules/ipfs-http-client/src/dht/find-provs.js
var createFindProvs = configure4((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});

// node_modules/ipfs-http-client/src/dht/get.js
var createGet8 = configure4((api) => {
  async function* get3(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString11(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get3;
});

// node_modules/ipfs-http-client/src/dht/provide.js
var createProvide = configure4((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});

// node_modules/ipfs-http-client/src/dht/put.js
var createPut6 = configure4((api) => {
  async function* put(key, value2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString11(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value2], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});

// node_modules/ipfs-http-client/src/dht/query.js
var createQuery = configure4((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});

// node_modules/ipfs-http-client/src/dht/index.js
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet8(config2),
    provide: createProvide(config2),
    put: createPut6(config2),
    query: createQuery(config2)
  };
}

// node_modules/ipfs-http-client/src/diag/cmds.js
var createCmds = configure4((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

// node_modules/ipfs-http-client/src/diag/net.js
var createNet = configure4((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

// node_modules/ipfs-http-client/src/diag/sys.js
var createSys = configure4((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

// node_modules/ipfs-http-client/src/diag/index.js
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}

// node_modules/ipfs-http-client/src/files/chmod.js
var createChmod2 = configure4((api) => {
  async function chmod(path2, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

// node_modules/ipfs-http-client/src/files/cp.js
var createCp2 = configure4((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src18) => CID.asCID(src18) ? `/ipfs/${src18}` : src18),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

// node_modules/ipfs-http-client/src/files/flush.js
var createFlush2 = configure4((api) => {
  async function flush3(path2, options = {}) {
    if (!path2 || typeof path2 !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID.parse(data.Cid);
  }
  return flush3;
});

// node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

// node_modules/ipfs-http-client/src/files/ls.js
var createLs4 = configure4((api) => {
  async function* ls(path2, options = {}) {
    if (!path2) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID.asCID(path2) ? `/ipfs/${path2}` : path2,
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}

// node_modules/ipfs-http-client/src/files/mkdir.js
var createMkdir2 = configure4((api) => {
  async function mkdir(path2, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

// node_modules/ipfs-http-client/src/files/mv.js
var createMv2 = configure4((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

// node_modules/ipfs-http-client/src/files/read.js
var import_source = __toESM(require_source(), 1);
var createRead2 = configure4((api) => {
  async function* read19(path2, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read19;
});

// node_modules/ipfs-http-client/src/files/rm.js
var import_http4 = __toESM(require_http(), 1);
var createRm8 = configure4((api) => {
  async function rm(path2, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http4.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});

// node_modules/ipfs-http-client/src/files/stat.js
var createStat8 = configure4((api) => {
  async function stat(path2, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}

// node_modules/ipfs-http-client/src/files/touch.js
var createTouch2 = configure4((api) => {
  async function touch(path2, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

// node_modules/ipfs-http-client/src/files/write.js
var createWrite2 = configure4((api) => {
  async function write3(path2, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime2(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write3;
});

// node_modules/ipfs-http-client/src/files/index.js
function createFiles2(config2) {
  return {
    chmod: createChmod2(config2),
    cp: createCp2(config2),
    flush: createFlush2(config2),
    ls: createLs4(config2),
    mkdir: createMkdir2(config2),
    mv: createMv2(config2),
    read: createRead2(config2),
    rm: createRm8(config2),
    stat: createStat8(config2),
    touch: createTouch2(config2),
    write: createWrite2(config2)
  };
}

// node_modules/ipfs-http-client/src/key/export.js
var import_err_code77 = __toESM(require_err_code(), 1);
var createExport4 = configure4((api) => {
  const exportKey2 = async (name22, password, options = {}) => {
    throw (0, import_err_code77.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey2;
});

// node_modules/ipfs-http-client/src/key/gen.js
var createGen2 = configure4((api) => {
  async function gen(name22, options = { type: "Ed25519" }) {
    const res = await api.post("key/gen", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name22,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});

// node_modules/ipfs-http-client/src/key/import.js
var createImport4 = configure4((api) => {
  async function importKey2(name22, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name22,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey2;
});

// node_modules/ipfs-http-client/src/key/info.js
var import_err_code78 = __toESM(require_err_code(), 1);
var createInfo2 = configure4((api) => {
  const info = async (name22, options = {}) => {
    throw (0, import_err_code78.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});

// node_modules/ipfs-http-client/src/key/list.js
var createList5 = configure4((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});

// node_modules/ipfs-http-client/src/key/rename.js
var createRename2 = configure4((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});

// node_modules/ipfs-http-client/src/key/rm.js
var createRm9 = configure4((api) => {
  async function rm(name22, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name22,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});

// node_modules/ipfs-http-client/src/key/index.js
function createKey(config2) {
  return {
    export: createExport4(config2),
    gen: createGen2(config2),
    import: createImport4(config2),
    info: createInfo2(config2),
    list: createList5(config2),
    rename: createRename2(config2),
    rm: createRm9(config2)
  };
}

// node_modules/ipfs-http-client/src/log/level.js
var createLevel = configure4((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});

// node_modules/ipfs-http-client/src/log/ls.js
var createLs5 = configure4((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

// node_modules/ipfs-http-client/src/log/tail.js
var createTail = configure4((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

// node_modules/ipfs-http-client/src/log/index.js
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs5(config2),
    tail: createTail(config2)
  };
}

// node_modules/ipfs-http-client/src/name/publish.js
var createPublish2 = configure4((api) => {
  async function publish(path2, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path2}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});

// node_modules/ipfs-http-client/src/name/resolve.js
var createResolve5 = configure4((api) => {
  async function* resolve7(path2, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve7;
});

// node_modules/ipfs-http-client/src/name/pubsub/cancel.js
var createCancel2 = configure4((api) => {
  async function cancel(name22, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name22,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});

// node_modules/ipfs-http-client/src/name/pubsub/state.js
var createState2 = configure4((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});

// node_modules/ipfs-http-client/src/name/pubsub/subs.js
var createSubs2 = configure4((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

// node_modules/ipfs-http-client/src/name/pubsub/index.js
function createPubsub(config2) {
  return {
    cancel: createCancel2(config2),
    state: createState2(config2),
    subs: createSubs2(config2)
  };
}

// node_modules/ipfs-http-client/src/name/index.js
function createName(config2) {
  return {
    publish: createPublish2(config2),
    resolve: createResolve5(config2),
    pubsub: createPubsub(config2)
  };
}

// node_modules/ipfs-http-client/src/object/data.js
var createData2 = configure4((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});

// node_modules/ipfs-http-client/src/object/get.js
var createGet9 = configure4((api) => {
  async function get3(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString3(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get3;
});

// node_modules/ipfs-http-client/src/object/links.js
var createLinks2 = configure4((api) => {
  async function links3(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID.parse(l.Hash)
    }));
  }
  return links3;
});

// node_modules/ipfs-http-client/src/object/new.js
var createNew2 = configure4((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return newObject;
});

// node_modules/ipfs-http-client/src/object/put.js
var createPut7 = (codecs2, options) => {
  const fn = configure4((api) => {
    const dagPut = createPut5(codecs2, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/object/stat.js
var createStat9 = configure4((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID.parse(output.Hash)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/object/patch/add-link.js
var createAddLink2 = configure4((api) => {
  async function addLink2(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || "",
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return addLink2;
});

// node_modules/ipfs-http-client/src/object/patch/append-data.js
var createAppendData2 = configure4((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return appendData;
});

// node_modules/ipfs-http-client/src/object/patch/rm-link.js
var createRmLink2 = configure4((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return rmLink;
});

// node_modules/ipfs-http-client/src/object/patch/set-data.js
var createSetData2 = configure4((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return setData;
});

// node_modules/ipfs-http-client/src/object/patch/index.js
function createPatch(config2) {
  return {
    addLink: createAddLink2(config2),
    appendData: createAppendData2(config2),
    rmLink: createRmLink2(config2),
    setData: createSetData2(config2)
  };
}

// node_modules/ipfs-http-client/src/object/index.js
function createObject(codecs2, config2) {
  return {
    data: createData2(config2),
    get: createGet9(config2),
    links: createLinks2(config2),
    new: createNew2(config2),
    put: createPut7(codecs2, config2),
    stat: createStat9(config2),
    patch: createPatch(config2)
  };
}

// node_modules/ipfs-http-client/src/pin/add-all.js
var createAddAll3 = configure4((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path2,
          recursive: recursive2,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID.parse(cid);
          }
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return addAll;
});

// node_modules/ipfs-http-client/src/pin/add.js
var import_it_last11 = __toESM(require_it_last(), 1);
function createAdd5(config2) {
  const all12 = createAddAll3(config2);
  return configure4(() => {
    async function add(path2, options = {}) {
      return (0, import_it_last11.default)(all12([{
        path: path2,
        ...options
      }], options));
    }
    return add;
  })(config2);
}

// node_modules/ipfs-http-client/src/pin/ls.js
function toPin3(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs6 = configure4((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path2) => `${path2}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin3(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin3(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

// node_modules/ipfs-http-client/src/pin/rm-all.js
var createRmAll2 = configure4((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path: path2, recursive: recursive2 } of normaliseInput(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path2}`);
      if (recursive2 != null)
        searchParams.set("recursive", String(recursive2));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path2}`,
          recursive: recursive2
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID.parse(cid));
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return rmAll;
});

// node_modules/ipfs-http-client/src/pin/rm.js
var import_it_last12 = __toESM(require_it_last(), 1);
var createRm10 = (config2) => {
  const all12 = createRmAll2(config2);
  return configure4(() => {
    async function rm(path2, options = {}) {
      return (0, import_it_last12.default)(all12([{
        path: path2,
        ...options
      }], options));
    }
    return rm;
  })(config2);
};

// node_modules/ipfs-http-client/src/pin/remote/utils.js
var decodePin = ({ Name: name22, Status: status, Cid: cid }) => {
  return {
    cid: CID.parse(cid),
    name: name22,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID11 = (cid) => {
  if (CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name22, status, all: all12 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name22,
    force: all12 ? true : void 0
  });
  if (cid) {
    for (const value2 of cid) {
      query.append("cid", encodeCID11(value2));
    }
  }
  if (status) {
    for (const value2 of status) {
      query.append("status", value2);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name22, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID11(cid),
    service: encodeService(service),
    name: name22,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};

// node_modules/ipfs-http-client/src/pin/remote/add.js
function createAdd6(client) {
  async function add(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add;
}

// node_modules/ipfs-http-client/src/pin/remote/ls.js
function createLs7(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}

// node_modules/ipfs-http-client/src/pin/remote/rm.js
function createRm11(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/src/pin/remote/rm-all.js
function createRmAll3(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

// node_modules/ipfs-http-client/src/pin/remote/service/utils.js
function encodeEndpoint(url2) {
  const href = String(url2);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}

// node_modules/ipfs-http-client/src/pin/remote/service/add.js
function createAdd7(client) {
  async function add(name22, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name22, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add;
}

// node_modules/ipfs-http-client/src/pin/remote/service/ls.js
function createLs8(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}

// node_modules/ipfs-http-client/src/pin/remote/service/rm.js
function createRm12(client) {
  async function rm(name22, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name22
      })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/src/pin/remote/service/index.js
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd7(client),
    ls: createLs8(client),
    rm: createRm12(client)
  };
}

// node_modules/ipfs-http-client/src/pin/remote/index.js
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd6(client),
    ls: createLs7(client),
    rm: createRm11(client),
    rmAll: createRmAll3(client),
    service: createService(config2)
  };
}

// node_modules/ipfs-http-client/src/pin/index.js
function createPin(config2) {
  return {
    addAll: createAddAll3(config2),
    add: createAdd5(config2),
    ls: createLs6(config2),
    rmAll: createRmAll2(config2),
    rm: createRm10(config2),
    remote: createRemote(config2)
  };
}

// node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js
var rpcArrayToTextArray = (strings2) => {
  if (Array.isArray(strings2)) {
    return strings2.map(rpcToText);
  }
  return strings2;
};
var rpcToText = (mb) => toString11(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url2.decode(mb);
var rpcToBigInt = (mb) => BigInt(`0x${toString11(base64url2.decode(mb), "base16")}`);
var textToUrlSafeRpc = (text) => base64url2.encode(fromString3(text));

// node_modules/ipfs-http-client/src/pubsub/ls.js
var createLs9 = configure4((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});

// node_modules/ipfs-http-client/src/pubsub/peers.js
var createPeers = configure4((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});

// node_modules/ipfs-http-client/src/pubsub/publish.js
var createPublish3 = configure4((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

// node_modules/ipfs-http-client/src/pubsub/subscribe.js
var log50 = logger("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure4((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve7, reject) => {
        done = resolve7;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err2) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err2);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message6) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message6);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message6);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log50;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err2) {
        err2.message = `Failed to parse pubsub message: ${err2.message}`;
        onError(err2, false, msg);
      }
    }
  } catch (err2) {
    if (!isAbortError(err2)) {
      onError(err2, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};

// node_modules/ipfs-http-client/src/pubsub/unsubscribe.js
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

// node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};

// node_modules/ipfs-http-client/src/pubsub/index.js
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs9(config2),
    peers: createPeers(config2),
    publish: createPublish3(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}

// node_modules/ipfs-http-client/src/refs/local.js
var createLocal2 = configure4((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

// node_modules/ipfs-http-client/src/refs/index.js
var createRefs2 = configure4((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal2(opts)
  });
});

// node_modules/ipfs-http-client/src/repo/gc.js
var createGc2 = configure4((api) => {
  async function* gc2(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc2;
});

// node_modules/ipfs-http-client/src/repo/stat.js
var createStat10 = configure4((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/repo/version.js
var createVersion3 = configure4((api) => {
  async function version4(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version4;
});

// node_modules/ipfs-http-client/src/repo/index.js
function createRepo3(config2) {
  return {
    gc: createGc2(config2),
    stat: createStat10(config2),
    version: createVersion3(config2)
  };
}

// node_modules/ipfs-http-client/src/stats/bw.js
var createBw2 = configure4((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

// node_modules/ipfs-http-client/src/stats/index.js
function createStats(config2) {
  return {
    bitswap: createStat6(config2),
    repo: createStat10(config2),
    bw: createBw2(config2)
  };
}

// node_modules/ipfs-http-client/src/swarm/addrs.js
var createAddrs = configure4((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});

// node_modules/ipfs-http-client/src/swarm/connect.js
var createConnect = configure4((api) => {
  async function connect2(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect2;
});

// node_modules/ipfs-http-client/src/swarm/disconnect.js
var createDisconnect = configure4((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});

// node_modules/ipfs-http-client/src/swarm/local-addrs.js
var createLocalAddrs = configure4((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});

// node_modules/ipfs-http-client/src/swarm/peers.js
var createPeers2 = configure4((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});

// node_modules/ipfs-http-client/src/swarm/index.js
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}

// node_modules/ipfs-http-client/src/add-all.js
var createAddAll4 = configure4((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts: parts2 } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts2, options.progress) : [void 0, void 0];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts2, progress) => parts2 ? [void 0, createOnUploadProgress(total, parts2, progress)] : [progress, void 0];
var createOnUploadProgress = (size, parts2, progress) => {
  let index = 0;
  const count = parts2.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const { start, end, name: name22 } = parts2[index];
      if (position < end) {
        progress(position - start, name22);
        break;
      } else {
        progress(end - start, name22);
        index += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name22, hash: hash3, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name22,
    cid: CID.parse(hash3),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

// node_modules/ipfs-http-client/src/add.js
var import_it_last13 = __toESM(require_it_last(), 1);
function createAdd8(options) {
  const all12 = createAddAll4(options);
  return configure4(() => {
    async function add(input, options2 = {}) {
      return await (0, import_it_last13.default)(all12(normaliseInput2(input), options2));
    }
    return add;
  })(options);
}

// node_modules/ipfs-http-client/src/cat.js
var createCat2 = configure4((api) => {
  async function* cat(path2, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

// node_modules/ipfs-http-client/src/commands.js
var createCommands = configure4((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

// node_modules/ipfs-http-client/src/dns.js
var createDns2 = configure4((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

// node_modules/ipfs-http-client/src/get-endpoint-config.js
var createGetEndpointConfig = configure4((api) => {
  return () => {
    const url2 = new URL(api.opts.base || "");
    return {
      host: url2.hostname,
      port: url2.port,
      protocol: url2.protocol,
      pathname: url2.pathname,
      "api-path": url2.pathname
    };
  };
});

// node_modules/ipfs-http-client/src/get.js
var createGet10 = configure4((api) => {
  async function* get3(path2, options = {}) {
    const opts = {
      arg: `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get3;
});

// node_modules/ipfs-http-client/src/id.js
var createId2 = configure4((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});

// node_modules/ipfs-http-client/src/is-online.js
var createIsOnline2 = (options) => {
  const id = createId2(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

// node_modules/ipfs-http-client/src/ls.js
var createLs10 = configure4((api, opts) => {
  async function* ls(path2, options = {}) {
    const pathStr = `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`;
    async function mapLink(link) {
      let hash3 = link.Hash;
      if (hash3.includes("/")) {
        const ipfsPath3 = hash3.startsWith("/ipfs/") ? hash3 : `/ipfs/${hash3}`;
        const stats = await createStat8(opts)(ipfsPath3);
        hash3 = stats.cid;
      } else {
        hash3 = CID.parse(hash3);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash3,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links3 = result.Links;
      if (!Array.isArray(links3)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links3.length) {
        yield mapLink(result);
        return;
      }
      yield* links3.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}

// node_modules/ipfs-http-client/src/mount.js
var createMount = configure4((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});

// node_modules/ipfs-http-client/src/ping.js
var createPing = configure4((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

// node_modules/ipfs-http-client/src/resolve.js
var createResolve6 = configure4((api) => {
  async function resolve7(path2, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve7;
});

// node_modules/ipfs-http-client/src/start.js
var import_err_code79 = __toESM(require_err_code(), 1);
var createStart2 = configure4((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code79.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});

// node_modules/ipfs-http-client/src/stop.js
var createStop2 = configure4((api) => {
  async function stop2(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop2;
});

// node_modules/ipfs-http-client/src/version.js
var createVersion4 = configure4((api) => {
  async function version4(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version4;
});

// node_modules/ipfs-http-client/src/index.js
var import_glob_source = __toESM(require_glob_source());
var import_url_source = __toESM(require_url_source());
function create16(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base30) => multibaseCodecs.push(base30));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [src_exports, esm_exports, esm_exports2, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd8(options),
    addAll: createAddAll4(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat2(options),
    commands: createCommands(options),
    config: createConfig2(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns2(options),
    files: createFiles2(options),
    get: createGet10(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId2(options),
    isOnline: createIsOnline2(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs10(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs2(options),
    repo: createRepo3(options),
    resolve: createResolve6(options),
    start: createStart2(options),
    stats: createStats(options),
    stop: createStop2(options),
    swarm: createSwarm(options),
    version: createVersion4(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}

// node_modules/@libp2p/webrtc-star/dist/src/index.js
var import_err_code84 = __toESM(require_err_code());

// node_modules/@libp2p/webrtc-star/dist/src/constants.js
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT = 2e3;

// node_modules/@libp2p/webrtc-star/dist/src/listener.js
var import_err_code83 = __toESM(require_err_code(), 1);

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
var encodePacket_browser_default = encodePacket;

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup[chars.charCodeAt(i2)] = i2;
}
var decode63 = (base6416) => {
  let bufferLength = base6416.length * 0.75, len = base6416.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base6416[base6416.length - 1] === "=") {
    bufferLength--;
    if (base6416[base6416.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup[base6416.charCodeAt(i2)];
    encoded2 = lookup[base6416.charCodeAt(i2 + 1)];
    encoded3 = lookup[base6416.charCodeAt(i2 + 2)];
    encoded4 = lookup[base6416.charCodeAt(i2 + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode63(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
var decodePacket_browser_default = decodePacket;

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length23 = packets.length;
  const encodedPackets = new Array(length23);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket_browser_default(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length23) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket_browser_default(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
var protocol = 4;

// node_modules/@socket.io/component-emitter/index.mjs
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globalThis.browser.js
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length23 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length23 += 1;
    } else if (c < 2048) {
      length23 += 2;
    } else if (c < 55296 || c >= 57344) {
      length23 += 3;
    } else {
      i2++;
      length23 += 4;
    }
  }
  return length23;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  onData(data) {
    const packet = decodePacket_browser_default(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  pause(onPause) {
  }
};

// node_modules/engine.io-client/build/esm/contrib/yeast.js
var alphabet10 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length13 = 64;
var map12 = {};
var seed = 0;
var i = 0;
var prev;
function encode53(num) {
  let encoded = "";
  do {
    encoded = alphabet10[num % length13] + encoded;
    num = Math.floor(num / length13);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode53(+new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode53(seed++);
}
for (; i < length13; i++)
  map12[alphabet10[i]] = i;

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode54(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode64(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair2 = pairs[i2].split("=");
    qry[decodeURIComponent(pair2[0])] = decodeURIComponent(pair2[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err2) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/polling.js
function empty12() {
}
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = class extends Transport {
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      } else {
      }
    }
  }
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    const encodedQuery = encode54(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class extends Emitter {
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  create() {
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  onError(err2) {
    this.emitReserved("error", err2, this.xhr);
    this.cleanup(true);
  }
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty12;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  abort() {
    this.cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var WebSocket2 = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var usingBrowserWebSocket = true;
var defaultBinaryType = "arraybuffer";

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS = class extends Transport {
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
    } catch (err2) {
      return this.emitReserved("error", err2);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket_browser_default(packet, this.supportsBinary, (data) => {
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (this.opts.perMessageDeflate) {
            const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          } else {
            this.ws.send(data, opts);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    const encodedQuery = encode54(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  check() {
    return !!WebSocket2;
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  polling: Polling
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse2(str) {
  const src18 = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src18;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names3 = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names3.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names3.splice(names3.length - 1, 1);
  }
  return names3;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var Socket = class extends Emitter {
  constructor(uri, opts = {}) {
    super();
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse2(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse2(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || ["polling", "websocket"];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode64(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  createTransport(name22) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name22;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts.transportOptions[name22], this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[name22](opts);
  }
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  probe(name22) {
    let transport = this.createTransport(name22);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err2 = new Error("probe error");
          err2.transport = transport.name;
          this.emitReserved("upgradeError", err2);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err2) => {
      const error = new Error("probe error: " + err2);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport.open();
  }
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err2 = new Error("server error");
          err2.code = packet.data;
          this.onError(err2);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  onError(err2) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err2);
    this.onClose("transport error", err2);
  }
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j = upgrades.length;
    for (; i2 < j; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket.protocol = protocol;

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse2(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  Decoder: () => Decoder12,
  Encoder: () => Encoder12,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString19 = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString19.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString19.call(File) === "[object FileConstructor]";
function isBinary2(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary2(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack2 = packet;
  pack2.data = _deconstructPacket(packetData, buffers);
  pack2.attachments = buffers.length;
  return { packet: pack2, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary2(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder12 = class {
  constructor(replacer) {
    this.replacer = replacer;
  }
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack2 = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack2);
    return buffers;
  }
};
var Decoder12 = class extends Emitter {
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary2(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf2 = str.substring(start, i2);
      if (buf2 != Number(buf2) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf2);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder12.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return typeof payload === "object";
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || typeof payload === "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && payload.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
    } else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    var _a3;
    const timeout = (_a3 = this.flags.timeout) !== null && _a3 !== void 0 ? _a3 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((resolve7, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve7(arg2);
        } else {
          return resolve7(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err2, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err2 !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err2);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  onerror(err2) {
    if (!this.connected) {
      this.emitReserved("connect_error", err2);
    }
  }
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err2 = new Error(packet.data.message);
        err2.data = packet.data.data;
        this.emitReserved("connect_error", err2);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
    }
  }
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a3;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports5;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a3;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a3;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a3;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const errorSub = on(socket, "error", (err2) => {
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err2);
      if (fn) {
        fn(err2);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (false !== this._timeout) {
      const timeout = this._timeout;
      if (timeout === 0) {
        openSubDestroy();
      }
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        socket.close();
        socket.emit("error", new Error("timeout"));
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn) {
    return this.open(fn);
  }
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  onerror(err2) {
    this.emitReserved("error", err2);
  }
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay3 = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err2) => {
          if (err2) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err2);
          } else {
            self2.onreconnect();
          }
        });
      }, delay3);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache11 = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache11[id] && path2 in cache11[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache11[id]) {
      cache11[id] = new Manager(source, opts);
    }
    io = cache11[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// node_modules/@libp2p/webrtc-peer/dist/src/peer.js
var import_err_code81 = __toESM(require_err_code(), 1);
var import_random = __toESM(require_random_browser(), 1);

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/identity.js
var identity_exports19 = {};
__export(identity_exports19, {
  identity: () => identity19
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/vendor/base-x.js
function base15(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src12 = base15;
var _brrp__multiformats_scope_baseX12 = src12;
var base_x_default12 = _brrp__multiformats_scope_baseX12;

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bytes.js
var empty13 = new Uint8Array(0);
var equals27 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce12 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString19 = (str) => new TextEncoder().encode(str);
var toString20 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base.js
var Encoder13 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder13 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or13(this, decoder);
  }
};
var ComposedDecoder12 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or13(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or13 = (left, right) => new ComposedDecoder12({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec12 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder13(name22, prefix, baseEncode);
    this.decoder = new Decoder13(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from21 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec12(name22, prefix, encode81, decode97);
var baseX12 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default12(alphabet16, name22);
  return from21({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce12(decode97(text))
  });
};
var decode65 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode55 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464812 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from21({
    prefix,
    name: name22,
    encode(input) {
      return encode55(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode65(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/identity.js
var identity19 = from21({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString20(buf2),
  decode: (str) => fromString19(str)
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base2.js
var base2_exports10 = {};
__export(base2_exports10, {
  base2: () => base211
});
var base211 = rfc464812({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base8.js
var base8_exports10 = {};
__export(base8_exports10, {
  base8: () => base810
});
var base810 = rfc464812({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base10.js
var base10_exports10 = {};
__export(base10_exports10, {
  base10: () => base1010
});
var base1010 = baseX12({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base16.js
var base16_exports10 = {};
__export(base16_exports10, {
  base16: () => base1610,
  base16upper: () => base16upper10
});
var base1610 = rfc464812({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper10 = rfc464812({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base32.js
var base32_exports10 = {};
__export(base32_exports10, {
  base32: () => base3212,
  base32hex: () => base32hex12,
  base32hexpad: () => base32hexpad12,
  base32hexpadupper: () => base32hexpadupper12,
  base32hexupper: () => base32hexupper12,
  base32pad: () => base32pad12,
  base32padupper: () => base32padupper12,
  base32upper: () => base32upper12,
  base32z: () => base32z12
});
var base3212 = rfc464812({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper12 = rfc464812({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad12 = rfc464812({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper12 = rfc464812({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex12 = rfc464812({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper12 = rfc464812({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad12 = rfc464812({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper12 = rfc464812({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z12 = rfc464812({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base36.js
var base36_exports10 = {};
__export(base36_exports10, {
  base36: () => base3610,
  base36upper: () => base36upper10
});
var base3610 = baseX12({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper10 = baseX12({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base58.js
var base58_exports10 = {};
__export(base58_exports10, {
  base58btc: () => base58btc12,
  base58flickr: () => base58flickr12
});
var base58btc12 = baseX12({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr12 = baseX12({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base64.js
var base64_exports10 = {};
__export(base64_exports10, {
  base64: () => base6411,
  base64pad: () => base64pad11,
  base64url: () => base64url11,
  base64urlpad: () => base64urlpad11
});
var base6411 = rfc464812({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad11 = rfc464812({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url11 = rfc464812({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad11 = rfc464812({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports10 = {};
__export(base256emoji_exports10, {
  base256emoji: () => base256emoji10
});
var alphabet11 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars10 = alphabet11.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes10 = alphabet11.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode56(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars10[c];
    return p;
  }, "");
}
function decode66(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes10[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji10 = from21({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode56,
  decode: decode66
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports10 = {};
__export(sha2_browser_exports10, {
  sha256: () => sha25610,
  sha512: () => sha51210
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/vendor/varint.js
var encode_111 = encode57;
var MSB11 = 128;
var REST11 = 127;
var MSBALL11 = ~REST11;
var INT11 = Math.pow(2, 31);
function encode57(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT11) {
    out[offset++] = num & 255 | MSB11;
    num /= 128;
  }
  while (num & MSBALL11) {
    out[offset++] = num & 255 | MSB11;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode57.bytes = offset - oldOffset + 1;
  return out;
}
var decode67 = read11;
var MSB$111 = 128;
var REST$111 = 127;
function read11(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read11.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$111) << shift : (b & REST$111) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$111);
  read11.bytes = counter - offset;
  return res;
}
var N112 = Math.pow(2, 7);
var N212 = Math.pow(2, 14);
var N312 = Math.pow(2, 21);
var N412 = Math.pow(2, 28);
var N512 = Math.pow(2, 35);
var N612 = Math.pow(2, 42);
var N712 = Math.pow(2, 49);
var N812 = Math.pow(2, 56);
var N912 = Math.pow(2, 63);
var length14 = function(value2) {
  return value2 < N112 ? 1 : value2 < N212 ? 2 : value2 < N312 ? 3 : value2 < N412 ? 4 : value2 < N512 ? 5 : value2 < N612 ? 6 : value2 < N712 ? 7 : value2 < N812 ? 8 : value2 < N912 ? 9 : 10;
};
var varint17 = {
  encode: encode_111,
  decode: decode67,
  encodingLength: length14
};
var _brrp_varint11 = varint17;
var varint_default11 = _brrp_varint11;

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/varint.js
var decode68 = (data, offset = 0) => {
  const code22 = varint_default11.decode(data, offset);
  return [code22, varint_default11.decode.bytes];
};
var encodeTo11 = (int, target, offset = 0) => {
  varint_default11.encode(int, target, offset);
  return target;
};
var encodingLength11 = (int) => {
  return varint_default11.encodingLength(int);
};

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/hashes/digest.js
var create17 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength11(code22);
  const digestOffset = sizeOffset + encodingLength11(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo11(code22, bytes2, 0);
  encodeTo11(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest11(code22, size, digest15, bytes2);
};
var decode69 = (multihash) => {
  const bytes2 = coerce12(multihash);
  const [code22, sizeOffset] = decode68(bytes2);
  const [size, digestOffset] = decode68(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest11(code22, size, digest15, bytes2);
};
var equals28 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals27(a.bytes, data.bytes);
  }
};
var Digest11 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/hashes/hasher.js
var from22 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher10(name22, code22, encode81);
var Hasher10 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create17(this.code, result) : result.then((digest15) => create17(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/hashes/sha2-browser.js
var sha10 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25610 = from22({
  name: "sha2-256",
  code: 18,
  encode: sha10("SHA-256")
});
var sha51210 = from22({
  name: "sha2-512",
  code: 19,
  encode: sha10("SHA-512")
});

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/hashes/identity.js
var identity_exports20 = {};
__export(identity_exports20, {
  identity: () => identity20
});
var code16 = 0;
var name16 = "identity";
var encode58 = coerce12;
var digest10 = (input) => create17(code16, encode58(input));
var identity20 = { code: code16, name: name16, encode: encode58, digest: digest10 };

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/codecs/json.js
var textEncoder13 = new TextEncoder();
var textDecoder12 = new TextDecoder();

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/cid.js
var format10 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV011(
        bytes2,
        baseCache10(link),
        base30 || base58btc12.encoder
      );
    default:
      return toStringV111(
        bytes2,
        baseCache10(link),
        base30 || base3212.encoder
      );
  }
};
var cache12 = /* @__PURE__ */ new WeakMap();
var baseCache10 = (cid) => {
  const baseCache16 = cache12.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache12.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID11 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE11) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE11) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID11.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create17(code22, digest15);
        return CID11.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID11.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals28(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format10(this, base30);
  }
  toJSON() {
    return { "/": format10(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID11) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID11(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID12(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol11] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode69(multihash);
      return CID11.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE11) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE11}) block encoding`
          );
        } else {
          return new CID11(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID12(version4, code22, digest15.bytes);
        return new CID11(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID11.create(0, DAG_PB_CODE11, digest15);
  }
  static createV1(code22, digest15) {
    return CID11.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID11.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID11.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce12(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest11(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID11.createV0(digest15) : CID11.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode68(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE11;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes11(source, base30);
    const cid = CID11.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache10(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes11 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc12;
      return [
        base58btc12.prefix,
        decoder.decode(`${base58btc12.prefix}${source}`)
      ];
    }
    case base58btc12.prefix: {
      const decoder = base30 || base58btc12;
      return [base58btc12.prefix, decoder.decode(source)];
    }
    case base3212.prefix: {
      const decoder = base30 || base3212;
      return [base3212.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV011 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc12.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV111 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE11 = 112;
var SHA_256_CODE11 = 18;
var encodeCID12 = (version4, code22, multihash) => {
  const codeOffset = encodingLength11(version4);
  const hashOffset = codeOffset + encodingLength11(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo11(version4, bytes2, 0);
  encodeTo11(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol11 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webrtc-peer/node_modules/multiformats/src/basics.js
var bases10 = { ...identity_exports19, ...base2_exports10, ...base8_exports10, ...base10_exports10, ...base16_exports10, ...base32_exports10, ...base36_exports10, ...base58_exports10, ...base64_exports10, ...base256emoji_exports10 };
var hashes10 = { ...sha2_browser_exports10, ...identity_exports20 };

// node_modules/@libp2p/webrtc-peer/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array11(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/webrtc-peer/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe12(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array11(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/webrtc-peer/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec13(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string9 = createCodec13("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii9 = createCodec13("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe12(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES9 = {
  utf8: string9,
  "utf-8": string9,
  hex: bases10.base16,
  latin1: ascii9,
  ascii: ascii9,
  binary: ascii9,
  ...bases10
};
var bases_default9 = BASES9;

// node_modules/@libp2p/webrtc-peer/node_modules/uint8arrays/dist/src/to-string.js
function toString21(array, encoding = "utf8") {
  const base30 = bases_default9[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/webrtc-peer/dist/src/channel.js
var import_err_code80 = __toESM(require_err_code(), 1);
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
var WebRTCDataChannel = class {
  constructor(channel, opts) {
    this.label = channel.label;
    this.open = pDefer();
    this.channel = channel;
    this.channel.binaryType = "arraybuffer";
    this.log = opts.log;
    if (typeof this.channel.bufferedAmountLowThreshold === "number") {
      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    channel.addEventListener("message", (event) => {
      opts.onMessage(event);
    });
    channel.addEventListener("bufferedamountlow", () => {
      this.log("stop backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open.resolve();
    });
    channel.addEventListener("open", () => {
      this.open.resolve();
      opts.onOpen();
    });
    channel.addEventListener("close", () => {
      opts.onClose();
    });
    channel.addEventListener("error", (event) => {
      if (event.error?.message === "Transport channel closed") {
        return this.close();
      }
      opts.log.error('channel encounter an error in state "%s" message: "%s" detail: "%s', channel.readyState, event.error?.message, event.error?.errorDetail);
      const err2 = event.error instanceof Error ? event.error : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`);
      opts.onError((0, import_err_code80.default)(err2, "ERR_DATA_CHANNEL"));
    });
    let isClosing = false;
    this.closingInterval = setInterval(() => {
      if (channel.readyState === "closing") {
        if (isClosing) {
          opts.onClose();
        }
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  async send(data) {
    await this.open.promise;
    this.channel.send(data);
    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      this.log("start backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open = pDefer();
    }
  }
  close() {
    clearInterval(this.closingInterval);
    this.channel.close();
  }
  get bufferedAmount() {
    return this.channel.bufferedAmount;
  }
};

// node_modules/@libp2p/webrtc-peer/dist/src/peer.js
var import_delay = __toESM(require_delay(), 1);
var DEFAULT_PEER_CONNECTION_CONFIG = {
  iceServers: [{
    urls: [
      "stun:stun.l.google.com:19302",
      "stun:global.stun.twilio.com:3478"
    ]
  }]
};
function getBrowserRTC() {
  if (typeof globalThis === "undefined") {
    throw (0, import_err_code81.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  const wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate
  };
  if (wrtc.RTCPeerConnection == null) {
    throw (0, import_err_code81.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  return wrtc;
}
var WebRTCPeer = class extends EventEmitter2 {
  constructor(opts) {
    super();
    this.id = opts.id ?? toString21((0, import_random.default)(4), "hex").slice(0, 7);
    this.log = logger(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`);
    this.wrtc = opts.wrtc ?? getBrowserRTC();
    this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig));
    this.closed = false;
    this.connected = pDefer();
    this.source = pushable();
    this.sink = async (source) => {
      await this.connected.promise;
      if (this.channel == null) {
        throw (0, import_err_code81.default)(new Error("Connected but no channel?!"), "ERR_DATA_CHANNEL");
      }
      for await (const buf2 of source) {
        await this.channel.send(buf2);
      }
      await this.close();
    };
  }
  handleDataChannelEvent(event) {
    const dataChannel = event.channel;
    if (dataChannel == null) {
      this.close((0, import_err_code81.default)(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")).catch((err2) => {
        this.log("Error closing after event channel was found to be null", err2);
      });
      return;
    }
    this.channel = new WebRTCDataChannel(dataChannel, {
      log: this.log,
      onMessage: (event2) => {
        this.source.push(new Uint8Array(event2.data));
      },
      onOpen: () => {
        this.connected.resolve();
        this.dispatchEvent(new CustomEvent("ready"));
      },
      onClose: () => {
        this.close().catch((err2) => {
          this.log("error closing connection after channel close", err2);
        });
      },
      onError: (err2) => {
        this.close(err2).catch((err3) => {
          this.log("error closing connection after channel error", err3);
        });
      }
    });
  }
  async close(err2) {
    this.closed = true;
    if (err2 == null && this.channel != null) {
      while (this.channel.bufferedAmount > 0) {
        await (0, import_delay.default)(100);
      }
    }
    this.channel?.close();
    this.peerConnection.close();
    this.source.end(err2);
    this.dispatchEvent(new CustomEvent("close"));
  }
};

// node_modules/@libp2p/webrtc-peer/dist/src/handshake.js
var import_err_code82 = __toESM(require_err_code(), 1);
var WebRTCHandshake = class extends EventEmitter2 {
  constructor(options) {
    super();
    this.log = options.log;
    this.peerConnection = options.peerConnection;
    this.wrtc = options.wrtc;
    this.status = "idle";
    this.peerConnection.addEventListener("negotiationneeded", () => {
      this.log("peer connection negotiation needed");
      this.handleRenegotiate({ type: "renegotiate" }).catch((err2) => {
        this.log.error("could not renegotiate %o", err2);
      });
    });
  }
  async handleSignal(signal) {
    this.log('incoming signal "%s"', signal.type);
    if (signal.type === "offer") {
      return await this.handleOffer(signal);
    } else if (signal.type === "answer") {
      return await this.handleAnswer(signal);
    } else if (signal.type === "candidate") {
      return await this.handleCandidate(signal);
    } else if (signal.type === "renegotiate") {
      return await this.handleRenegotiate(signal);
    } else if (signal.type === "goodbye") {
      return await this.handleGoodye(signal);
    } else {
      this.log(`Unknown signal type ${signal.type}`);
    }
  }
  async handleOffer(signal) {
  }
  async handleAnswer(signal) {
  }
  async handleRenegotiate(signal) {
  }
  async handleGoodye(signal) {
    this.peerConnection.close();
  }
  async handleCandidate(signal) {
    const iceCandidate = new this.wrtc.RTCIceCandidate(signal.candidate);
    try {
      await this.peerConnection.addIceCandidate(iceCandidate);
    } catch (err2) {
      if (iceCandidate.address == null || iceCandidate.address.endsWith(".local")) {
        this.log("ignoring unsupported ICE candidate.");
      } else {
        throw (0, import_err_code82.default)(err2, "ERR_ADD_ICE_CANDIDATE");
      }
    }
  }
};

// node_modules/@libp2p/webrtc-peer/dist/src/receiver.js
var log51 = logger("libp2p:webrtc-peer:receiver");
var WebRTCReceiver = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "receiver"
    });
    this.handshake = new WebRTCReceiverHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      answerOptions: opts.answerOptions
    });
    this.handshake.addEventListener("signal", (event) => this.dispatchEvent(new CustomEvent("signal", {
      detail: event.detail
    })));
    this.peerConnection.addEventListener("datachannel", (event) => {
      this.handleDataChannelEvent(event);
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
};
var WebRTCReceiverHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.iceCandidates = [];
  }
  async handleRenegotiate() {
    log51.trace("renegotiate");
    this.dispatchEvent(new CustomEvent("signal", {
      detail: {
        type: "renegotiate"
      }
    }));
  }
  async handleOffer(signal) {
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    for (const candidate of this.iceCandidates) {
      await this.handleCandidate(candidate);
    }
    this.iceCandidates = [];
    const answer = await this.peerConnection.createAnswer(this.options.answerOptions);
    await this.peerConnection.setLocalDescription(answer);
    log51.trace("handle offer", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? answer
    }));
  }
  async handleCandidate(signal) {
    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {
      this.iceCandidates.push(signal);
      return;
    }
    await super.handleCandidate(signal);
  }
};

// node_modules/@libp2p/webrtc-peer/dist/src/initiator.js
var import_random2 = __toESM(require_random_browser(), 1);

// node_modules/p-event/node_modules/p-timeout/index.js
var TimeoutError4 = class extends Error {
  constructor(message6) {
    super(message6);
    this.name = "TimeoutError";
  }
};
var AbortError6 = class extends Error {
  constructor(message6) {
    super();
    this.name = "AbortError";
    this.message = message6;
  }
};
var getDOMException3 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError6(errorMessage) : new DOMException(errorMessage);
var getAbortedReason3 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException3("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException3(reason);
};
function pTimeout3(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason3(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason3(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message6 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError4(message6);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve7, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    const events2 = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value2 = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value2)) {
        return;
      }
      items.push(value2);
      if (options.count === items.length) {
        cancel();
        resolve7(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events2) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events2) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options.resolveImmediately) {
      resolve7(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout3(returnValue, options.timeout);
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// node_modules/@libp2p/webrtc-peer/dist/src/initiator.js
var import_delay2 = __toESM(require_delay(), 1);
var log52 = logger("libp2p:webrtc-peer:initator");
var ICECOMPLETE_TIMEOUT = 1e3;
var WebRTCInitiator = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "initiator"
    });
    this.handleDataChannelEvent({
      channel: this.peerConnection.createDataChannel(opts.dataChannelLabel ?? toString21((0, import_random2.default)(20), "hex").slice(0, 7), opts.dataChannelInit)
    });
    this.handshake = new WebRTCInitiatorHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      offerOptions: opts.offerOptions
    });
    this.handshake.addEventListener("signal", (event) => {
      this.dispatchEvent(new CustomEvent("signal", { detail: event.detail }));
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
};
var WebRTCInitiatorHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.peerConnection.addEventListener("icecandidate", (event) => {
      if (event.candidate == null) {
        return;
      }
      const signal = {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      };
      log52.trace("create candidate", signal);
      this.dispatchEvent(new CustomEvent("signal", {
        detail: signal
      }));
      this.dispatchEvent(new CustomEvent("ice-candidate"));
    });
  }
  async handleRenegotiate() {
    if (this.status === "negotiating") {
      this.log("already negotiating, queueing");
      return;
    }
    this.status = "negotiating";
    const offer = await this.peerConnection.createOffer(this.options.offerOptions);
    await this.peerConnection.setLocalDescription(offer);
    await pEvent(this, "ice-candidate");
    await (0, import_delay2.default)(ICECOMPLETE_TIMEOUT);
    log52.trace("renegotiate", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? offer
    }));
  }
  async handleAnswer(signal) {
    log52.trace("handle answer", signal);
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    this.status = "idle";
  }
};

// node_modules/@libp2p/webrtc-star/dist/src/socket-to-conn.js
var log53 = logger("libp2p:webrtc-star:socket");
function toMultiaddrConnection(socket, options) {
  const { sink, source } = socket;
  const maConn = {
    remoteAddr: options.remoteAddr,
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log53.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(source, options.signal) : source,
    timeline: { open: Date.now() },
    async close() {
      if (socket.closed) {
        return;
      }
      const start = Date.now();
      const timeout = setTimeout(() => {
        if (maConn.remoteAddr != null) {
          const { host, port } = maConn.remoteAddr.toOptions();
          log53("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        }
        if (!socket.closed) {
          socket.close().catch((err2) => {
            log53.error("could not close socket", err2);
          });
        }
      }, CLOSE_TIMEOUT);
      try {
        await socket.close();
      } finally {
        clearTimeout(timeout);
      }
    }
  };
  socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, {
    once: true
  });
  return maConn;
}

// node_modules/@libp2p/webrtc-star/dist/src/utils.js
function cleanUrlSIO(ma) {
  const maStrSplit = ma.toString().split("/");
  const tcpProto = ma.protos()[1].name;
  const wsProto = ma.protos()[2].name;
  const tcpPort = ma.stringTuples()[1][1];
  if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
    throw new Error(`invalid multiaddr: ${ma.toString()}`);
  }
  if (!isName(ma)) {
    return `http://${maStrSplit[2]}:${maStrSplit[4]}`;
  }
  if (wsProto === "ws") {
    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === "80" ? "" : `:${tcpPort}`}`;
  }
  if (wsProto === "wss") {
    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === "443" ? "" : `:${tcpPort}`}`;
  }
  throw new Error("invalid multiaddr: " + ma.toString());
}
function cleanMultiaddr(maStr) {
  const legacy = "/libp2p-webrtc-star";
  if (maStr.startsWith(legacy)) {
    maStr = maStr.substring(legacy.length, maStr.length);
    let ma = multiaddr(maStr);
    const tuppleIPFS = ma.stringTuples().filter((tupple) => {
      return tupple[0] === 421;
    })[0];
    if (tuppleIPFS[1] == null) {
      throw new Error("invalid multiaddr: " + maStr);
    }
    ma = ma.decapsulate("p2p");
    ma = ma.encapsulate("/p2p-webrtc-star");
    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
    maStr = ma.toString();
  }
  return maStr;
}

// node_modules/@libp2p/webrtc-star/dist/src/listener.js
var log54 = logger("libp2p:webrtc-star:listener");
var sioOptions = {
  transports: ["websocket"],
  path: "/socket.io-next/"
};
var SigServer = class extends EventEmitter2 {
  constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {
    super();
    this.signallingAddr = signallingAddr;
    this.socket = lookup2(signallingUrl, sioOptions);
    this.connections = [];
    this.channels = /* @__PURE__ */ new Map();
    this.pendingSignals = /* @__PURE__ */ new Map();
    this.upgrader = upgrader;
    this.handler = handler;
    this.channelOptions = channelOptions;
    this.handleWsHandshake = this.handleWsHandshake.bind(this);
    let previouslyConnected = false;
    this.socket.on("connect_error", (err2) => {
      if (previouslyConnected && err2.type === "TransportError") {
        return;
      }
      this.dispatchEvent(new CustomEvent("error", {
        detail: err2
      }));
    });
    this.socket.on("error", (err2) => {
      this.dispatchEvent(new CustomEvent("error", {
        detail: err2
      }));
    });
    this.socket.on("ws-handshake", this.handleWsHandshake);
    this.socket.on("ws-peer", (maStr) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: maStr
      }));
    });
    this.socket.on("connect", () => {
      this.socket.emit("ss-join", this.signallingAddr.toString());
      if (previouslyConnected) {
        this.dispatchEvent(new CustomEvent("reconnect"));
      }
    });
    this.socket.once("connect", () => {
      previouslyConnected = true;
      this.dispatchEvent(new CustomEvent("listening"));
    });
    this.socket.on("disconnect", () => {
      this.dispatchEvent(new CustomEvent("disconnect"));
    });
  }
  _createChannel(intentId, srcMultiaddr, dstMultiaddr) {
    const channelOptions = {
      ...this.channelOptions
    };
    const channel = new WebRTCReceiver(channelOptions);
    const onError = (evt) => {
      const err2 = evt.detail;
      log54.error("incoming connection errored", err2);
    };
    channel.addEventListener("error", onError);
    channel.addEventListener("close", () => {
      channel.removeEventListener("error", onError);
    }, {
      once: true
    });
    channel.addEventListener("signal", (evt) => {
      const signal = evt.detail;
      this.socket.emit("ss-handshake", {
        intentId,
        srcMultiaddr,
        dstMultiaddr,
        answer: true,
        signal
      });
    });
    channel.addEventListener("ready", () => {
      const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr });
      log54("new inbound connection %s", maConn.remoteAddr);
      try {
        this.upgrader.upgradeInbound(maConn).then((conn) => {
          log54("inbound connection %s upgraded", maConn.remoteAddr);
          this.connections.push(maConn);
          const untrackConn = () => {
            this.connections = this.connections.filter((c) => c !== maConn);
            this.channels.delete(intentId);
            this.pendingSignals.delete(intentId);
          };
          channel.addEventListener("close", untrackConn, {
            once: true
          });
          this.dispatchEvent(new CustomEvent("connection", {
            detail: conn
          }));
          this.handler(conn);
        }).catch((err2) => {
          log54.error("inbound connection failed to upgrade", err2);
          maConn.close().catch((err3) => {
            log54.error("inbound connection failed to close after failing to upgrade", err3);
          });
        });
      } catch (err2) {
        log54.error("inbound connection failed to upgrade", err2);
        maConn.close().catch((err3) => {
          log54.error("inbound connection failed to close after failing to upgrade", err3);
        });
      }
    }, {
      once: true
    });
    return channel;
  }
  handleWsHandshake(offer) {
    log54('incoming handshake. signal type "%s" is answer %s', offer.signal.type, offer.answer);
    if (offer.answer === true || offer.err != null || offer.intentId == null) {
      return;
    }
    const intentId = offer.intentId;
    let pendingSignals = this.pendingSignals.get(intentId);
    if (pendingSignals == null) {
      pendingSignals = [];
      this.pendingSignals.set(intentId, pendingSignals);
    }
    pendingSignals.push(offer);
    let channel = this.channels.get(intentId);
    if (channel == null) {
      if (offer.signal.type !== "offer") {
        log54("handshake is not an offer and channel does not exist, buffering until we receive an offer");
        return;
      }
      log54("creating new channel to handle offer handshake");
      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);
      this.channels.set(intentId, channel);
    } else {
      log54("channel already exists, using it to handle handshake");
    }
    while (pendingSignals.length > 0) {
      const handshake2 = pendingSignals.shift();
      if (handshake2?.signal != null) {
        channel.handleSignal(handshake2.signal);
      }
    }
  }
  async close() {
    this.socket.emit("ss-leave", this.signallingAddr.toString());
    this.socket.removeAllListeners();
    this.socket.close();
    await Promise.all([
      ...this.connections.map(async (maConn) => await maConn.close()),
      ...Array.from(this.channels.values()).map(async (channel) => await channel.close())
    ]);
    this.dispatchEvent(new CustomEvent("close"));
  }
};
var WebRTCListener = class extends EventEmitter2 {
  constructor(upgrader, handler, peerId, transport, options) {
    super();
    this.upgrader = upgrader;
    this.handler = handler;
    this.peerId = peerId;
    this.transport = transport;
    this.options = options;
  }
  async listen(ma) {
    if (this.listeningAddr != null) {
      throw (0, import_err_code83.default)(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
    }
    const defer = pDefer();
    this.listeningAddr = ma;
    let signallingAddr;
    if (!ma.protoCodes().includes(CODE_P2P)) {
      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);
    } else {
      signallingAddr = ma;
    }
    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);
    log54("connecting to signalling server on: %s", this.signallingUrl);
    const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);
    server.addEventListener("error", (evt) => {
      const err2 = evt.detail;
      log54("error connecting to signalling server %o", err2);
      server.close().catch((err3) => {
        log54.error("error closing server after error", err3);
      });
      defer.reject(err2);
    });
    server.addEventListener("listening", () => {
      log54("connected to signalling server");
      this.dispatchEvent(new CustomEvent("listening"));
      defer.resolve();
    });
    server.addEventListener("peer", (evt) => {
      this.transport.peerDiscovered(evt.detail);
    });
    server.addEventListener("connection", (evt) => {
      const conn = evt.detail;
      if (conn.remoteAddr == null) {
        try {
          conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);
        } catch (err2) {
          log54.error("could not determine remote address", err2);
        }
      }
      this.dispatchEvent(new CustomEvent("connection", {
        detail: conn
      }));
    });
    server.addEventListener("disconnect", () => {
      this.transport.sigServers.delete(signallingUrl);
    });
    server.addEventListener("reconnect", () => {
      this.transport.sigServers.set(signallingUrl, server);
    });
    this.transport.sigServers.set(this.signallingUrl, server);
    return await defer.promise;
  }
  async close() {
    if (this.signallingUrl != null) {
      const server = this.transport.sigServers.get(this.signallingUrl);
      if (server != null) {
        await server.close();
        this.transport.sigServers.delete(this.signallingUrl);
      }
    }
    this.dispatchEvent(new CustomEvent("close"));
    this.listeningAddr = void 0;
  }
  getAddrs() {
    if (this.listeningAddr != null) {
      return [
        this.listeningAddr
      ];
    }
    return [];
  }
};
function createListener(upgrader, handler, peerId, transport, options) {
  return new WebRTCListener(upgrader, handler, peerId, transport, options);
}

// node_modules/@libp2p/webrtc-star/dist/src/index.js
var import_random3 = __toESM(require_random_browser());

// node_modules/uint8arrays/esm/src/index.js
init_concat();

// node_modules/uint8arrays/esm/src/xor.js
init_alloc();
init_as_uint8array();
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    result[i2] = a[i2] ^ b[i2];
  }
  return asUint8Array(result);
}

// node_modules/@libp2p/interface-transport/dist/src/index.js
var symbol4 = Symbol.for("@libp2p/transport");

// node_modules/@libp2p/interface-peer-discovery/dist/src/index.js
var symbol5 = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/webrtc-star/dist/src/index.js
var webrtcSupport = "RTCPeerConnection" in globalThis;
var log55 = logger("libp2p:webrtc-star");
var noop3 = () => {
};
var WebRTCStarDiscovery = class extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.started = false;
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star-discovery";
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  dispatchEvent(event) {
    if (!this.isStarted()) {
      return false;
    }
    return super.dispatchEvent(event);
  }
};
var WebRTCStar2 = class {
  constructor(options) {
    this.components = new Components();
    if (options?.wrtc != null) {
      this.wrtc = options.wrtc;
    }
    this.sigServers = /* @__PURE__ */ new Map();
    this.discovery = new WebRTCStarDiscovery();
    this.peerDiscovered = this.peerDiscovered.bind(this);
  }
  get [symbol4]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star";
  }
  init(components) {
    this.components = components;
  }
  async dial(ma, options) {
    const rawConn = await this._connect(ma, options);
    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal });
    log55("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log55("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options.signal?.aborted === true) {
      throw new AbortError5();
    }
    const channelOptions = {
      ...options.channelOptions ?? {}
    };
    if (this.wrtc != null) {
      channelOptions.wrtc = this.wrtc;
    }
    const cOpts = ma.toOptions();
    const intentId = toString11((0, import_random3.default)(36), "hex");
    return await new Promise((resolve7, reject) => {
      const sio = this.sigServers.get(cleanUrlSIO(ma));
      if (sio?.socket == null) {
        return reject((0, import_err_code84.default)(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
      }
      let connected = false;
      log55("dialing %s:%s", cOpts.host, cOpts.port);
      const channel = new WebRTCInitiator(channelOptions);
      const onError = (evt) => {
        const err2 = evt.detail;
        if (!connected) {
          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err2.message}`;
          log55.error(msg);
          done(err2);
        }
      };
      const onReady = () => {
        connected = true;
        log55("connection opened %s:%s", cOpts.host, cOpts.port);
        done();
      };
      const onAbort = () => {
        log55.error("connection aborted %s:%s", cOpts.host, cOpts.port);
        channel.close().finally(() => {
          done(new AbortError5());
        });
      };
      const done = (err2) => {
        channel.removeEventListener("ready", onReady);
        options.signal?.removeEventListener("abort", onAbort);
        if (err2 == null) {
          resolve7(channel);
        } else {
          reject(err2);
        }
      };
      channel.addEventListener("ready", onReady, {
        once: true
      });
      channel.addEventListener("close", () => {
        channel.removeEventListener("error", onError);
      });
      options.signal?.addEventListener("abort", onAbort);
      channel.addEventListener("signal", (evt) => {
        const signal = evt.detail;
        sio.socket.emit("ss-handshake", {
          intentId,
          srcMultiaddr: sio.signallingAddr.toString(),
          dstMultiaddr: ma.toString(),
          signal
        });
      });
      sio.socket.on("ws-handshake", (offer) => {
        if (offer.intentId === intentId && offer.err != null) {
          channel.close().finally(() => {
            reject((0, import_err_code84.default)(new Error(offer.err), "ERR_SIGNALLING_FAILED"));
          });
        }
        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {
          return;
        }
        channel.handleSignal(offer.signal);
      });
    });
  }
  createListener(options) {
    if (!webrtcSupport && this.wrtc == null) {
      throw (0, import_err_code84.default)(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
    }
    options.channelOptions = options.channelOptions ?? {};
    if (this.wrtc != null) {
      options.channelOptions.wrtc = this.wrtc;
    }
    return createListener(options.upgrader, options.handler ?? noop3, this.components.getPeerId(), this, options);
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      return WebRTCStar.matches(ma);
    });
  }
  peerDiscovered(maStr) {
    log55("peer discovered: %s", maStr);
    maStr = cleanMultiaddr(maStr);
    const ma = multiaddr(maStr);
    const peerIdStr = ma.getPeerId();
    if (peerIdStr == null) {
      return;
    }
    const peerId = peerIdFromString(peerIdStr);
    this.discovery.dispatchEvent(new CustomEvent("peer", {
      detail: {
        id: peerId,
        multiaddrs: [ma],
        protocols: []
      }
    }));
  }
};

// node_modules/ipfs-core-config/src/libp2p.browser.js
function libp2pConfig() {
  const webRtcStar = new WebRTCStar2();
  const options = {
    transports: [
      webRtcStar
    ],
    peerDiscovery: [
      webRtcStar.discovery
    ],
    connectionManager: {
      maxParallelDials: 150,
      maxDialsPerPeer: 4,
      dialTimeout: 1e4,
      autoDial: true
    },
    nat: {
      enabled: false
    },
    metrics: {
      enabled: true
    }
  };
  return options;
}

// node_modules/libp2p/dist/src/peer-routing.js
var import_err_code86 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/errors.js
var messages2;
(function(messages3) {
  messages3["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages3["DHT_DISABLED"] = "DHT is not available";
  messages3["PUBSUB_DISABLED"] = "PubSub is not available";
  messages3["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages3["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages3["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages3["NOT_FOUND"] = "Not found";
})(messages2 || (messages2 = {}));
var codes4;
(function(codes6) {
  codes6["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes6["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes6["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes6["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes6["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes6["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes6["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes6["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes6["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes6["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes6["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes6["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes6["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes6["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes6["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes6["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes6["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes6["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes6["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes6["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes6["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes6["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes6["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes6["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes6["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes6["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes6["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes6["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes6["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes6["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes6["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes6["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes6["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes6["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes6["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes6["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes6["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes6["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes6["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes6["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes6["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes6["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes6["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes6["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes6["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes6["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes6["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes6["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes6["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes6["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes6["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes6["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes6["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes6["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes6["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes6["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes6["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes6["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes6["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes6["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes6["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes6["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes6["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes6["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes6["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
})(codes4 || (codes4 = {}));

// node_modules/libp2p/dist/src/content-routing/utils.js
var import_err_code85 = __toESM(require_err_code(), 1);
var import_it_filter8 = __toESM(require_it_filter(), 1);
var import_it_map12 = __toESM(require_it_map(), 1);
async function* storeAddresses(source, peerStore) {
  yield* (0, import_it_map12.default)(source, async (peer) => {
    await peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return (0, import_it_filter8.default)(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw (0, import_err_code85.default)(new Error("not found"), "NOT_FOUND");
  }
}

// node_modules/libp2p/dist/src/peer-routing.js
var import_timeout_abort_controller4 = __toESM(require_timeout_abort_controller(), 1);
var import_it_merge4 = __toESM(require_it_merge(), 1);
var import_it_first4 = __toESM(require_it_first(), 1);
var import_it_drain10 = __toESM(require_it_drain(), 1);
var import_it_filter9 = __toESM(require_it_filter(), 1);
var import_set_delayed_interval = __toESM(require_src4(), 1);
var import_events8 = __toESM(require_events(), 1);
var log56 = logger("libp2p:peer-routing");
var DefaultPeerRouting = class {
  constructor(components, init) {
    this.components = components;
    this.routers = init.routers;
    this.refreshManagerInit = init.refreshManager ?? {};
    this.started = false;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {
      return;
    }
    this.timeoutId = (0, import_set_delayed_interval.setDelayedInterval)(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);
    this.started = true;
  }
  async _findClosestPeersTask() {
    if (this.abortController != null) {
      return;
    }
    try {
      this.abortController = new import_timeout_abort_controller4.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
      try {
        (0, import_events8.setMaxListeners)?.(Infinity, this.abortController.signal);
      } catch {
      }
      await (0, import_it_drain10.default)(this.getClosestPeers(this.components.getPeerId().toBytes(), { signal: this.abortController.signal }));
    } catch (err2) {
      log56.error(err2);
    } finally {
      this.abortController?.clear();
      this.abortController = void 0;
    }
  }
  async stop() {
    (0, import_set_delayed_interval.clearDelayedInterval)(this.timeoutId);
    this.abortController?.abort();
    this.started = false;
  }
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code86.default)(new Error("No peer routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.getPeerId().toString()) {
      throw (0, import_err_code86.default)(new Error("Should not try to find self"), codes4.ERR_FIND_SELF);
    }
    const output = await pipe((0, import_it_merge4.default)(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err2) {
        log56.error(err2);
      }
    }())), (source) => (0, import_it_filter9.default)(source, Boolean), (source) => storeAddresses(source, this.components.getPeerStore()), async (source) => await (0, import_it_first4.default)(source));
    if (output != null) {
      return output;
    }
    throw (0, import_err_code86.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code86.default)(new Error("No peer routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe((0, import_it_merge4.default)(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.getPeerStore()), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};

// node_modules/libp2p/dist/src/content-routing/index.js
var import_err_code87 = __toESM(require_err_code(), 1);
var import_it_drain11 = __toESM(require_it_drain(), 1);
var import_it_merge5 = __toESM(require_it_merge(), 1);
var CompoundContentRouting = class {
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code87.default)(new Error("No content this.routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe((0, import_it_merge5.default)(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.getPeerStore()), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code87.default)(new Error("No content routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
  }
  async put(key, value2, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code87.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    const dht = this.components.getDHT();
    if (dht != null) {
      await (0, import_it_drain11.default)(dht.put(key, value2, options));
    }
  }
  async get(key, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code87.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    const dht = this.components.getDHT();
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
    }
    throw (0, import_err_code87.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  async *getMany(key, nVals, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code87.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    if (nVals == null || nVals === 0) {
      return;
    }
    let gotValues = 0;
    const dht = this.components.getDHT();
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          yield { from: event.from, val: event.value };
          gotValues++;
          if (gotValues === nVals) {
            break;
          }
        }
      }
    }
    if (gotValues === 0) {
      throw (0, import_err_code87.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
    }
  }
};

// node_modules/libp2p/dist/src/get-peer.js
var import_err_code88 = __toESM(require_err_code(), 1);
function peerIdFromMultiaddr(ma) {
  const idStr = ma.getPeerId();
  if (idStr == null) {
    throw (0, import_err_code88.default)(new Error(`${ma.toString()} does not have a valid peer type`), codes4.ERR_INVALID_MULTIADDR);
  }
  try {
    return peerIdFromString(idStr);
  } catch (err2) {
    throw (0, import_err_code88.default)(new Error(`${ma.toString()} is not a valid peer type`), codes4.ERR_INVALID_MULTIADDR);
  }
}
function getPeer(peer) {
  if (isPeerId(peer)) {
    return {
      id: peer,
      multiaddrs: [],
      protocols: []
    };
  }
  if (typeof peer === "string") {
    peer = multiaddr(peer);
  }
  let addr;
  if (isMultiaddr(peer)) {
    addr = peer;
    peer = peerIdFromMultiaddr(peer);
  }
  return {
    id: peer,
    multiaddrs: addr != null ? [addr] : [],
    protocols: []
  };
}

// node_modules/libp2p/dist/src/address-manager/index.js
var defaultAddressFilter = (addrs) => addrs;
var DefaultAddressManager = class extends EventEmitter2 {
  constructor(components, init) {
    super();
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = new Set(listen.map((ma) => ma.toString()));
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Set();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
  }
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  getObservedAddrs() {
    return Array.from(this.observed).map((a) => multiaddr(a));
  }
  addObservedAddr(addr) {
    let ma = multiaddr(addr);
    const remotePeer = ma.getPeerId();
    if (remotePeer != null) {
      const remotePeerId = peerIdFromString(remotePeer);
      if (remotePeerId.equals(this.components.getPeerId())) {
        ma = ma.decapsulate(multiaddr(`/p2p/${this.components.getPeerId().toString()}`));
      }
    }
    const addrString = ma.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.add(addrString);
    this.dispatchEvent(new CustomEvent("change:addresses"));
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.getTransportManager().getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(this.getObservedAddrs().map((ma) => ma.toString()));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.getPeerId().toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.getPeerId().toString()}`);
    });
  }
};

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_err_code89 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/connection-manager/visibility-change-emitter.js
var log57 = logger("libp2p:connection-manager:latency-monitor:visibility-change-emitter");
var VisibilityChangeEmitter = class extends EventEmitter2 {
  constructor() {
    super();
    this.hidden = "hidden";
    this.visibilityChange = "visibilityChange";
    if (globalThis.document != null) {
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
  }
  _initializeVisibilityVarNames() {
    let hidden2 = "hidden";
    let visibilityChange = "visibilitychange";
    if (typeof globalThis.document.hidden !== "undefined") {
      hidden2 = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof globalThis.document.mozHidden !== "undefined") {
      hidden2 = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof globalThis.document.msHidden !== "undefined") {
      hidden2 = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof globalThis.document.webkitHidden !== "undefined") {
      hidden2 = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    this.hidden = hidden2;
    this.visibilityChange = visibilityChange;
  }
  _addVisibilityChangeListener() {
    if (typeof globalThis.document.addEventListener === "undefined" || typeof document[this.hidden] === "undefined") {
      log57("Checking page visibility requires a browser that supports the Page Visibility API.");
    } else {
      globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
    }
  }
  isVisible() {
    if (this.hidden === void 0 || document[this.hidden] === void 0) {
      return void 0;
    }
    return document[this.hidden] == null;
  }
  _handleVisibilityChange() {
    const visible = globalThis.document[this.hidden] === false;
    log57(visible ? "Page Visible" : "Page Hidden");
    this.dispatchEvent(new CustomEvent("visibilityChange", {
      detail: visible
    }));
  }
};

// node_modules/libp2p/dist/src/connection-manager/latency-monitor.js
var log58 = logger("libp2p:connection-manager:latency-monitor");
var LatencyMonitor = class extends EventEmitter2 {
  constructor(init = {}) {
    super();
    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init;
    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500;
    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;
    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs;
    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;
    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs ?? 5 * 1e3;
    log58("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs);
    if (this.dataEmitIntervalMs != null) {
      log58("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs);
    } else {
      log58("Not emitting summaries");
    }
    this.asyncTestFn = asyncTestFn;
    if (globalThis.process?.hrtime != null) {
      log58("Using process.hrtime for timing");
      this.now = globalThis.process.hrtime;
      this.getDeltaMS = (startTime) => {
        const hrtime = this.now(startTime);
        return hrtime[0] * 1e3 + hrtime[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance?.now != null) {
      log58("Using performance.now for timing");
      this.now = window.performance.now.bind(window.performance);
      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
    } else {
      log58("Using Date.now for timing");
      this.now = Date.now;
      this.getDeltaMS = (startTime) => this.now() - startTime;
    }
    this.latencyData = this.initLatencyData();
  }
  start() {
    if (isBrowser2()) {
      this.visibilityChangeEmitter = new VisibilityChangeEmitter();
      this.visibilityChangeEmitter.addEventListener("visibilityChange", (evt) => {
        const { detail: pageInFocus } = evt;
        if (pageInFocus) {
          this._startTimers();
        } else {
          this._emitSummary();
          this._stopTimers();
        }
      });
    }
    if (this.visibilityChangeEmitter?.isVisible() === true) {
      this._startTimers();
    }
  }
  stop() {
    this._stopTimers();
  }
  _startTimers() {
    if (this.checkLatencyID != null) {
      return;
    }
    this.checkLatency();
    if (this.dataEmitIntervalMs != null) {
      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
      if (typeof this.emitIntervalID.unref === "function") {
        this.emitIntervalID.unref();
      }
    }
  }
  _stopTimers() {
    if (this.checkLatencyID != null) {
      clearTimeout(this.checkLatencyID);
      this.checkLatencyID = void 0;
    }
    if (this.emitIntervalID != null) {
      clearInterval(this.emitIntervalID);
      this.emitIntervalID = void 0;
    }
  }
  _emitSummary() {
    const summary = this.getSummary();
    if (summary.events > 0) {
      this.dispatchEvent(new CustomEvent("data", {
        detail: summary
      }));
    }
  }
  getSummary() {
    const latency = {
      events: this.latencyData.events,
      minMs: this.latencyData.minMs,
      maxMs: this.latencyData.maxMs,
      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,
      lengthMs: this.getDeltaMS(this.latencyData.startTime)
    };
    this.latencyData = this.initLatencyData();
    log58.trace("Summary: %O", latency);
    return latency;
  }
  checkLatency() {
    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;
    const localData = {
      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),
      startTime: this.now()
    };
    const cb = () => {
      if (this.checkLatencyID == null) {
        return;
      }
      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;
      this.checkLatency();
      this.latencyData.events++;
      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);
      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);
      this.latencyData.totalMs += deltaMS;
      log58.trace("MS: %s Data: %O", deltaMS, this.latencyData);
    };
    log58.trace("localData: %O", localData);
    this.checkLatencyID = setTimeout(() => {
      if (this.asyncTestFn != null) {
        localData.deltaOffset = 0;
        localData.startTime = this.now();
        this.asyncTestFn(cb);
      } else {
        localData.deltaOffset -= 1;
        cb();
      }
    }, localData.deltaOffset);
    if (typeof this.checkLatencyID.unref === "function") {
      this.checkLatencyID.unref();
    }
  }
  initLatencyData() {
    return {
      startTime: this.now(),
      minMs: Number.POSITIVE_INFINITY,
      maxMs: Number.NEGATIVE_INFINITY,
      events: 0,
      totalMs: 0
    };
  }
};
function isBrowser2() {
  return typeof globalThis.window !== "undefined";
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_retimer = __toESM(require_retimer(), 1);
var import_events13 = __toESM(require_events(), 1);

// node_modules/@libp2p/interface-connection/dist/src/status.js
var OPEN = "OPEN";
var CLOSING = "CLOSING";
var CLOSED = "CLOSED";

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map19) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map19(val)
      };
    }
  };
  return iterator;
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map19) {
    this.map = /* @__PURE__ */ new Map();
    if (map19 != null) {
      for (const [key, value2] of map19.entries()) {
        this.map.set(key.toString(), value2);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value2, key) => {
      fn(value2, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value2) {
    this.map.set(peer.toString(), value2);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class {
  constructor(set2) {
    this.set = /* @__PURE__ */ new Set();
    if (set2 != null) {
      for (const key of set2) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/list.js
var PeerList = class {
  constructor(list) {
    this.list = [];
    if (list != null) {
      for (const value2 of list) {
        this.list.push(value2.toString());
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return peerIdFromString(val[1]);
    });
  }
  concat(list) {
    const output = new PeerList(this);
    for (const value2 of list) {
      output.push(value2);
    }
    return output;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], peerIdFromString(val[1])];
    });
  }
  every(predicate) {
    return this.list.every((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  filter(predicate) {
    const output = new PeerList();
    this.list.forEach((str, index) => {
      const peerId = peerIdFromString(str);
      if (predicate(peerId, index, this)) {
        output.push(peerId);
      }
    });
    return output;
  }
  find(predicate) {
    const str = this.list.find((str2, index) => {
      return predicate(peerIdFromString(str2), index, this);
    });
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  findIndex(predicate) {
    return this.list.findIndex((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((str, index) => {
      predicate(peerIdFromString(str), index, this);
    });
  }
  includes(peerId) {
    return this.list.includes(peerId.toString());
  }
  indexOf(peerId) {
    return this.list.indexOf(peerId.toString());
  }
  pop() {
    const str = this.list.pop();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  push(...peerIds) {
    for (const peerId of peerIds) {
      this.list.push(peerId.toString());
    }
  }
  shift() {
    const str = this.list.shift();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i2 = peerIds.length - 1; i2 > -1; i2--) {
      len = this.list.unshift(peerIds[i2].toString());
    }
    return len;
  }
  get length() {
    return this.list.length;
  }
};

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_timeout_abort_controller5 = __toESM(require_timeout_abort_controller(), 1);

// node_modules/@libp2p/interface-peer-store/dist/src/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/libp2p/dist/src/connection-manager/index.js
var log59 = logger("libp2p:connection-manager");
var defaultOptions16 = {
  maxConnections: Infinity,
  minConnections: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2e3,
  autoDialInterval: 1e4,
  movingAverageInterval: 6e4
};
var METRICS_SYSTEM = "libp2p";
var METRICS_COMPONENT = "connection-manager";
var STARTUP_RECONNECT_TIMEOUT = 6e4;
var DefaultConnectionManager = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.components = new Components();
    this.opts = merge_options_default.call({ ignoreUndefined: true }, defaultOptions16, init);
    if (this.opts.maxConnections < this.opts.minConnections) {
      throw (0, import_err_code89.default)(new Error("Connection Manager maxConnections must be greater than minConnections"), codes4.ERR_INVALID_PARAMETERS);
    }
    log59("options: %o", this.opts);
    this.connections = /* @__PURE__ */ new Map();
    this.started = false;
    this._checkMetrics = this._checkMetrics.bind(this);
    this.latencyMonitor = new LatencyMonitor({
      latencyCheckIntervalMs: init.pollInterval,
      dataEmitIntervalMs: init.pollInterval
    });
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, this);
    } catch {
    }
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;
    this.dialTimeout = init.dialTimeout ?? 3e4;
  }
  init(components) {
    this.components = components;
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "connections",
      label: "direction",
      value: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-total",
      label: "protocol",
      value: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-per-connection-90th-percentile",
      label: "protocol",
      value: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol4, count] of Object.entries(streams)) {
              allStreams[protocol4] = allStreams[protocol4] ?? [];
              allStreams[protocol4].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol4, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol4] = counts[index];
        }
        return metric;
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.components.getMetrics() != null) {
      this.timer = this.timer ?? (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
    }
    this.latencyMonitor.start();
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
    this.latencyMonitor.addEventListener("data", this._onLatencyMeasure);
    this.started = true;
    log59("started");
  }
  async afterStart() {
    this.components.getUpgrader().addEventListener("connection", this.onConnect);
    this.components.getUpgrader().addEventListener("connectionEnd", this.onDisconnect);
    void Promise.resolve().then(async () => {
      const keepAlivePeers = [];
      for (const peer of await this.components.getPeerStore().all()) {
        const tags = await this.components.getPeerStore().getTags(peer.id);
        const hasKeepAlive = tags.filter((tag) => tag.name === KEEP_ALIVE).length > 0;
        if (hasKeepAlive) {
          keepAlivePeers.push(peer.id);
        }
      }
      this.connectOnStartupController?.clear();
      this.connectOnStartupController = new import_timeout_abort_controller5.TimeoutController(this.startupReconnectTimeout);
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, this.connectOnStartupController.signal);
      } catch {
      }
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer, {
          signal: this.connectOnStartupController?.signal
        }).catch((err2) => {
          log59.error(err2);
        });
      }));
    }).catch((err2) => {
      log59.error(err2);
    }).finally(() => {
      this.connectOnStartupController?.clear();
    });
  }
  async beforeStop() {
    this.connectOnStartupController?.abort();
    this.components.getUpgrader().removeEventListener("connection", this.onConnect);
    this.components.getUpgrader().removeEventListener("connectionEnd", this.onDisconnect);
  }
  async stop() {
    this.timer?.clear();
    this.latencyMonitor.removeEventListener("data", this._onLatencyMeasure);
    this.latencyMonitor.stop();
    this.started = false;
    await this._close();
    log59("stopped");
  }
  async _close() {
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err2) {
            log59.error(err2);
          }
        })());
      }
    }
    log59("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
  }
  async _checkMetrics() {
    const metrics = this.components.getMetrics();
    if (metrics != null) {
      try {
        const movingAverages = metrics.getGlobal().getMovingAverages();
        const received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxReceivedData", received);
        const sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxSentData", sent);
        const total = received + sent;
        await this._checkMaxLimit("maxData", total);
        log59.trace("metrics update", total);
      } finally {
        this.timer = (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
      }
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err2) => {
      log59.error(err2);
    });
  }
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const peerIdStr = peerId.toString();
    const storedConns = this.connections.get(peerIdStr);
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      this.connections.set(peerIdStr, [connection]);
    }
    if (peerId.publicKey != null) {
      await this.components.getPeerStore().keyBook.set(peerId, peerId.publicKey);
    }
    const numConnections = this.getConnections().length;
    const toPrune = numConnections - this.opts.maxConnections;
    await this._checkMaxLimit("maxConnections", numConnections, toPrune);
    this.dispatchEvent(new CustomEvent("peer:connect", { detail: connection }));
  }
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer.toString();
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.dispatchEvent(new CustomEvent("peer:disconnect", { detail: connection }));
      this.components.getMetrics()?.onPeerDisconnected(connection.remotePeer);
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId.toString()) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  async openConnection(peerId, options = {}) {
    log59("dial to %p", peerId);
    const existingConnections = this.getConnections(peerId);
    if (existingConnections.length > 0) {
      log59("had an existing connection to %p", peerId);
      return existingConnections[0];
    }
    let timeoutController;
    if (options?.signal == null) {
      timeoutController = new import_timeout_abort_controller5.TimeoutController(this.dialTimeout);
      options.signal = timeoutController.signal;
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      const connection = await this.components.getDialer().dial(peerId, options);
      let peerConnections = this.connections.get(peerId.toString());
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(peerId.toString(), peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
    }
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId.toString()) ?? [];
    await Promise.all(connections.map(async (connection) => {
      return await connection.close();
    }));
  }
  getAll(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code89.default)(new Error("peerId must be an instance of peer-id"), codes4.ERR_INVALID_PARAMETERS);
    }
    const id = peerId.toString();
    const connections = this.connections.get(id);
    if (connections != null) {
      return connections.filter((connection) => connection.stat.status === OPEN);
    }
    return [];
  }
  _onLatencyMeasure(evt) {
    const { detail: summary } = evt;
    this._checkMaxLimit("maxEventLoopDelay", summary.avgMs, 1).catch((err2) => {
      log59.error(err2);
    });
  }
  async _checkMaxLimit(name22, value2, toPrune = 1) {
    const limit = this.opts[name22];
    log59.trace("checking limit of %s. current value: %d of %d", name22, value2, limit);
    if (value2 > limit) {
      log59("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)", this.components.getPeerId(), name22, value2, limit, toPrune);
      await this._maybePruneConnections(toPrune);
    }
  }
  async _maybePruneConnections(toPrune) {
    const connections = this.getConnections();
    if (connections.length <= this.opts.minConnections || toPrune < 1) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      const tags = await this.components.getPeerStore().getTags(remotePeer);
      peerValues.set(remotePeer, tags.reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log59("too many connections open - closing a connection to %p", connection.remotePeer);
      toClose.push(connection);
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err2) {
        log59.error(err2);
      }
      this.onDisconnect(new CustomEvent("connectionEnd", {
        detail: connection
      }));
    }));
  }
  async acceptIncomingConnection(maConn) {
    return true;
  }
};

// node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
var import_retimer2 = __toESM(require_retimer(), 1);
var import_it_all7 = __toESM(require_it_all(), 1);
var import_it_filter10 = __toESM(require_it_filter(), 1);
var import_it_sort2 = __toESM(require_it_sort(), 1);
var log60 = logger("libp2p:connection-manager:auto-dialler");
var defaultOptions17 = {
  enabled: true,
  minConnections: 0,
  autoDialInterval: 1e4
};
var AutoDialler = class {
  constructor(components, init) {
    this.components = components;
    this.options = merge_options_default.call({ ignoreUndefined: true }, defaultOptions17, init);
    this.running = false;
    this._autoDial = this._autoDial.bind(this);
    log60("options: %j", this.options);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.options.enabled) {
      log60("not enabled");
      return;
    }
    this.running = true;
    void this._autoDial().catch((err2) => {
      log60.error("could start autodial", err2);
    });
    log60("started");
  }
  async stop() {
    if (!this.options.enabled) {
      log60("not enabled");
      return;
    }
    this.running = false;
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    log60("stopped");
  }
  async _autoDial() {
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    const minConnections = this.options.minConnections;
    if (this.components.getConnectionManager().getConnections().length >= minConnections) {
      this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
      return;
    }
    const allPeers = await this.components.getPeerStore().all();
    const peers = await pipe(
      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),
      (source) => (0, import_it_filter10.default)(source, (peer) => !peer.id.equals(this.components.getPeerId())),
      (source) => (0, import_it_sort2.default)(source, (a, b) => {
        if (b.protocols.length > a.protocols.length) {
          return 1;
        } else if (b.id.publicKey != null && a.id.publicKey == null) {
          return 1;
        }
        return -1;
      }),
      async (source) => await (0, import_it_all7.default)(source)
    );
    for (let i2 = 0; this.running && i2 < peers.length && this.components.getConnectionManager().getConnections().length < minConnections; i2++) {
      if (!this.running) {
        return;
      }
      const peer = peers[i2];
      if (this.components.getConnectionManager().getConnections(peer.id).length === 0) {
        log60("connecting to a peerStore stored peer %p", peer.id);
        try {
          await this.components.getConnectionManager().openConnection(peer.id);
        } catch (err2) {
          log60.error("could not connect to peerStore stored peer", err2);
        }
      }
    }
    if (!this.running) {
      return;
    }
    this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
  }
};

// node_modules/libp2p/dist/src/circuit/transport.js
var import_err_code91 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/circuit/pb/index.js
var CircuitRelay;
(function(CircuitRelay2) {
  let Status;
  (function(Status2) {
    Status2["SUCCESS"] = "SUCCESS";
    Status2["HOP_SRC_ADDR_TOO_LONG"] = "HOP_SRC_ADDR_TOO_LONG";
    Status2["HOP_DST_ADDR_TOO_LONG"] = "HOP_DST_ADDR_TOO_LONG";
    Status2["HOP_SRC_MULTIADDR_INVALID"] = "HOP_SRC_MULTIADDR_INVALID";
    Status2["HOP_DST_MULTIADDR_INVALID"] = "HOP_DST_MULTIADDR_INVALID";
    Status2["HOP_NO_CONN_TO_DST"] = "HOP_NO_CONN_TO_DST";
    Status2["HOP_CANT_DIAL_DST"] = "HOP_CANT_DIAL_DST";
    Status2["HOP_CANT_OPEN_DST_STREAM"] = "HOP_CANT_OPEN_DST_STREAM";
    Status2["HOP_CANT_SPEAK_RELAY"] = "HOP_CANT_SPEAK_RELAY";
    Status2["HOP_CANT_RELAY_TO_SELF"] = "HOP_CANT_RELAY_TO_SELF";
    Status2["STOP_SRC_ADDR_TOO_LONG"] = "STOP_SRC_ADDR_TOO_LONG";
    Status2["STOP_DST_ADDR_TOO_LONG"] = "STOP_DST_ADDR_TOO_LONG";
    Status2["STOP_SRC_MULTIADDR_INVALID"] = "STOP_SRC_MULTIADDR_INVALID";
    Status2["STOP_DST_MULTIADDR_INVALID"] = "STOP_DST_MULTIADDR_INVALID";
    Status2["STOP_RELAY_REFUSED"] = "STOP_RELAY_REFUSED";
    Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["SUCCESS"] = 100] = "SUCCESS";
    __StatusValues2[__StatusValues2["HOP_SRC_ADDR_TOO_LONG"] = 220] = "HOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_DST_ADDR_TOO_LONG"] = 221] = "HOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_SRC_MULTIADDR_INVALID"] = 250] = "HOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_DST_MULTIADDR_INVALID"] = 251] = "HOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_NO_CONN_TO_DST"] = 260] = "HOP_NO_CONN_TO_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_DIAL_DST"] = 261] = "HOP_CANT_DIAL_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_OPEN_DST_STREAM"] = 262] = "HOP_CANT_OPEN_DST_STREAM";
    __StatusValues2[__StatusValues2["HOP_CANT_SPEAK_RELAY"] = 270] = "HOP_CANT_SPEAK_RELAY";
    __StatusValues2[__StatusValues2["HOP_CANT_RELAY_TO_SELF"] = 280] = "HOP_CANT_RELAY_TO_SELF";
    __StatusValues2[__StatusValues2["STOP_SRC_ADDR_TOO_LONG"] = 320] = "STOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_DST_ADDR_TOO_LONG"] = 321] = "STOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_SRC_MULTIADDR_INVALID"] = 350] = "STOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_DST_MULTIADDR_INVALID"] = 351] = "STOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_RELAY_REFUSED"] = 390] = "STOP_RELAY_REFUSED";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status2) {
    Status2.codec = () => {
      return enumeration2(__StatusValues);
    };
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let Type2;
  (function(Type3) {
    Type3["HOP"] = "HOP";
    Type3["STOP"] = "STOP";
    Type3["STATUS"] = "STATUS";
    Type3["CAN_HOP"] = "CAN_HOP";
  })(Type2 = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["HOP"] = 1] = "HOP";
    __TypeValues2[__TypeValues2["STOP"] = 2] = "STOP";
    __TypeValues2[__TypeValues2["STATUS"] = 3] = "STATUS";
    __TypeValues2[__TypeValues2["CAN_HOP"] = 4] = "CAN_HOP";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration2(__TypeValues);
    };
  })(Type2 = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let Peer3;
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message2((obj, writer5, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer5.fork();
          }
          if (obj.id != null) {
            writer5.uint32(10);
            writer5.bytes(obj.id);
          } else {
            throw new Error('Protocol error: required field "id" was not found in object');
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              writer5.uint32(18);
              writer5.bytes(value2);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (opts.lengthDelimited !== false) {
            writer5.ldelim();
          }
        }, (reader6, length23) => {
          const obj = {};
          const end = length23 == null ? reader6.len : reader6.pos + length23;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader6.bytes();
                break;
              case 2:
                obj.addrs = obj.addrs ?? [];
                obj.addrs.push(reader6.bytes());
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          obj.addrs = obj.addrs ?? [];
          if (obj.id == null) {
            throw new Error('Protocol error: value for required field "id" was not found in protobuf');
          }
          if (obj.addrs == null) {
            throw new Error('Protocol error: value for required field "addrs" was not found in protobuf');
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage2(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage2(buf2, Peer4.codec());
    };
  })(Peer3 = CircuitRelay2.Peer || (CircuitRelay2.Peer = {}));
  let _codec;
  CircuitRelay2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.type != null) {
          writer5.uint32(8);
          CircuitRelay2.Type.codec().encode(obj.type, writer5);
        }
        if (obj.srcPeer != null) {
          writer5.uint32(18);
          CircuitRelay2.Peer.codec().encode(obj.srcPeer, writer5);
        }
        if (obj.dstPeer != null) {
          writer5.uint32(26);
          CircuitRelay2.Peer.codec().encode(obj.dstPeer, writer5);
        }
        if (obj.code != null) {
          writer5.uint32(32);
          CircuitRelay2.Status.codec().encode(obj.code, writer5);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = CircuitRelay2.Type.codec().decode(reader6);
              break;
            case 2:
              obj.srcPeer = CircuitRelay2.Peer.codec().decode(reader6, reader6.uint32());
              break;
            case 3:
              obj.dstPeer = CircuitRelay2.Peer.codec().decode(reader6, reader6.uint32());
              break;
            case 4:
              obj.code = CircuitRelay2.Status.codec().decode(reader6);
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  CircuitRelay2.encode = (obj) => {
    return encodeMessage2(obj, CircuitRelay2.codec());
  };
  CircuitRelay2.decode = (buf2) => {
    return decodeMessage2(buf2, CircuitRelay2.codec());
  };
})(CircuitRelay || (CircuitRelay = {}));

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
var log61 = logger("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream, remoteAddr } = props;
  const { sink, source } = stream;
  const mapSource = async function* () {
    for await (const list of source) {
      yield* list;
    }
  }();
  const maConn = {
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
        await close();
      } catch (err2) {
        if (err2.type !== "aborted") {
          log61(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    return await Promise.resolve();
  }
  return maConn;
}

// node_modules/libp2p/dist/src/circuit/multicodec.js
var RELAY_CODEC = "/libp2p/circuit/relay/0.1.0";

// node_modules/libp2p/dist/src/circuit/listener.js
function createListener2(options) {
  const listeningAddrs = /* @__PURE__ */ new Map();
  async function listen(addr) {
    const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
    const ma = multiaddr(addrString);
    const relayPeerStr = ma.getPeerId();
    if (relayPeerStr == null) {
      throw new Error("Could not determine relay peer from multiaddr");
    }
    const relayPeerId = peerIdFromString(relayPeerStr);
    await options.peerStore.addressBook.add(relayPeerId, [ma]);
    const relayConn = await options.connectionManager.openConnection(relayPeerId);
    const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);
    listener.dispatchEvent(new CustomEvent("listening"));
  }
  function getAddrs() {
    const addrs = [];
    for (const addr of listeningAddrs.values()) {
      addrs.push(addr);
    }
    return addrs;
  }
  const listener = Object.assign(new EventEmitter2(), {
    close: async () => await Promise.resolve(),
    listen,
    getAddrs
  });
  options.connectionManager.addEventListener("peer:disconnect", (evt) => {
    const { detail: connection } = evt;
    const deleted = listeningAddrs.delete(connection.remotePeer.toString());
    if (deleted) {
      listener.dispatchEvent(new CustomEvent("close"));
    }
  });
  return listener;
}

// node_modules/libp2p/dist/src/circuit/circuit/hop.js
var import_err_code90 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/circuit/circuit/utils.js
function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer?.addrs != null) {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err2;
  }
  try {
    if (msg.srcPeer?.addrs != null) {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err2;
  }
}

// node_modules/it-handshake/dist/src/index.js
function handshake(stream) {
  const writer5 = pushable();
  const source = reader3(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer5;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err2) => {
    sinkErr = err2;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        return await Promise.reject(sinkErr);
      }
      sourcePromise.resolve(source2);
      return await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer: writer5,
    stream: rest,
    rest: () => writer5.end(),
    write: writer5.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}

// node_modules/libp2p/dist/src/circuit/circuit/stream-handler.js
var log62 = logger("libp2p:circuit:stream-handler");
var StreamHandler = class {
  constructor(options) {
    const { stream, maxLength = 4096 } = options;
    this.stream = stream;
    this.shake = handshake(this.stream);
    this.decoder = decode62.fromReader(this.shake.reader, { maxDataLength: maxLength });
  }
  async read() {
    const msg = await this.decoder.next();
    if (msg.value != null) {
      const value2 = CircuitRelay.decode(msg.value);
      log62("read message type", value2.type);
      return value2;
    }
    log62("read received no value, closing stream");
    this.close();
  }
  write(msg) {
    log62("write message type %s", msg.type);
    this.shake.write(encode52.single(CircuitRelay.encode(msg)));
  }
  rest() {
    this.shake.rest();
    return this.shake.stream;
  }
  end(msg) {
    this.write(msg);
    this.close();
  }
  close() {
    log62("closing the stream");
    void this.rest().sink([]).catch((err2) => {
      log62.error(err2);
    });
  }
};

// node_modules/libp2p/dist/src/circuit/circuit/stop.js
var log63 = logger("libp2p:circuit:stop");
function handleStop(options) {
  const { connection, request: request2, streamHandler } = options;
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log63.error("invalid stop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  log63("stop request is valid");
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  return streamHandler.rest();
}
async function stop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  log63("starting stop request to %p", connection.remotePeer);
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    streamHandler.close();
    return;
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log63("stop request to %p was successful", connection.remotePeer);
    return streamHandler.rest();
  }
  log63("stop request failed with code %d", response.code);
  streamHandler.close();
}

// node_modules/libp2p/dist/src/circuit/circuit/hop.js
var log64 = logger("libp2p:circuit:hop");
async function handleHop(hopRequest) {
  const { connection, request: request2, streamHandler, circuit, connectionManager } = hopRequest;
  if (!circuit.hopEnabled()) {
    log64("HOP request received but we are not acting as a relay");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log64.error("invalid hop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  if (request2.dstPeer == null) {
    log64("HOP request received but we do not receive a dstPeer");
    return;
  }
  const destinationPeer = peerIdFromBytes(request2.dstPeer.id);
  const destinationConnections = connectionManager.getConnections(destinationPeer);
  if (destinationConnections.length === 0 && !circuit.hopActive()) {
    log64("HOP request received but we are not connected to the destination peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  if (destinationConnections.length === 0) {
    log64("did not have connection to remote peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  const stopRequest = {
    type: CircuitRelay.Type.STOP,
    dstPeer: request2.dstPeer,
    srcPeer: request2.srcPeer
  };
  let destinationStream;
  try {
    log64("performing STOP request");
    const result = await stop({
      connection: destinationConnections[0],
      request: stopRequest
    });
    if (result == null) {
      throw new Error("Could not stop");
    }
    destinationStream = result;
  } catch (err2) {
    log64.error(err2);
    return;
  }
  log64("hop request from %p is valid", connection.remotePeer);
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  const sourceStream = streamHandler.rest();
  log64("creating related connections");
  return await pipe(sourceStream, destinationStream, sourceStream);
}
async function hop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    throw (0, import_err_code90.default)(new Error("HOP request had no response"), codes4.ERR_HOP_REQUEST_FAILED);
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log64("hop request was successful");
    return streamHandler.rest();
  }
  log64("hop request failed with code %d, closing stream", response.code);
  streamHandler.close();
  throw (0, import_err_code90.default)(new Error(`HOP request failed with code "${response.code ?? "unknown"}"`), codes4.ERR_HOP_REQUEST_FAILED);
}
async function canHop(options) {
  const { connection, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write({
    type: CircuitRelay.Type.CAN_HOP
  });
  const response = await streamHandler.read();
  await streamHandler.close();
  if (response == null || response.code !== CircuitRelay.Status.SUCCESS) {
    return false;
  }
  return true;
}
function handleCanHop(options) {
  const { connection, streamHandler, circuit } = options;
  const canHop2 = circuit.hopEnabled();
  log64("can hop (%s) request from %p", canHop2, connection.remotePeer);
  streamHandler.end({
    type: CircuitRelay.Type.STATUS,
    code: canHop2 ? CircuitRelay.Status.SUCCESS : CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
  });
}

// node_modules/libp2p/dist/src/circuit/transport.js
var import_timeout_abort_controller6 = __toESM(require_timeout_abort_controller(), 1);
var import_events15 = __toESM(require_events(), 1);
var log65 = logger("libp2p:circuit");
var Circuit2 = class {
  constructor(init) {
    this.components = new Components();
    this._init = init;
  }
  init(components) {
    this.components = components;
    void this.components.getRegistrar().handle(RELAY_CODEC, (data) => {
      void this._onProtocol(data).catch((err2) => {
        log65.error(err2);
      });
    }).catch((err2) => {
      log65.error(err2);
    });
  }
  hopEnabled() {
    return true;
  }
  hopActive() {
    return true;
  }
  get [symbol4]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "libp2p/circuit-relay-v1";
  }
  async _onProtocol(data) {
    const { connection, stream } = data;
    const controller = new import_timeout_abort_controller6.TimeoutController(this._init.hop.timeout);
    try {
      (0, import_events15.setMaxListeners)?.(Infinity, controller.signal);
    } catch {
    }
    try {
      const source = abortableDuplex(stream, controller.signal);
      const streamHandler = new StreamHandler({
        stream: {
          ...stream,
          ...source
        }
      });
      const request2 = await streamHandler.read();
      if (request2 == null) {
        log65("request was invalid, could not read from stream");
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: CircuitRelay.Status.MALFORMED_MESSAGE
        });
        streamHandler.close();
        return;
      }
      let virtualConnection;
      switch (request2.type) {
        case CircuitRelay.Type.CAN_HOP: {
          log65("received CAN_HOP request from %p", connection.remotePeer);
          await handleCanHop({ circuit: this, connection, streamHandler });
          break;
        }
        case CircuitRelay.Type.HOP: {
          log65("received HOP request from %p", connection.remotePeer);
          await handleHop({
            connection,
            request: request2,
            streamHandler,
            circuit: this,
            connectionManager: this.components.getConnectionManager()
          });
          break;
        }
        case CircuitRelay.Type.STOP: {
          log65("received STOP request from %p", connection.remotePeer);
          virtualConnection = await handleStop({
            connection,
            request: request2,
            streamHandler
          });
          break;
        }
        default: {
          log65("Request of type %s not supported", request2.type);
          streamHandler.write({
            type: CircuitRelay.Type.STATUS,
            code: CircuitRelay.Status.MALFORMED_MESSAGE
          });
          streamHandler.close();
          return;
        }
      }
      if (virtualConnection != null) {
        const remoteAddr = connection.remoteAddr.encapsulate("/p2p-circuit").encapsulate(multiaddr(request2.dstPeer?.addrs[0]));
        const localAddr = multiaddr(request2.srcPeer?.addrs[0]);
        const maConn = streamToMaConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request2.type === CircuitRelay.Type.HOP ? "relay" : "inbound";
        log65("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this.components.getUpgrader().upgradeInbound(maConn);
        log65("%s connection %s upgraded", type, maConn.remoteAddr);
        if (this.handler != null) {
          this.handler(conn);
        }
      }
    } finally {
      controller.clear();
    }
  }
  async dial(ma, options = {}) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = "Circuit relay dial failed as addresses did not have peer id";
      log65.error(errMsg);
      throw (0, import_err_code91.default)(new Error(errMsg), codes4.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.components.getConnectionManager().getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.getPeerStore().addressBook.add(relayPeer, [relayAddr]);
      relayConnection = await this.components.getConnectionManager().openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    try {
      const virtualConnection = await hop({
        ...options,
        connection: relayConnection,
        request: {
          type: CircuitRelay.Type.HOP,
          srcPeer: {
            id: this.components.getPeerId().toBytes(),
            addrs: this.components.getAddressManager().getAddresses().map((addr) => addr.bytes)
          },
          dstPeer: {
            id: destinationPeer.toBytes(),
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }
      });
      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.getPeerId().toString()}`);
      const maConn = streamToMaConnection({
        stream: virtualConnection,
        remoteAddr: ma,
        localAddr
      });
      log65("new outbound connection %s", maConn.remoteAddr);
      return await this.components.getUpgrader().upgradeOutbound(maConn);
    } catch (err2) {
      log65.error("Circuit relay dial failed", err2);
      disconnectOnFailure && await relayConnection.close();
      throw err2;
    }
  }
  createListener(options) {
    this.handler = options.handler;
    return createListener2({
      connectionManager: this.components.getConnectionManager(),
      peerStore: this.components.getPeerStore()
    });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
};

// node_modules/libp2p/dist/src/circuit/index.js
var import_set_delayed_interval2 = __toESM(require_src4(), 1);

// node_modules/libp2p/dist/src/circuit/utils.js
async function namespaceToCid(namespace3) {
  const bytes2 = new TextEncoder().encode(namespace3);
  const hash3 = await sha256.digest(bytes2);
  return CID.createV0(hash3);
}

// node_modules/libp2p/dist/src/circuit/constants.js
var minute3 = 60 * 1e3;
var ADVERTISE_BOOT_DELAY = 15 * minute3;
var ADVERTISE_TTL = 30 * minute3;
var CIRCUIT_PROTO_CODE = 290;
var HOP_METADATA_KEY = "hop_relay";
var HOP_METADATA_VALUE = "true";
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";

// node_modules/libp2p/dist/src/circuit/auto-relay.js
var import_it_sort3 = __toESM(require_it_sort(), 1);
var import_it_all8 = __toESM(require_it_all(), 1);

// node_modules/@libp2p/utils/node_modules/private-ip/lib/index.js
var import_netmask = __toESM(require_netmask(), 1);

// node_modules/@libp2p/utils/node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/@libp2p/utils/node_modules/private-ip/lib/index.js
var import_ipaddr = __toESM(require_ipaddr(), 1);
var { isValid: is_valid, parse: parse3 } = import_ipaddr.default;
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new import_netmask.Netmask(ip_range));
function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
function ipv6_check(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
var lib_default = (ip) => {
  if (is_valid(ip)) {
    const parsed = parse3(ip);
    if (parsed.kind() === "ipv4")
      return ipv4_check(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check(ip);
  } else if (isIP(ip) && ip_regex_default.v6().test(ip))
    return ipv6_check(ip);
  return void 0;
};

// node_modules/@libp2p/utils/node_modules/private-ip/index.js
var private_ip_default = lib_default;

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  const { address } = ma.nodeAddress();
  return Boolean(private_ip_default(address));
}

// node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}

// node_modules/libp2p/dist/src/circuit/auto-relay.js
var log66 = logger("libp2p:auto-relay");
var noop4 = () => {
};
var AutoRelay = class {
  constructor(components, init) {
    this.components = components;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxListeners = init.maxListeners ?? 1;
    this.listenRelays = /* @__PURE__ */ new Set();
    this.onError = init.onError ?? noop4;
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    this.components.getPeerStore().addEventListener("change:protocols", (evt) => {
      void this._onProtocolChange(evt).catch((err2) => {
        log66.error(err2);
      });
    });
    this.components.getConnectionManager().addEventListener("peer:disconnect", this._onPeerDisconnected);
  }
  async _onProtocolChange(evt) {
    const { peerId, protocols } = evt.detail;
    const id = peerId.toString();
    const hasProtocol = protocols.find((protocol4) => protocol4 === RELAY_CODEC);
    if (hasProtocol == null) {
      if (this.listenRelays.has(id)) {
        await this._removeListenRelay(id);
      }
      return;
    }
    if (this.listenRelays.has(id)) {
      return;
    }
    try {
      const connections = this.components.getConnectionManager().getConnections(peerId);
      if (connections.length === 0) {
        return;
      }
      const connection = connections[0];
      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
        log66(`relayed connection to ${id} will not be used to hop on`);
        return;
      }
      const supportsHop = await canHop({ connection });
      if (supportsHop) {
        await this.components.getPeerStore().metadataBook.setValue(peerId, HOP_METADATA_KEY, fromString3(HOP_METADATA_VALUE));
        await this._addListenRelay(connection, id);
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  _onPeerDisconnected(evt) {
    const connection = evt.detail;
    const peerId = connection.remotePeer;
    const id = peerId.toString();
    if (!this.listenRelays.has(id)) {
      return;
    }
    this._removeListenRelay(id).catch((err2) => {
      log66.error(err2);
    });
  }
  async _addListenRelay(connection, id) {
    try {
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = await pipe(await this.components.getPeerStore().addressBook.get(connection.remotePeer), (source) => (0, import_it_sort3.default)(source, this.addressSorter), async (source) => await (0, import_it_all8.default)(source));
      const result = await Promise.all(remoteAddrs.map(async (addr) => {
        try {
          let multiaddr2 = addr.multiaddr;
          if (multiaddr2.getPeerId() == null) {
            multiaddr2 = multiaddr2.encapsulate(`/p2p/${connection.remotePeer.toString()}`);
          }
          multiaddr2 = multiaddr2.encapsulate("/p2p-circuit");
          await this.components.getTransportManager().listen([multiaddr2]);
          return true;
        } catch (err2) {
          log66.error("error listening on circuit address", err2);
          this.onError(err2);
        }
        return false;
      }));
      if (result.includes(true)) {
        this.listenRelays.add(id);
      }
    } catch (err2) {
      this.onError(err2);
      this.listenRelays.delete(id);
    }
  }
  async _removeListenRelay(id) {
    if (this.listenRelays.delete(id)) {
      await this._listenOnAvailableHopRelays([id]);
    }
  }
  async _listenOnAvailableHopRelays(peersToIgnore = []) {
    if (this.listenRelays.size >= this.maxListeners) {
      return;
    }
    const knownHopsToDial = [];
    const peers = await this.components.getPeerStore().all();
    for (const { id, metadata } of peers) {
      const idStr = id.toString();
      if (this.listenRelays.has(idStr)) {
        continue;
      }
      if (peersToIgnore.includes(idStr)) {
        continue;
      }
      const supportsHop = metadata.get(HOP_METADATA_KEY);
      if (supportsHop == null || toString11(supportsHop) !== HOP_METADATA_VALUE) {
        continue;
      }
      const connections = this.components.getConnectionManager().getConnections(id);
      if (connections.length === 0) {
        knownHopsToDial.push(id);
        continue;
      }
      await this._addListenRelay(connections[0], idStr);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    for (const peerId of knownHopsToDial) {
      await this._tryToListenOnRelay(peerId);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      for await (const provider of this.components.getContentRouting().findProviders(cid)) {
        if (provider.multiaddrs.length === 0) {
          continue;
        }
        const peerId = provider.id;
        if (peerId.equals(this.components.getPeerId())) {
          continue;
        }
        await this.components.getPeerStore().addressBook.add(peerId, provider.multiaddrs);
        await this._tryToListenOnRelay(peerId);
        if (this.listenRelays.size >= this.maxListeners) {
          return;
        }
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  async _tryToListenOnRelay(peerId) {
    try {
      const connection = await this.components.getConnectionManager().openConnection(peerId);
      await this._addListenRelay(connection, peerId.toString());
    } catch (err2) {
      log66.error("Could not use %p as relay", peerId, err2);
      this.onError(err2, `could not connect and listen on known hop relay ${peerId.toString()}`);
    }
  }
};

// node_modules/libp2p/dist/src/circuit/index.js
var log67 = logger("libp2p:relay");
var Relay = class {
  constructor(components, init) {
    this.components = components;
    this.autoRelay = init.autoRelay?.enabled !== false ? new AutoRelay(components, {
      addressSorter: init.addressSorter,
      ...init.autoRelay
    }) : void 0;
    this.started = false;
    this.init = init;
    this._advertiseService = this._advertiseService.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.init.hop.enabled !== false && this.init.advertise.enabled !== false) {
      this.timeout = (0, import_set_delayed_interval2.setDelayedInterval)(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay);
    }
    this.started = true;
  }
  async stop() {
    if (this.timeout != null) {
      (0, import_set_delayed_interval2.clearDelayedInterval)(this.timeout);
    }
    this.started = false;
  }
  async _advertiseService() {
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      await this.components.getContentRouting().provide(cid);
    } catch (err2) {
      if (err2.code === codes4.ERR_NO_ROUTERS_AVAILABLE) {
        log67.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err2);
        await this.stop();
      } else {
        log67.error(err2);
      }
    }
  }
};

// node_modules/libp2p/dist/src/keychain/index.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/libp2p/dist/src/keychain/cms.js
var import_pkcs7 = __toESM(require_pkcs7(), 1);
var import_pbe2 = __toESM(require_pbe(), 1);
var import_forge8 = __toESM(require_forge(), 1);

// node_modules/libp2p/dist/src/keychain/util.js
var import_x509 = __toESM(require_x509(), 1);
var import_forge7 = __toESM(require_forge(), 1);
var pki = import_forge7.default.pki;
var certificateForKey = (key, privateKey) => {
  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);
  const cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = "01";
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  const attrs = [{
    name: "organizationName",
    value: "ipfs"
  }, {
    shortName: "OU",
    value: "keystore"
  }, {
    name: "commonName",
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: "basicConstraints",
    cA: true
  }, {
    name: "keyUsage",
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: "extKeyUsage",
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: "nsCertType",
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]);
  cert.sign(privateKey);
  return cert;
};
async function findAsync(array, asyncCompare) {
  const promises = array.map(asyncCompare);
  const results = await Promise.all(promises);
  const index = results.findIndex((result) => result);
  return array[index];
}

// node_modules/libp2p/dist/src/keychain/cms.js
var import_err_code92 = __toESM(require_err_code(), 1);
var log68 = logger("libp2p:keychain:cms");
var privates = /* @__PURE__ */ new WeakMap();
var CMS = class {
  constructor(keychain, dek) {
    if (keychain == null) {
      throw (0, import_err_code92.default)(new Error("keychain is required"), codes4.ERR_KEYCHAIN_REQUIRED);
    }
    this.keychain = keychain;
    privates.set(this, { dek });
  }
  async encrypt(name22, plain) {
    if (!(plain instanceof Uint8Array)) {
      throw (0, import_err_code92.default)(new Error("Plain data must be a Uint8Array"), codes4.ERR_INVALID_PARAMETERS);
    }
    const key = await this.keychain.findKeyByName(name22);
    const pem = await this.keychain.getPrivateKey(name22);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code92.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge8.default.pki.decryptRsaPrivateKey(pem, dek);
    const certificate = await certificateForKey(key, privateKey);
    const p7 = import_forge8.default.pkcs7.createEnvelopedData();
    p7.addRecipient(certificate);
    p7.content = import_forge8.default.util.createBuffer(plain);
    p7.encrypt();
    const der = import_forge8.default.asn1.toDer(p7.toAsn1()).getBytes();
    return fromString3(der, "ascii");
  }
  async decrypt(cmsData) {
    if (!(cmsData instanceof Uint8Array)) {
      throw (0, import_err_code92.default)(new Error("CMS data is required"), codes4.ERR_INVALID_PARAMETERS);
    }
    let cms;
    try {
      const buf2 = import_forge8.default.util.createBuffer(toString11(cmsData, "ascii"));
      const obj = import_forge8.default.asn1.fromDer(buf2);
      cms = import_forge8.default.pkcs7.messageFromAsn1(obj);
    } catch (err2) {
      log68.error(err2);
      throw (0, import_err_code92.default)(new Error("Invalid CMS"), codes4.ERR_INVALID_CMS);
    }
    const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
      return {
        recipient: r2,
        keyId: r2.issuer.find((a) => a.shortName === "CN").value
      };
    });
    const r = await findAsync(recipients, async (recipient) => {
      try {
        const key2 = await this.keychain.findKeyById(recipient.keyId);
        if (key2 != null) {
          return true;
        }
      } catch (err2) {
        return false;
      }
      return false;
    });
    if (r == null) {
      const missingKeys = recipients.map((r2) => r2.keyId);
      throw (0, import_err_code92.default)(new Error(`Decryption needs one of the key(s): ${missingKeys.join(", ")}`), codes4.ERR_MISSING_KEYS, {
        missingKeys
      });
    }
    const key = await this.keychain.findKeyById(r.keyId);
    if (key == null) {
      throw (0, import_err_code92.default)(new Error("No key available to decrypto"), codes4.ERR_NO_KEY);
    }
    const pem = await this.keychain.getPrivateKey(key.name);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code92.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge8.default.pki.decryptRsaPrivateKey(pem, dek);
    cms.decrypt(r.recipient, privateKey);
    return fromString3(cms.content.getBytes(), "ascii");
  }
};

// node_modules/libp2p/dist/src/keychain/index.js
var import_err_code93 = __toESM(require_err_code(), 1);
var log69 = logger("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates2 = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions18 = {
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name22) {
  if (name22 == null) {
    return false;
  }
  if (typeof name22 !== "string") {
    return false;
  }
  return name22 === (0, import_sanitize_filename.default)(name22.trim()) && name22.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay3 = Math.random() * (max - min) + min;
  await new Promise((resolve7) => setTimeout(resolve7, delay3));
}
function DsName(name22) {
  return new Key(keyPrefix + name22);
}
function DsInfoName(name22) {
  return new Key(infoPrefix + name22);
}
var KeyChain = class {
  constructor(components, init) {
    this.components = components;
    this.init = merge_options_default(defaultOptions18, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const dsname = DsInfoName("self");
    if (!await this.components.getDatastore().has(dsname)) {
      await this.importPeer("self", this.components.getPeerId());
    }
    this.started = true;
  }
  stop() {
    this.started = false;
  }
  get cms() {
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    return new CMS(this, dek);
  }
  static generateOptions() {
    const options = Object.assign({}, defaultOptions18);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString11(randomBytes(saltLength), "base64");
    return options;
  }
  static get options() {
    return defaultOptions18;
  }
  async createKey(name22, type, size = 2048) {
    if (!validateKeyName(name22) || name22 === "self") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("Invalid key name"), codes4.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("Invalid key type"), codes4.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name22);
    const exists2 = await this.components.getDatastore().has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("Key name already exists"), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw (0, import_err_code93.default)(new Error("Invalid RSA key size"), codes4.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair4(type, size);
      const kid = await keypair.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name22,
        id: kid
      };
      const batch3 = this.components.getDatastore().batch();
      batch3.put(dsname, fromString3(pem));
      batch3.put(DsInfoName(name22), fromString3(JSON.stringify(keyInfo)));
      await batch3.commit();
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    return keyInfo;
  }
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value2 of this.components.getDatastore().query(query)) {
      info.push(JSON.parse(toString11(value2.value)));
    }
    return info;
  }
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      return keys.find((k) => k.id === id);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async findKeyByName(name22) {
    if (!validateKeyName(name22)) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name22);
    try {
      const res = await this.components.getDatastore().get(dsname);
      return JSON.parse(toString11(res));
    } catch (err2) {
      await randomDelay();
      log69.error(err2);
      throw (0, import_err_code93.default)(new Error(`Key '${name22}' does not exist.`), codes4.ERR_KEY_NOT_FOUND);
    }
  }
  async removeKey(name22) {
    if (!validateKeyName(name22) || name22 === "self") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name22);
    const keyInfo = await this.findKeyByName(name22);
    const batch3 = this.components.getDatastore().batch();
    batch3.delete(dsname);
    batch3.delete(DsInfoName(name22));
    await batch3.commit();
    return keyInfo;
  }
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid old key name '${oldName}'`), codes4.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid new key name '${newName}'`), codes4.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists2 = await this.components.getDatastore().has(newDsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Key '${newName}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.getDatastore().get(oldDsname);
      const res = await this.components.getDatastore().get(oldInfoName);
      const keyInfo = JSON.parse(toString11(res));
      keyInfo.name = newName;
      const batch3 = this.components.getDatastore().batch();
      batch3.put(newDsname, pem);
      batch3.put(newInfoName, fromString3(JSON.stringify(keyInfo)));
      batch3.delete(oldDsname);
      batch3.delete(oldInfoName);
      await batch3.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async exportKey(name22, password) {
    if (!validateKeyName(name22)) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("Password is required"), codes4.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name22);
    try {
      const res = await this.components.getDatastore().get(dsname);
      const pem = toString11(res);
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      return await privateKey.export(password);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async importKey(name22, pem, password) {
    if (!validateKeyName(name22) || name22 === "self") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("PEM encoded key is required"), codes4.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name22);
    const exists2 = await this.components.getDatastore().has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Key '${name22}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err2) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error("Cannot read the key, most likely the password is wrong"), codes4.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    const keyInfo = {
      name: name22,
      id: kid
    };
    const batch3 = this.components.getDatastore().batch();
    batch3.put(dsname, fromString3(pem));
    batch3.put(DsInfoName(name22), fromString3(JSON.stringify(keyInfo)));
    await batch3.commit();
    return keyInfo;
  }
  async importPeer(name22, peer) {
    try {
      if (!validateKeyName(name22)) {
        throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw (0, import_err_code93.default)(new Error("PeerId is required"), codes4.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw (0, import_err_code93.default)(new Error("PeerId.privKey is required"), codes4.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey3(peer.privateKey);
      const dsname = DsName(name22);
      const exists2 = await this.components.getDatastore().has(dsname);
      if (exists2) {
        await randomDelay();
        throw (0, import_err_code93.default)(new Error(`Key '${name22}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name22,
        id: peer.toString()
      };
      const batch3 = this.components.getDatastore().batch();
      batch3.put(dsname, fromString3(pem));
      batch3.put(DsInfoName(name22), fromString3(JSON.stringify(keyInfo)));
      await batch3.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async getPrivateKey(name22) {
    if (!validateKeyName(name22)) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid key name '${name22}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name22);
      const res = await this.components.getDatastore().get(dsname);
      return toString11(res);
    } catch (err2) {
      await randomDelay();
      log69.error(err2);
      throw (0, import_err_code93.default)(new Error(`Key '${name22}' does not exist.`), codes4.ERR_KEY_NOT_FOUND);
    }
  }
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid old pass type '${typeof oldPass}'`), codes4.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid new pass type '${typeof newPass}'`), codes4.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw (0, import_err_code93.default)(new Error(`Invalid pass length ${newPass.length}`), codes4.ERR_INVALID_PASS_LENGTH);
    }
    log69("recreating keychain");
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code93.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.getDatastore().get(DsName(key.name));
      const pem = toString11(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch3 = this.components.getDatastore().batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch3.put(DsName(key.name), fromString3(keyAsPEM));
      batch3.put(DsInfoName(key.name), fromString3(JSON.stringify(keyInfo)));
      await batch3.commit();
    }
    log69("keychain reconstructed");
  }
};

// node_modules/libp2p/dist/src/metrics/index.js
var import_it_foreach = __toESM(require_it_foreach(), 1);
var import_hashlru4 = __toESM(require_hashlru(), 1);

// node_modules/libp2p/dist/src/constants.js
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PARALLEL_DIALS = 100;
var MAX_PER_PEER_DIALS = 4;
var MAX_ADDRS_TO_DIAL = 25;
var METRICS = {
  computeThrottleMaxQueueSize: 1e3,
  computeThrottleTimeout: 2e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ],
  maxOldPeersRetention: 50
};

// node_modules/libp2p/dist/src/metrics/moving-average.js
var DefaultMovingAverage = class {
  constructor(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(time, value2) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value2 - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value2 + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value2;
    }
    this.previousTime = time;
  }
};
function createMovingAverage(timespan) {
  return new DefaultMovingAverage(timespan);
}

// node_modules/libp2p/dist/src/metrics/stats.js
var import_retimer3 = __toESM(require_retimer(), 1);
var DefaultStats = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.enabled = init.enabled;
    this.queue = [];
    this.stats = {
      dataReceived: 0n,
      dataSent: 0n
    };
    this.frequencyLastTime = Date.now();
    this.frequencyAccumulators = {};
    this.movingAverages = {
      dataReceived: [],
      dataSent: []
    };
    this.computeThrottleMaxQueueSize = init.computeThrottleMaxQueueSize;
    this.computeThrottleTimeout = init.computeThrottleTimeout;
    this._update = this._update.bind(this);
    this.movingAverageIntervals = init.movingAverageIntervals;
    for (let i2 = 0; i2 < init.initialCounters.length; i2++) {
      const key = init.initialCounters[i2];
      this.stats[key] = 0n;
      this.movingAverages[key] = [];
      for (let k = 0; k < this.movingAverageIntervals.length; k++) {
        const interval = this.movingAverageIntervals[k];
        const ma = this.movingAverages[key][interval] = createMovingAverage(interval);
        ma.push(this.frequencyLastTime, 0);
      }
    }
  }
  start() {
    if (!this.enabled) {
      return;
    }
    if (this.queue.length > 0) {
      this._resetComputeTimeout();
    }
  }
  stop() {
    if (this.timeout != null) {
      this.timeout.clear();
      this.timeout = null;
    }
  }
  getSnapshot() {
    return Object.assign({}, this.stats);
  }
  getMovingAverages() {
    return Object.assign({}, this.movingAverages);
  }
  push(counter, inc) {
    this.queue.push([counter, inc, Date.now()]);
    this._resetComputeTimeout();
  }
  _resetComputeTimeout() {
    this.timeout = (0, import_retimer3.default)(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this.queue.length / this.computeThrottleMaxQueueSize;
    const timeout = Math.max(this.computeThrottleTimeout * (1 - urgency), 0);
    return timeout;
  }
  _update() {
    this.timeout = null;
    if (this.queue.length > 0) {
      let last14 = ["", 0, 0];
      for (last14 of this.queue) {
        this._applyOp(last14);
      }
      this.queue = [];
      if (last14.length > 2 && last14[0] !== "") {
        this._updateFrequency(last14[2]);
      }
      this.dispatchEvent(new CustomEvent("update", {
        detail: this.stats
      }));
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this.frequencyLastTime;
    this._updateFrequencyFor("dataReceived", timeDiff, latestTime);
    this._updateFrequencyFor("dataSent", timeDiff, latestTime);
    this.frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this.frequencyAccumulators[key] ?? 0;
    this.frequencyAccumulators[key] = 0;
    const safeTimeDiff = timeDiffMS ?? 1;
    const hz = count / safeTimeDiff * 1e3;
    let movingAverages = this.movingAverages[key];
    if (movingAverages == null) {
      movingAverages = this.movingAverages[key] = [];
    }
    const intervals = this.movingAverageIntervals;
    for (let i2 = 0; i2 < intervals.length; i2++) {
      const movingAverageInterval = intervals[i2];
      let movingAverage = movingAverages[movingAverageInterval];
      if (movingAverage == null) {
        movingAverage = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    }
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error("invalid increment number");
    }
    let n;
    if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {
      n = this.stats[key] = 0n;
    } else {
      n = this.stats[key];
    }
    this.stats[key] = n + BigInt(inc);
    if (this.frequencyAccumulators[key] == null) {
      this.frequencyAccumulators[key] = 0;
    }
    this.frequencyAccumulators[key] += inc;
  }
};

// node_modules/libp2p/dist/src/metrics/index.js
var initialCounters = [
  "dataReceived",
  "dataSent"
];
var directionToEvent = {
  in: "dataReceived",
  out: "dataSent"
};
var DefaultMetrics = class {
  constructor(init) {
    this.enabled = init.enabled;
    this.statsInit = {
      ...init,
      initialCounters
    };
    this.globalStats = new DefaultStats(this.statsInit);
    this.peerStats = /* @__PURE__ */ new Map();
    this.protocolStats = /* @__PURE__ */ new Map();
    this.oldPeers = (0, import_hashlru4.default)(init.maxOldPeersRetention ?? METRICS.maxOldPeersRetention);
    this.running = false;
    this._onMessage = this._onMessage.bind(this);
    this.systems = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.enabled) {
      return;
    }
    this.running = true;
  }
  async stop() {
    if (!this.running) {
      return;
    }
    this.running = false;
    this.globalStats.stop();
    for (const stats of this.peerStats.values()) {
      stats.stop();
    }
    for (const stats of this.protocolStats.values()) {
      stats.stop();
    }
  }
  getGlobal() {
    return this.globalStats;
  }
  getPeers() {
    return Array.from(this.peerStats.keys());
  }
  getComponentMetrics() {
    return this.systems;
  }
  updateComponentMetric(update) {
    const { system = "libp2p", component, metric, value: value2, label, help } = update;
    if (!this.systems.has(system)) {
      this.systems.set(system, /* @__PURE__ */ new Map());
    }
    const systemMetrics = this.systems.get(system);
    if (systemMetrics == null) {
      throw new Error("Unknown metric system");
    }
    if (!systemMetrics.has(component)) {
      systemMetrics.set(component, /* @__PURE__ */ new Map());
    }
    const componentMetrics = systemMetrics.get(component);
    if (componentMetrics == null) {
      throw new Error("Unknown metric component");
    }
    componentMetrics.set(metric, {
      label,
      help,
      calculate: typeof value2 !== "function" ? () => value2 : value2
    });
  }
  forPeer(peerId) {
    const idString = peerId.toString();
    return this.peerStats.get(idString) ?? this.oldPeers.get(idString);
  }
  getProtocols() {
    return Array.from(this.protocolStats.keys());
  }
  forProtocol(protocol4) {
    return this.protocolStats.get(protocol4);
  }
  onPeerDisconnected(peerId) {
    const idString = peerId.toString();
    const peerStats = this.peerStats.get(idString);
    if (peerStats != null) {
      peerStats.stop();
      this.peerStats.delete(idString);
      this.oldPeers.set(idString, peerStats);
    }
  }
  _onMessage(opts) {
    if (!this.running) {
      return;
    }
    const { remotePeer, protocol: protocol4, direction, dataLength } = opts;
    const key = directionToEvent[direction];
    let peerStats = this.forPeer(remotePeer);
    if (peerStats == null) {
      const stats = new DefaultStats(this.statsInit);
      this.peerStats.set(remotePeer.toString(), stats);
      peerStats = stats;
    }
    peerStats.push(key, dataLength);
    this.globalStats.push(key, dataLength);
    if (protocol4 != null) {
      let protocolStats = this.forProtocol(protocol4);
      if (protocolStats == null) {
        const stats = new DefaultStats(this.statsInit);
        this.protocolStats.set(protocol4, stats);
        protocolStats = stats;
      }
      protocolStats.push(key, dataLength);
    }
  }
  updatePlaceholder(placeholder, peerId) {
    if (!this.running) {
      return;
    }
    const placeholderString = placeholder.toString();
    const placeholderStats = this.peerStats.get(placeholderString) ?? this.oldPeers.get(placeholderString);
    const peerIdString = peerId.toString();
    const existingStats = this.peerStats.get(peerIdString) ?? this.oldPeers.get(peerIdString);
    let mergedStats = placeholderStats;
    if (existingStats != null) {
      mergedStats = mergeStats(existingStats, mergedStats);
      this.oldPeers.remove(peerIdString);
    }
    this.peerStats.delete(placeholder.toString());
    this.peerStats.set(peerIdString, mergedStats);
    mergedStats.start();
  }
  trackStream(opts) {
    const { stream, remotePeer, protocol: protocol4 } = opts;
    if (!this.running) {
      return;
    }
    const source = stream.source;
    stream.source = (0, import_it_foreach.default)(source, (chunk) => this._onMessage({
      remotePeer,
      protocol: protocol4,
      direction: "in",
      dataLength: chunk.byteLength
    }));
    const sink = stream.sink;
    stream.sink = async (source2) => {
      return await pipe(source2, (source3) => (0, import_it_foreach.default)(source3, (chunk) => {
        this._onMessage({
          remotePeer,
          protocol: protocol4,
          direction: "out",
          dataLength: chunk.byteLength
        });
      }), sink);
    };
  }
};
function mergeStats(target, other) {
  target.stop();
  other.stop();
  target.queue = [...target.queue, ...other.queue];
  return target;
}

// node_modules/p-reflect/index.js
async function pReflect(promise) {
  try {
    const value2 = await promise;
    return {
      status: "fulfilled",
      value: value2,
      isFulfilled: true,
      isRejected: false
    };
  } catch (error) {
    return {
      status: "rejected",
      reason: error,
      isFulfilled: false,
      isRejected: true
    };
  }
}

// node_modules/yocto-queue/index.js
var Node = class {
  constructor(value2) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value2;
  }
};
var _head, _tail, _size;
var Queue4 = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value2) {
    const node = new Node(value2);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue4();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve7, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve7(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve7, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve7, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve7) => {
    enqueue(fn, resolve7, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// node_modules/p-settle/index.js
async function pSettle(array, options = {}) {
  const { concurrency = Number.POSITIVE_INFINITY } = options;
  const limit = pLimit(concurrency);
  return Promise.all(array.map((element) => {
    if (element && typeof element.then === "function") {
      return pReflect(element);
    }
    if (typeof element === "function") {
      return pReflect(limit(() => element()));
    }
    return pReflect(Promise.resolve(element));
  }));
}

// node_modules/libp2p/dist/src/transport-manager.js
var import_err_code94 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/tracked-map/dist/src/index.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    const { system, component, metric, metrics } = init;
    this.system = system ?? "libp2p";
    this.component = component;
    this.metric = metric;
    this.metrics = metrics;
    this.updateComponentMetric();
  }
  set(key, value2) {
    super.set(key, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metrics.updateComponentMetric({
      system: this.system,
      component: this.component,
      metric: this.metric,
      value: this.size
    });
  }
};
function trackedMap(config2) {
  const { system, component, metric, metrics } = config2;
  let map19;
  if (metrics != null) {
    map19 = new TrackedMap({ system, component, metric, metrics });
  } else {
    map19 = /* @__PURE__ */ new Map();
  }
  return map19;
}

// node_modules/libp2p/dist/src/transport-manager.js
var log70 = logger("libp2p:transports");
var DefaultTransportManager = class extends EventEmitter2 {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      component: "transport-manager",
      metric: "listeners",
      metrics: this.components.getMetrics()
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw (0, import_err_code94.default)(new Error("Transport must have a valid tag"), codes4.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw (0, import_err_code94.default)(new Error("There is already a transport with this tag"), codes4.ERR_DUPLICATE_TRANSPORT);
    }
    log70("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const addrs = this.components.getAddressManager().getListenAddrs();
    await this.listen(addrs);
    this.started = true;
  }
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log70("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log70("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw (0, import_err_code94.default)(new Error(`No transport available for address ${String(ma)}`), codes4.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.getUpgrader()
      });
    } catch (err2) {
      if (err2.code == null) {
        err2.code = codes4.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err2;
    }
  }
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  getTransports() {
    return Array.of(...this.transports.values());
  }
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log70("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log70("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.getUpgrader()
        });
        let listeners = this.listeners.get(key);
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.dispatchEvent(new CustomEvent("listener:listening", {
            detail: listener
          }));
        });
        listener.addEventListener("close", () => {
          this.dispatchEvent(new CustomEvent("listener:close", {
            detail: listener
          }));
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await pSettle(tasks);
      const isListening = results.find((r) => r.isFulfilled);
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw (0, import_err_code94.default)(new Error(`Transport (${key}) could not listen on any available address`), codes4.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message6 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw (0, import_err_code94.default)(new Error(message6), codes4.ERR_NO_VALID_ADDRESSES);
      }
      log70(`libp2p in dial mode only: ${message6}`);
    }
  }
  async remove(key) {
    log70("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/libp2p/dist/src/upgrader.js
var import_err_code99 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/@libp2p/multistream-select/dist/src/select.js
var import_err_code96 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var import_err_code95 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/identity.js
var identity_exports21 = {};
__export(identity_exports21, {
  identity: () => identity21
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/vendor/base-x.js
function base17(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src13 = base17;
var _brrp__multiformats_scope_baseX13 = src13;
var base_x_default13 = _brrp__multiformats_scope_baseX13;

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bytes.js
var empty14 = new Uint8Array(0);
var equals29 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce13 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString20 = (str) => new TextEncoder().encode(str);
var toString22 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base.js
var Encoder14 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder14 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or14(this, decoder);
  }
};
var ComposedDecoder13 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or14(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or14 = (left, right) => new ComposedDecoder13({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec13 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder14(name22, prefix, baseEncode);
    this.decoder = new Decoder14(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from23 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec13(name22, prefix, encode81, decode97);
var baseX13 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default13(alphabet16, name22);
  return from23({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce13(decode97(text))
  });
};
var decode70 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode59 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464813 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from23({
    prefix,
    name: name22,
    encode(input) {
      return encode59(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode70(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/identity.js
var identity21 = from23({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString22(buf2),
  decode: (str) => fromString20(str)
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base2.js
var base2_exports11 = {};
__export(base2_exports11, {
  base2: () => base212
});
var base212 = rfc464813({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base8.js
var base8_exports11 = {};
__export(base8_exports11, {
  base8: () => base811
});
var base811 = rfc464813({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base10.js
var base10_exports11 = {};
__export(base10_exports11, {
  base10: () => base1011
});
var base1011 = baseX13({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base16.js
var base16_exports11 = {};
__export(base16_exports11, {
  base16: () => base1611,
  base16upper: () => base16upper11
});
var base1611 = rfc464813({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper11 = rfc464813({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base32.js
var base32_exports11 = {};
__export(base32_exports11, {
  base32: () => base3213,
  base32hex: () => base32hex13,
  base32hexpad: () => base32hexpad13,
  base32hexpadupper: () => base32hexpadupper13,
  base32hexupper: () => base32hexupper13,
  base32pad: () => base32pad13,
  base32padupper: () => base32padupper13,
  base32upper: () => base32upper13,
  base32z: () => base32z13
});
var base3213 = rfc464813({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper13 = rfc464813({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad13 = rfc464813({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper13 = rfc464813({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex13 = rfc464813({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper13 = rfc464813({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad13 = rfc464813({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper13 = rfc464813({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z13 = rfc464813({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base36.js
var base36_exports11 = {};
__export(base36_exports11, {
  base36: () => base3611,
  base36upper: () => base36upper11
});
var base3611 = baseX13({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper11 = baseX13({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base58.js
var base58_exports11 = {};
__export(base58_exports11, {
  base58btc: () => base58btc13,
  base58flickr: () => base58flickr13
});
var base58btc13 = baseX13({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr13 = baseX13({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base64.js
var base64_exports11 = {};
__export(base64_exports11, {
  base64: () => base6412,
  base64pad: () => base64pad12,
  base64url: () => base64url12,
  base64urlpad: () => base64urlpad12
});
var base6412 = rfc464813({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad12 = rfc464813({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url12 = rfc464813({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad12 = rfc464813({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports11 = {};
__export(base256emoji_exports11, {
  base256emoji: () => base256emoji11
});
var alphabet12 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars11 = alphabet12.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes11 = alphabet12.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode60(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars11[c];
    return p;
  }, "");
}
function decode71(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes11[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji11 = from23({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode60,
  decode: decode71
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports11 = {};
__export(sha2_browser_exports11, {
  sha256: () => sha25611,
  sha512: () => sha51211
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/vendor/varint.js
var encode_112 = encode61;
var MSB12 = 128;
var REST12 = 127;
var MSBALL12 = ~REST12;
var INT12 = Math.pow(2, 31);
function encode61(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT12) {
    out[offset++] = num & 255 | MSB12;
    num /= 128;
  }
  while (num & MSBALL12) {
    out[offset++] = num & 255 | MSB12;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode61.bytes = offset - oldOffset + 1;
  return out;
}
var decode72 = read12;
var MSB$112 = 128;
var REST$112 = 127;
function read12(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read12.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$112) << shift : (b & REST$112) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$112);
  read12.bytes = counter - offset;
  return res;
}
var N113 = Math.pow(2, 7);
var N213 = Math.pow(2, 14);
var N313 = Math.pow(2, 21);
var N413 = Math.pow(2, 28);
var N513 = Math.pow(2, 35);
var N613 = Math.pow(2, 42);
var N713 = Math.pow(2, 49);
var N813 = Math.pow(2, 56);
var N913 = Math.pow(2, 63);
var length15 = function(value2) {
  return value2 < N113 ? 1 : value2 < N213 ? 2 : value2 < N313 ? 3 : value2 < N413 ? 4 : value2 < N513 ? 5 : value2 < N613 ? 6 : value2 < N713 ? 7 : value2 < N813 ? 8 : value2 < N913 ? 9 : 10;
};
var varint18 = {
  encode: encode_112,
  decode: decode72,
  encodingLength: length15
};
var _brrp_varint12 = varint18;
var varint_default12 = _brrp_varint12;

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/varint.js
var decode73 = (data, offset = 0) => {
  const code22 = varint_default12.decode(data, offset);
  return [code22, varint_default12.decode.bytes];
};
var encodeTo12 = (int, target, offset = 0) => {
  varint_default12.encode(int, target, offset);
  return target;
};
var encodingLength12 = (int) => {
  return varint_default12.encodingLength(int);
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/hashes/digest.js
var create18 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength12(code22);
  const digestOffset = sizeOffset + encodingLength12(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo12(code22, bytes2, 0);
  encodeTo12(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest12(code22, size, digest15, bytes2);
};
var decode74 = (multihash) => {
  const bytes2 = coerce13(multihash);
  const [code22, sizeOffset] = decode73(bytes2);
  const [size, digestOffset] = decode73(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest12(code22, size, digest15, bytes2);
};
var equals30 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals29(a.bytes, data.bytes);
  }
};
var Digest12 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/hashes/hasher.js
var from24 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher11(name22, code22, encode81);
var Hasher11 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create18(this.code, result) : result.then((digest15) => create18(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/hashes/sha2-browser.js
var sha11 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25611 = from24({
  name: "sha2-256",
  code: 18,
  encode: sha11("SHA-256")
});
var sha51211 = from24({
  name: "sha2-512",
  code: 19,
  encode: sha11("SHA-512")
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/hashes/identity.js
var identity_exports22 = {};
__export(identity_exports22, {
  identity: () => identity22
});
var code17 = 0;
var name17 = "identity";
var encode62 = coerce13;
var digest11 = (input) => create18(code17, encode62(input));
var identity22 = { code: code17, name: name17, encode: encode62, digest: digest11 };

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/codecs/json.js
var textEncoder14 = new TextEncoder();
var textDecoder13 = new TextDecoder();

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/cid.js
var format11 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV012(
        bytes2,
        baseCache11(link),
        base30 || base58btc13.encoder
      );
    default:
      return toStringV112(
        bytes2,
        baseCache11(link),
        base30 || base3213.encoder
      );
  }
};
var cache13 = /* @__PURE__ */ new WeakMap();
var baseCache11 = (cid) => {
  const baseCache16 = cache13.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache13.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID12 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE12) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE12) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID12.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create18(code22, digest15);
        return CID12.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID12.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals30(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format11(this, base30);
  }
  toJSON() {
    return { "/": format11(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID12) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID12(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID13(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol12] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode74(multihash);
      return CID12.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE12) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE12}) block encoding`
          );
        } else {
          return new CID12(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID13(version4, code22, digest15.bytes);
        return new CID12(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID12.create(0, DAG_PB_CODE12, digest15);
  }
  static createV1(code22, digest15) {
    return CID12.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID12.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID12.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce13(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest12(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID12.createV0(digest15) : CID12.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode73(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE12;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes12(source, base30);
    const cid = CID12.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache11(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes12 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc13;
      return [
        base58btc13.prefix,
        decoder.decode(`${base58btc13.prefix}${source}`)
      ];
    }
    case base58btc13.prefix: {
      const decoder = base30 || base58btc13;
      return [base58btc13.prefix, decoder.decode(source)];
    }
    case base3213.prefix: {
      const decoder = base30 || base3213;
      return [base3213.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV012 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc13.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV112 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE12 = 112;
var SHA_256_CODE12 = 18;
var encodeCID13 = (version4, code22, multihash) => {
  const codeOffset = encodingLength12(version4);
  const hashOffset = codeOffset + encodingLength12(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo12(version4, bytes2, 0);
  encodeTo12(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol12 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/basics.js
var bases11 = { ...identity_exports21, ...base2_exports11, ...base8_exports11, ...base10_exports11, ...base16_exports11, ...base32_exports11, ...base36_exports11, ...base58_exports11, ...base64_exports11, ...base256emoji_exports11 };
var hashes11 = { ...sha2_browser_exports11, ...identity_exports22 };

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array12(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe13(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array12(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec14(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string10 = createCodec14("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii10 = createCodec14("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe13(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES10 = {
  utf8: string10,
  "utf-8": string10,
  hex: bases11.base16,
  latin1: ascii10,
  ascii: ascii10,
  binary: ascii10,
  ...bases11
};
var bases_default10 = BASES10;

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/from-string.js
function fromString21(string14, encoding = "utf8") {
  const base30 = bases_default10[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array12(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/@libp2p/multistream-select/node_modules/it-first/dist/src/index.js
async function first5(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/to-string.js
function toString23(array, encoding = "utf8") {
  const base30 = bases_default10[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var log71 = logger("libp2p:mss");
var NewLine = fromString21("\n");
function encode63(buffer2) {
  const list = new Uint8ArrayList(buffer2, NewLine);
  return encode52.single(list);
}
function write2(writer5, buffer2, options = {}) {
  const encoded = encode63(buffer2);
  if (options.writeBytes === true) {
    writer5.push(encoded.subarray());
  } else {
    writer5.push(encoded);
  }
}
function writeAll(writer5, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf2 of buffers) {
    list.append(encode63(buf2));
  }
  if (options.writeBytes === true) {
    writer5.push(list.subarray());
  } else {
    writer5.push(list);
  }
}
async function read13(reader6, options) {
  let byteLength2 = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => await reader6.next(byteLength2)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength2 = l;
  };
  const buf2 = await pipe(input, decode62({ onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source) => await first5(source));
  if (buf2 == null || buf2.length === 0) {
    throw (0, import_err_code95.default)(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf2.get(buf2.byteLength - 1) !== NewLine[0]) {
    log71.error("Invalid mss message - missing newline - %s", buf2.subarray());
    throw (0, import_err_code95.default)(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf2.sublist(0, -1);
}
async function readString(reader6, options) {
  const buf2 = await read13(reader6, options);
  return toString23(buf2.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
var log72 = logger("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader6, writer: writer5, rest, stream: shakeStream } = handshake(stream);
  const protocol4 = protocols.shift();
  if (protocol4 == null) {
    throw new Error("At least one protocol must be specified");
  }
  log72('select: write ["%s", "%s"]', PROTOCOL_ID, protocol4);
  const p1 = fromString21(PROTOCOL_ID);
  const p2 = fromString21(protocol4);
  writeAll(writer5, [p1, p2], options);
  let response = await readString(reader6, options);
  log72('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader6, options);
    log72('select: read "%s"', response);
  }
  if (response === protocol4) {
    rest();
    return { stream: shakeStream, protocol: protocol4 };
  }
  for (const protocol5 of protocols) {
    log72('select: write "%s"', protocol5);
    write2(writer5, fromString21(protocol5), options);
    const response2 = await readString(reader6, options);
    log72('select: read "%s" for "%s"', response2, protocol5);
    if (response2 === protocol5) {
      rest();
      return { stream: shakeStream, protocol: protocol5 };
    }
  }
  rest();
  throw (0, import_err_code96.default)(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
var log73 = logger("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer: writer5, reader: reader6, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol4 = await readString(reader6, options);
    log73('read "%s"', protocol4);
    if (protocol4 === PROTOCOL_ID) {
      log73('respond with "%s" for "%s"', PROTOCOL_ID, protocol4);
      write2(writer5, fromString21(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol4)) {
      write2(writer5, fromString21(protocol4), options);
      log73('respond with "%s" for "%s"', protocol4, protocol4);
      rest();
      return { stream: shakeStream, protocol: protocol4 };
    }
    if (protocol4 === "ls") {
      write2(writer5, new Uint8ArrayList(...protocols.map((p) => encode63(fromString21(p)))), options);
      log73('respond with "%s" for %s', protocols, protocol4);
      continue;
    }
    write2(writer5, fromString21("na"), options);
    log73('respond with "na" for "%s"', protocol4);
  }
}

// node_modules/libp2p/dist/src/upgrader.js
var import_mutable_proxy = __toESM(require_build(), 1);

// node_modules/@libp2p/connection/dist/src/index.js
var import_err_code97 = __toESM(require_err_code());

// node_modules/@libp2p/interface-connection/dist/src/index.js
var symbol6 = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/connection/dist/src/index.js
var log74 = logger("libp2p:connection");
var ConnectionImpl = class {
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  get [Symbol.toStringTag]() {
    return "Connection";
  }
  get [symbol6]() {
    return true;
  }
  get streams() {
    return this._getStreams();
  }
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw (0, import_err_code97.default)(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw (0, import_err_code97.default)(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream = await this._newStream(protocols, options);
    stream.stat.direction = "outbound";
    return stream;
  }
  addStream(stream) {
    stream.stat.direction = "inbound";
  }
  removeStream(id) {
  }
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s) => s.close());
    } catch (err2) {
      log74.error(err2);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/registrar.js
var import_err_code98 = __toESM(require_err_code(), 1);
var log75 = logger("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var DefaultRegistrar = class {
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this.components.getConnectionManager().addEventListener("peer:disconnect", this._onDisconnect);
    this.components.getPeerStore().addEventListener("change:protocols", this._onProtocolChange);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.topologies.keys(),
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol4) {
    const handler = this.handlers.get(protocol4);
    if (handler == null) {
      throw (0, import_err_code98.default)(new Error(`No handler registered for protocol ${protocol4}`), codes4.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol4) {
    const topologies = this.topologies.get(protocol4);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  async handle(protocol4, handler, opts) {
    if (this.handlers.has(protocol4)) {
      throw (0, import_err_code98.default)(new Error(`Handler already registered for protocol ${protocol4}`), codes4.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol4, {
      handler,
      options
    });
    await this.components.getPeerStore().protoBook.add(this.components.getPeerId(), [protocol4]);
  }
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol4) => {
      this.handlers.delete(protocol4);
    });
    await this.components.getPeerStore().protoBook.remove(this.components.getPeerId(), protocolList);
  }
  async register(protocol4, topology) {
    if (!isTopology(topology)) {
      log75.error("topology must be an instance of interfaces/topology");
      throw (0, import_err_code98.default)(new Error("topology must be an instance of interfaces/topology"), codes4.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol4);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol4, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  unregister(id) {
    for (const [protocol4, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol4);
        }
      }
    }
  }
  _onDisconnect(evt) {
    const connection = evt.detail;
    void this.components.getPeerStore().protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol4 of peerProtocols) {
        const topologies = this.topologies.get(protocol4);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(connection.remotePeer);
        }
      }
    }).catch((err2) => {
      log75.error(err2);
    });
  }
  _onProtocolChange(evt) {
    const { peerId, protocols, oldProtocols } = evt.detail;
    const removed = oldProtocols.filter((protocol4) => !protocols.includes(protocol4));
    const added = protocols.filter((protocol4) => !oldProtocols.includes(protocol4));
    for (const protocol4 of removed) {
      const topologies = this.topologies.get(protocol4);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peerId);
      }
    }
    for (const protocol4 of added) {
      const topologies = this.topologies.get(protocol4);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.getConnectionManager().getConnections(peerId)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peerId, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/upgrader.js
var import_timeout_abort_controller7 = __toESM(require_timeout_abort_controller(), 1);
var import_events19 = __toESM(require_events(), 1);
var log76 = logger("libp2p:upgrader");
function findIncomingStreamLimit(protocol4, registrar) {
  try {
    const { options } = registrar.getHandler(protocol4);
    return options.maxInboundStreams;
  } catch (err2) {
    if (err2.code !== codes4.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol4, registrar) {
  try {
    const { options } = registrar.getHandler(protocol4);
    return options.maxOutboundStreams;
  } catch (err2) {
    if (err2.code !== codes4.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol4, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.stat.direction === direction && stream.stat.protocol === protocol4) {
      streamCount++;
    }
  });
  return streamCount;
}
var DefaultUpgrader = class extends EventEmitter2 {
  constructor(components, init) {
    super();
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;
  }
  async upgradeInbound(maConn) {
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.getMetrics();
    const timeoutController = new import_timeout_abort_controller7.TimeoutController(this.inboundUpgradeTimeout);
    try {
      (0, import_events19.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, timeoutController.signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.getConnectionGater().denyInboundConnection(maConn)) {
        throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
        const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
        setPeer({ toString: () => idString });
        metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
      }
      log76("starting the inbound connection upgrade");
      let protectedConn = maConn;
      const protector = this.components.getConnectionProtector();
      if (protector != null) {
        log76("protecting the inbound connection");
        protectedConn = await protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptInbound(protectedConn));
        if (await this.components.getConnectionGater().denyInboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err2) {
        log76.error("Failed to upgrade inbound connection", err2);
        await maConn.close(err2);
        throw err2;
      }
      if (await this.components.getConnectionGater().denyInboundUpgradedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log76("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      timeoutController.clear();
    }
  }
  async upgradeOutbound(maConn) {
    const idStr = maConn.remoteAddr.getPeerId();
    if (idStr == null) {
      throw (0, import_err_code99.default)(new Error("outbound connection must have a peer id"), codes4.ERR_INVALID_MULTIADDR);
    }
    const remotePeerId = peerIdFromString(idStr);
    if (await this.components.getConnectionGater().denyOutboundConnection(remotePeerId, maConn)) {
      throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.getMetrics();
    if (metrics != null) {
      ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
      const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      setPeer({ toB58String: () => idString });
      metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
    }
    log76("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    const protector = this.components.getConnectionProtector();
    if (protector != null) {
      protectedConn = await protector.protect(maConn);
    }
    try {
      ({
        conn: encryptedConn,
        remotePeer,
        protocol: cryptoProtocol
      } = await this._encryptOutbound(protectedConn, remotePeerId));
      if (await this.components.getConnectionGater().denyOutboundEncryptedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
      if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      } else {
        upgradedConn = encryptedConn;
      }
    } catch (err2) {
      log76.error("Failed to upgrade outbound connection", err2);
      await maConn.close(err2);
      throw err2;
    }
    if (await this.components.getConnectionGater().denyOutboundUpgradedConnection(remotePeer, {
      ...protectedConn,
      ...encryptedConn
    })) {
      throw (0, import_err_code99.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
    }
    if (metrics != null) {
      metrics.updatePlaceholder(proxyPeer, remotePeer);
      setPeer(remotePeer);
    }
    log76("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.getRegistrar().getProtocols();
            const { stream, protocol: protocol4 } = await handle(muxedStream, protocols);
            log76("%s: incoming stream opened on %s", direction, protocol4);
            const metrics = this.components.getMetrics();
            if (metrics != null) {
              metrics.trackStream({ stream, remotePeer, protocol: protocol4 });
            }
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol4, this.components.getRegistrar());
            const streamCount = countStreams(protocol4, "inbound", connection);
            if (streamCount === incomingLimit) {
              muxedStream.abort((0, import_err_code99.default)(new Error(`Too many inbound protocol streams for protocol "${protocol4}" - limit ${incomingLimit}`), codes4.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));
              return;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.stat.protocol = protocol4;
            this.components.getPeerStore().protoBook.add(remotePeer, [protocol4]).catch((err2) => log76.error(err2));
            connection.addStream(muxedStream);
            this._onStream({ connection, stream: muxedStream, protocol: protocol4 });
          }).catch((err2) => {
            log76.error(err2);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      if (isInitializable(muxer)) {
        muxer.init(this.components);
      }
      newStream = async (protocols, options = {}) => {
        if (muxer == null) {
          throw (0, import_err_code99.default)(new Error("Stream is not multiplexed"), codes4.ERR_MUXER_UNAVAILABLE);
        }
        log76("%s: starting new stream on %s", direction, protocols);
        const muxedStream = muxer.newStream();
        const metrics = this.components.getMetrics();
        let controller;
        try {
          if (options.signal == null) {
            log76("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            controller = new import_timeout_abort_controller7.TimeoutController(3e4);
            options.signal = controller.signal;
            try {
              (0, import_events19.setMaxListeners)?.(Infinity, controller.signal);
            } catch {
            }
          }
          const { stream, protocol: protocol4 } = await select(muxedStream, protocols, options);
          if (metrics != null) {
            metrics.trackStream({ stream, remotePeer, protocol: protocol4 });
          }
          const outgoingLimit = findOutgoingStreamLimit(protocol4, this.components.getRegistrar());
          const streamCount = countStreams(protocol4, "outbound", connection);
          if (streamCount === outgoingLimit) {
            const err2 = (0, import_err_code99.default)(new Error(`Too many outbound protocol streams for protocol "${protocol4}" - limit ${outgoingLimit}`), codes4.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err2);
            throw err2;
          }
          this.components.getPeerStore().protoBook.add(remotePeer, [protocol4]).catch((err2) => log76.error(err2));
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.stat.protocol = protocol4;
          return muxedStream;
        } catch (err2) {
          log76.error("could not create new stream", err2);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err2.code != null) {
            throw err2;
          }
          throw (0, import_err_code99.default)(err2, codes4.ERR_UNSUPPORTED_PROTOCOL);
        } finally {
          if (controller != null) {
            controller.clear();
          }
        }
      };
      pipe(upgradedConn, muxer, upgradedConn).catch(log76.error);
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err2) {
              log76.error(err2);
            } finally {
              this.dispatchEvent(new CustomEvent("connectionEnd", {
                detail: connection
              }));
            }
          })().catch((err2) => {
            log76.error(err2);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw (0, import_err_code99.default)(new Error("connection is not multiplexed"), codes4.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.dispatchEvent(new CustomEvent("connection", {
      detail: connection
    }));
    return connection;
  }
  _onStream(opts) {
    const { connection, stream, protocol: protocol4 } = opts;
    const { handler } = this.components.getRegistrar().getHandler(protocol4);
    handler({ connection, stream });
  }
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log76("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol: protocol4 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol4);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol4}`);
      }
      log76("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.getPeerId(), stream),
        protocol: protocol4
      };
    } catch (err2) {
      throw (0, import_err_code99.default)(err2, codes4.ERR_ENCRYPTION_FAILED);
    }
  }
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log76("selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol: protocol4 } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol4);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol4}`);
      }
      log76("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.getPeerId(), stream, remotePeerId),
        protocol: protocol4
      };
    } catch (err2) {
      throw (0, import_err_code99.default)(err2, codes4.ERR_ENCRYPTION_FAILED);
    }
  }
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log76("outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol: protocol4 } = await select(connection, protocols, {
        writeBytes: true
      });
      log76("%s selected as muxer protocol", protocol4);
      const muxerFactory = muxers.get(protocol4);
      return { stream, muxerFactory };
    } catch (err2) {
      log76.error("error multiplexing outbound stream", err2);
      throw (0, import_err_code99.default)(err2, codes4.ERR_MUXER_UNAVAILABLE);
    }
  }
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log76("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol: protocol4 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol4);
      return { stream, muxerFactory };
    } catch (err2) {
      log76.error("error multiplexing inbound stream", err2);
      throw (0, import_err_code99.default)(err2, codes4.ERR_MUXER_UNAVAILABLE);
    }
  }
};

// node_modules/libp2p/dist/src/identify/index.js
var import_err_code100 = __toESM(require_err_code(), 1);
var import_it_drain12 = __toESM(require_it_drain(), 1);
var import_it_first6 = __toESM(require_it_first(), 1);

// node_modules/libp2p/dist/src/identify/pb/message.js
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.protocolVersion != null) {
          writer5.uint32(42);
          writer5.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          writer5.uint32(50);
          writer5.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          writer5.uint32(10);
          writer5.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value2 of obj.listenAddrs) {
            writer5.uint32(18);
            writer5.bytes(value2);
          }
        } else {
          throw new Error('Protocol error: required field "listenAddrs" was not found in object');
        }
        if (obj.observedAddr != null) {
          writer5.uint32(34);
          writer5.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            writer5.uint32(26);
            writer5.string(value2);
          }
        } else {
          throw new Error('Protocol error: required field "protocols" was not found in object');
        }
        if (obj.signedPeerRecord != null) {
          writer5.uint32(66);
          writer5.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader6.string();
              break;
            case 6:
              obj.agentVersion = reader6.string();
              break;
            case 1:
              obj.publicKey = reader6.bytes();
              break;
            case 2:
              obj.listenAddrs = obj.listenAddrs ?? [];
              obj.listenAddrs.push(reader6.bytes());
              break;
            case 4:
              obj.observedAddr = reader6.bytes();
              break;
            case 3:
              obj.protocols = obj.protocols ?? [];
              obj.protocols.push(reader6.string());
              break;
            case 8:
              obj.signedPeerRecord = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        obj.listenAddrs = obj.listenAddrs ?? [];
        obj.protocols = obj.protocols ?? [];
        if (obj.listenAddrs == null) {
          throw new Error('Protocol error: value for required field "listenAddrs" was not found in protobuf');
        }
        if (obj.protocols == null) {
          throw new Error('Protocol error: value for required field "protocols" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage2(obj, Identify2.codec());
  };
  Identify2.decode = (buf2) => {
    return decodeMessage2(buf2, Identify2.codec());
  };
})(Identify || (Identify = {}));

// node_modules/libp2p/dist/src/version.js
var version3 = "0.0.0";
var name18 = "libp2p";

// node_modules/libp2p/dist/src/identify/consts.js
var AGENT_VERSION = `js-libp2p/${version3}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// node_modules/libp2p/dist/src/identify/index.js
var import_timeout_abort_controller8 = __toESM(require_timeout_abort_controller(), 1);
var import_events20 = __toESM(require_events(), 1);
var log77 = logger("libp2p:identify");
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var IdentifyService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.init = init;
    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.host = {
      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      ...init.host
    };
    this.components.getConnectionManager().addEventListener("peer:connect", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch(log77.error);
    });
    this.components.getPeerStore().addEventListener("change:multiaddrs", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.getPeerId().equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log77.error(err2));
      }
    });
    this.components.getPeerStore().addEventListener("change:protocols", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.getPeerId().equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log77.error(err2));
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "AgentVersion", fromString3(this.host.agentVersion));
    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "ProtocolVersion", fromString3(this.host.protocolVersion));
    await this.components.getRegistrar().handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err2) => {
        log77.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    await this.components.getRegistrar().handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err2) => {
        log77.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxPushIncomingStreams,
      maxOutboundStreams: this.init.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.identifyProtocolStr);
    await this.components.getRegistrar().unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  async push(connections) {
    const signedPeerRecord = await this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId());
    const listenAddrs = this.components.getAddressManager().getAddresses().map((ma) => ma.bytes);
    const protocols = await this.components.getPeerStore().protoBook.get(this.components.getPeerId());
    const pushes = connections.map(async (connection) => {
      let stream;
      const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      try {
        (0, import_events20.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal: timeoutController.signal
        });
        const source = abortableDuplex(stream, timeoutController.signal);
        await pipe([Identify.encode({
          listenAddrs,
          signedPeerRecord,
          protocols
        })], encode52(), source, import_it_drain12.default);
      } catch (err2) {
        log77.error("could not push identify update to peer", err2);
      } finally {
        if (stream != null) {
          stream.close();
        }
        timeoutController.clear();
      }
    });
    await Promise.all(pushes);
  }
  async pushToPeerStore() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    for (const conn of this.components.getConnectionManager().getConnections()) {
      const peerId = conn.remotePeer;
      const peer = await this.components.getPeerStore().get(peerId);
      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
        continue;
      }
      connections.push(conn);
    }
    await this.push(connections);
  }
  async _identify(connection, options = {}) {
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events20.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const data = await pipe([], source, decode62({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await (0, import_it_first6.default)(source2));
      if (data == null) {
        throw (0, import_err_code100.default)(new Error("No data could be retrieved"), codes4.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err2) {
        throw (0, import_err_code100.default)(err2, codes4.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async identify(connection, options = {}) {
    const message6 = await this._identify(connection, options);
    const { publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, agentVersion, protocolVersion } = message6;
    if (publicKey == null) {
      throw (0, import_err_code100.default)(new Error("public key was missing from identify message"), codes4.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw (0, import_err_code100.default)(new Error("identified peer does not match the expected peer"), codes4.ERR_INVALID_PEER);
    }
    if (this.components.getPeerId().equals(id)) {
      throw (0, import_err_code100.default)(new Error("identified peer is our own peer id?"), codes4.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
    if (signedPeerRecord != null) {
      log77("received signed peer record from %p", id);
      try {
        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord3.DOMAIN);
        if (!envelope.peerId.equals(id)) {
          throw (0, import_err_code100.default)(new Error("identified peer does not match the expected peer"), codes4.ERR_INVALID_PEER);
        }
        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          await this.components.getPeerStore().protoBook.set(id, protocols);
          if (agentVersion != null) {
            await this.components.getPeerStore().metadataBook.setValue(id, "AgentVersion", fromString3(agentVersion));
          }
          if (protocolVersion != null) {
            await this.components.getPeerStore().metadataBook.setValue(id, "ProtocolVersion", fromString3(protocolVersion));
          }
          log77("identify completed for peer %p and protocols %o", id, protocols);
          return;
        }
      } catch (err2) {
        log77("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log77("no signed peer record received from %p", id);
    }
    log77("falling back to legacy addresses from %p", id);
    try {
      await this.components.getPeerStore().addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log77.error("received invalid addrs", err2);
    }
    await this.components.getPeerStore().protoBook.set(id, protocols);
    if (agentVersion != null) {
      await this.components.getPeerStore().metadataBook.setValue(id, "AgentVersion", fromString3(agentVersion));
    }
    if (protocolVersion != null) {
      await this.components.getPeerStore().metadataBook.setValue(id, "ProtocolVersion", fromString3(protocolVersion));
    }
    log77("identify completed for peer %p and protocols %o", id, protocols);
    log77("received observed address of %s", cleanObservedAddr?.toString());
  }
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events20.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const publicKey = this.components.getPeerId().publicKey ?? new Uint8Array(0);
      const peerData = await this.components.getPeerStore().get(this.components.getPeerId());
      const multiaddrs = this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord3({
          peerId: this.components.getPeerId(),
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId());
        await this.components.getPeerStore().addressBook.consumePeerRecord(envelope);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message6 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source = abortableDuplex(stream, timeoutController.signal);
      await pipe([message6], encode52(), source, import_it_drain12.default);
    } catch (err2) {
      log77.error("could not respond to identify request", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
  }
  async _handlePush(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events20.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    let message6;
    try {
      const source = abortableDuplex(stream, timeoutController.signal);
      const data2 = await pipe([], source, decode62({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await (0, import_it_first6.default)(source2));
      if (data2 != null) {
        message6 = Identify.decode(data2);
      }
    } catch (err2) {
      return log77.error("received invalid message", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
    if (message6 == null) {
      return log77.error("received invalid message");
    }
    const id = connection.remotePeer;
    if (this.components.getPeerId().equals(id)) {
      log77("received push from ourselves?");
      return;
    }
    log77("received push from %p", id);
    if (message6.signedPeerRecord != null) {
      log77("received signedPeerRecord in push");
      try {
        const envelope = await RecordEnvelope.openAndCertify(message6.signedPeerRecord, PeerRecord3.DOMAIN);
        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          log77("consumed signedPeerRecord sent in push");
          await this.components.getPeerStore().protoBook.set(id, message6.protocols);
          return;
        } else {
          log77("failed to consume signedPeerRecord sent in push");
        }
      } catch (err2) {
        log77("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log77("did not receive signedPeerRecord in push");
    }
    try {
      await this.components.getPeerStore().addressBook.set(id, message6.listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log77.error("received invalid addrs", err2);
    }
    try {
      await this.components.getPeerStore().protoBook.set(id, message6.protocols);
    } catch (err2) {
      log77.error("received invalid protocols", err2);
    }
    log77("handled push from %p", id);
  }
  static getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
};

// node_modules/libp2p/dist/src/fetch/index.js
var import_err_code101 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/fetch/pb/proto.js
var FetchRequest;
(function(FetchRequest2) {
  let _codec;
  FetchRequest2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.identifier != null) {
          writer5.uint32(10);
          writer5.string(obj.identifier);
        } else {
          throw new Error('Protocol error: required field "identifier" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identifier = reader6.string();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        if (obj.identifier == null) {
          throw new Error('Protocol error: value for required field "identifier" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchRequest2.encode = (obj) => {
    return encodeMessage2(obj, FetchRequest2.codec());
  };
  FetchRequest2.decode = (buf2) => {
    return decodeMessage2(buf2, FetchRequest2.codec());
  };
})(FetchRequest || (FetchRequest = {}));
var FetchResponse;
(function(FetchResponse2) {
  let StatusCode;
  (function(StatusCode2) {
    StatusCode2["OK"] = "OK";
    StatusCode2["NOT_FOUND"] = "NOT_FOUND";
    StatusCode2["ERROR"] = "ERROR";
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let __StatusCodeValues;
  (function(__StatusCodeValues2) {
    __StatusCodeValues2[__StatusCodeValues2["OK"] = 0] = "OK";
    __StatusCodeValues2[__StatusCodeValues2["NOT_FOUND"] = 1] = "NOT_FOUND";
    __StatusCodeValues2[__StatusCodeValues2["ERROR"] = 2] = "ERROR";
  })(__StatusCodeValues || (__StatusCodeValues = {}));
  (function(StatusCode2) {
    StatusCode2.codec = () => {
      return enumeration2(__StatusCodeValues);
    };
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let _codec;
  FetchResponse2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.status != null) {
          writer5.uint32(8);
          FetchResponse2.StatusCode.codec().encode(obj.status, writer5);
        } else {
          throw new Error('Protocol error: required field "status" was not found in object');
        }
        if (obj.data != null) {
          writer5.uint32(18);
          writer5.bytes(obj.data);
        } else {
          throw new Error('Protocol error: required field "data" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.status = FetchResponse2.StatusCode.codec().decode(reader6);
              break;
            case 2:
              obj.data = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        if (obj.status == null) {
          throw new Error('Protocol error: value for required field "status" was not found in protobuf');
        }
        if (obj.data == null) {
          throw new Error('Protocol error: value for required field "data" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchResponse2.encode = (obj) => {
    return encodeMessage2(obj, FetchResponse2.codec());
  };
  FetchResponse2.decode = (buf2) => {
    return decodeMessage2(buf2, FetchResponse2.codec());
  };
})(FetchResponse || (FetchResponse = {}));

// node_modules/libp2p/dist/src/fetch/constants.js
var PROTOCOL_VERSION = "0.0.1";
var PROTOCOL_NAME = "fetch";

// node_modules/libp2p/dist/src/fetch/index.js
var import_it_first7 = __toESM(require_it_first(), 1);
var import_timeout_abort_controller9 = __toESM(require_timeout_abort_controller(), 1);
var import_events21 = __toESM(require_events(), 1);
var log78 = logger("libp2p:fetch");
var FetchService = class {
  constructor(components, init) {
    this.started = false;
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? "libp2p"}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.lookupFunctions = /* @__PURE__ */ new Map();
    this.handleMessage = this.handleMessage.bind(this);
    this.init = init;
  }
  async start() {
    await this.components.getRegistrar().handle(this.protocol, (data) => {
      void this.handleMessage(data).catch((err2) => {
        log78.error(err2);
      }).finally(() => {
        data.stream.close();
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async fetch(peer, key, options = {}) {
    log78("dialing %s to %p", this.protocol, peer);
    const connection = await this.components.getConnectionManager().openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller9.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events21.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([FetchRequest.encode({ identifier: key })], encode52(), source, decode62(), async function(source2) {
        const buf2 = await (0, import_it_first7.default)(source2);
        if (buf2 == null) {
          throw (0, import_err_code101.default)(new Error("No data received"), codes4.ERR_INVALID_MESSAGE);
        }
        const response = FetchResponse.decode(buf2);
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            const errmsg = new TextDecoder().decode(response.data);
            throw (0, import_err_code101.default)(new Error("Error in fetch protocol response: " + errmsg), codes4.ERR_INVALID_PARAMETERS);
          }
          default: {
            throw (0, import_err_code101.default)(new Error("Unknown response status"), codes4.ERR_INVALID_MESSAGE);
          }
        }
      });
      return result ?? null;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async handleMessage(data) {
    const { stream } = data;
    const self2 = this;
    await pipe(stream, decode62(), async function* (source) {
      const buf2 = await (0, import_it_first7.default)(source);
      if (buf2 == null) {
        throw (0, import_err_code101.default)(new Error("No data received"), codes4.ERR_INVALID_MESSAGE);
      }
      const request2 = FetchRequest.decode(buf2);
      let response;
      const lookup3 = self2._getLookupFunction(request2.identifier);
      if (lookup3 != null) {
        const data2 = await lookup3(request2.identifier);
        if (data2 != null) {
          response = { status: FetchResponse.StatusCode.OK, data: data2 };
        } else {
          response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
        }
      } else {
        const errmsg = new TextEncoder().encode("No lookup function registered for key: " + request2.identifier);
        response = { status: FetchResponse.StatusCode.ERROR, data: errmsg };
      }
      yield FetchResponse.encode(response);
    }, encode52(), stream);
  }
  _getLookupFunction(key) {
    for (const prefix of this.lookupFunctions.keys()) {
      if (key.startsWith(prefix)) {
        return this.lookupFunctions.get(prefix);
      }
    }
  }
  registerLookupFunction(prefix, lookup3) {
    if (this.lookupFunctions.has(prefix)) {
      throw (0, import_err_code101.default)(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    this.lookupFunctions.set(prefix, lookup3);
  }
  unregisterLookupFunction(prefix, lookup3) {
    if (lookup3 != null) {
      const existingLookup = this.lookupFunctions.get(prefix);
      if (existingLookup !== lookup3) {
        return;
      }
    }
    this.lookupFunctions.delete(prefix);
  }
};

// node_modules/libp2p/dist/src/ping/index.js
var import_err_code102 = __toESM(require_err_code(), 1);
var import_it_first8 = __toESM(require_it_first(), 1);

// node_modules/libp2p/dist/src/ping/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";

// node_modules/libp2p/dist/src/ping/index.js
var import_timeout_abort_controller10 = __toESM(require_timeout_abort_controller(), 1);
var import_events22 = __toESM(require_events(), 1);
var log79 = logger("libp2p:ping");
var PingService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.init = init;
  }
  async start() {
    await this.components.getRegistrar().handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  handleMessage(data) {
    const { stream } = data;
    void pipe(stream, stream).catch((err2) => {
      log79.error(err2);
    });
  }
  async ping(peer, options = {}) {
    log79("dialing %s to %p", this.protocol, peer);
    const start = Date.now();
    const data = randomBytes(PING_LENGTH);
    const connection = await this.components.getConnectionManager().openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller10.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events22.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([data], source, async (source2) => await (0, import_it_first8.default)(source2));
      const end = Date.now();
      if (result == null || !equals15(data, result.subarray())) {
        throw (0, import_err_code102.default)(new Error("Received wrong ping ack"), codes4.ERR_WRONG_PING_ACK);
      }
      return end - start;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
};

// node_modules/@achingbrain/nat-port-mapper/dist/src/browser.js
async function upnpNat() {
  throw new Error("Not supported in browsers");
}

// node_modules/wherearewe/src/index.js
var import_is_electron = __toESM(require_is_electron());
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser3 = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode2 = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker2 = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative2 = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/libp2p/dist/src/nat-manager.js
var import_private_ip2 = __toESM(require_private_ip(), 1);
var import_err_code103 = __toESM(require_err_code(), 1);

// node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// node_modules/libp2p/dist/src/nat-manager.js
var log80 = logger("libp2p:nat");
var DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
var NatManager = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.enabled = init.enabled;
    this.externalAddress = init.externalAddress;
    this.localAddress = init.localAddress;
    this.description = init.description ?? `${name18}@${version3} ${this.components.getPeerId().toString()}`;
    this.ttl = init.ttl ?? DEFAULT_TTL;
    this.keepAlive = init.keepAlive ?? true;
    this.gateway = init.gateway;
    if (this.ttl < DEFAULT_TTL) {
      throw (0, import_err_code103.default)(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes4.ERR_INVALID_PARAMETERS);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
  }
  afterStart() {
    if (isBrowser3 || !this.enabled || this.started) {
      return;
    }
    this.started = true;
    void this._start().catch((err2) => {
      log80.error(err2);
    });
  }
  async _start() {
    const addrs = this.components.getTransportManager().getAddrs();
    for (const addr of addrs) {
      const { family, host, port, transport } = addr.toOptions();
      if (!addr.isThinWaistAddress() || transport !== "tcp") {
        continue;
      }
      if (isLoopback(addr)) {
        continue;
      }
      if (family !== 4) {
        continue;
      }
      const client = await this._getClient();
      const publicIp = this.externalAddress ?? await client.externalIp();
      if ((0, import_private_ip2.default)(publicIp)) {
        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
      }
      const publicPort = highPort();
      log80(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
      await client.map({
        publicPort,
        localPort: port,
        localAddress: this.localAddress,
        protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
      });
      this.components.getAddressManager().addObservedAddr(fromNodeAddress({
        family: 4,
        address: publicIp,
        port: publicPort
      }, transport));
    }
  }
  async _getClient() {
    if (this.client != null) {
      return this.client;
    }
    this.client = await upnpNat({
      description: this.description,
      ttl: this.ttl,
      keepAlive: this.keepAlive,
      gateway: this.gateway
    });
    return this.client;
  }
  async stop() {
    if (isBrowser3 || this.client == null) {
      return;
    }
    try {
      await this.client.close();
      this.client = void 0;
    } catch (err2) {
      log80.error(err2);
    }
  }
};

// node_modules/libp2p/dist/src/peer-record-updater.js
var log81 = logger("libp2p:peer-record-updater");
var PeerRecordUpdater = class {
  constructor(components) {
    this.components = components;
    this.started = false;
    this.update = this.update.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
    this.components.getTransportManager().addEventListener("listener:listening", this.update);
    this.components.getTransportManager().addEventListener("listener:close", this.update);
    this.components.getAddressManager().addEventListener("change:addresses", this.update);
  }
  async stop() {
    this.started = false;
    this.components.getTransportManager().removeEventListener("listener:listening", this.update);
    this.components.getTransportManager().removeEventListener("listener:close", this.update);
    this.components.getAddressManager().removeEventListener("change:addresses", this.update);
  }
  update() {
    Promise.resolve().then(async () => {
      const peerRecord = new PeerRecord3({
        peerId: this.components.getPeerId(),
        multiaddrs: this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId());
      await this.components.getPeerStore().addressBook.consumePeerRecord(envelope);
    }).catch((err2) => {
      log81.error("Could not update self peer record: %o", err2);
    });
  }
};

// node_modules/libp2p/dist/src/dht/dht-peer-routing.js
var import_err_code104 = __toESM(require_err_code(), 1);
var DHTPeerRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw (0, import_err_code104.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/address-book.js
var import_err_code105 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-store/dist/src/errors.js
var codes5 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
  ERR_NOT_FOUND: "ERR_NOT_FOUND"
};

// node_modules/@libp2p/peer-store/dist/src/address-book.js
var import_it_all9 = __toESM(require_it_all(), 1);
var import_it_filter11 = __toESM(require_it_filter(), 1);
var import_it_map13 = __toESM(require_it_map(), 1);
var import_it_foreach2 = __toESM(require_it_foreach(), 1);
var log82 = logger("libp2p:peer-store:address-book");
var EVENT_NAME = "change:multiaddrs";
async function allowAll() {
  return true;
}
var PeerStoreAddressBook = class {
  constructor(dispatchEvent, store, addressFilter) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
    this.addressFilter = addressFilter ?? allowAll;
  }
  async consumePeerRecord(envelope) {
    log82.trace("consumePeerRecord await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("consumePeerRecord got write lock");
    let peerId;
    let peer;
    let updatedPeer;
    try {
      let peerRecord;
      try {
        peerRecord = PeerRecord3.createFromProtobuf(envelope.payload);
      } catch (err2) {
        log82.error("invalid peer record received");
        return false;
      }
      peerId = peerRecord.peerId;
      const multiaddrs = peerRecord.multiaddrs;
      if (!peerId.equals(envelope.peerId)) {
        log82("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (multiaddrs == null || multiaddrs.length === 0) {
        return false;
      }
      if (await this.store.has(peerId)) {
        peer = await this.store.load(peerId);
        if (peer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
          const storedRecord = PeerRecord3.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log82("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            return false;
          }
        }
      }
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);
      updatedPeer = await this.store.patchOrCreate(peerId, {
        addresses,
        peerRecordEnvelope: envelope.marshal().subarray()
      });
      log82("stored provided peer record for %p", peerRecord.peerId);
    } finally {
      log82.trace("consumePeerRecord release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    return true;
  }
  async getRawEnvelope(peerId) {
    log82.trace("getRawEnvelope await read lock");
    const release = await this.store.lock.readLock();
    log82.trace("getRawEnvelope got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.peerRecordEnvelope;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log82.trace("getRawEnvelope release read lock");
      release();
    }
  }
  async getPeerRecord(peerId) {
    const raw = await this.getRawEnvelope(peerId);
    if (raw == null) {
      return void 0;
    }
    return await RecordEnvelope.createFromProtobuf(raw);
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log82.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log82.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.addresses;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log82.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log82.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code105.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes5.ERR_INVALID_PARAMETERS);
    }
    log82.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("set got write lock");
    let hasPeer = false;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, { addresses });
      log82("set multiaddrs for %p", peerId);
    } finally {
      log82.trace("set multiaddrs for %p", peerId);
      log82("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (!hasPeer) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async add(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log82.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code105.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes5.ERR_INVALID_PARAMETERS);
    }
    log82.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("add got write lock");
    let hasPeer;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses });
      log82("added multiaddrs for %p", peerId);
    } finally {
      log82.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (hasPeer === true) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log82.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        addresses: []
      });
    } finally {
      log82.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME, {
        detail: {
          peerId,
          multiaddrs: [],
          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        }
      }));
    }
  }
};
async function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
  return await pipe(multiaddrs, (source) => (0, import_it_foreach2.default)(source, (multiaddr2) => {
    if (!isMultiaddr(multiaddr2)) {
      log82.error("multiaddr must be an instance of Multiaddr");
      throw (0, import_err_code105.default)(new Error("multiaddr must be an instance of Multiaddr"), codes5.ERR_INVALID_PARAMETERS);
    }
  }), (source) => (0, import_it_filter11.default)(source, async (multiaddr2) => await addressFilter(peerId, multiaddr2)), (source) => (0, import_it_map13.default)(source, (multiaddr2) => {
    return {
      multiaddr: multiaddr2,
      isCertified
    };
  }), async (source) => await (0, import_it_all9.default)(source));
}

// node_modules/@libp2p/peer-store/dist/src/key-book.js
var import_err_code106 = __toESM(require_err_code(), 1);
var log83 = logger("libp2p:peer-store:key-book");
var EVENT_NAME2 = "change:pubkey";
var PeerStoreKeyBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async set(peerId, publicKey) {
    peerId = peerIdFromPeerId(peerId);
    if (!(publicKey instanceof Uint8Array)) {
      log83.error("publicKey must be an instance of Uint8Array to store data");
      throw (0, import_err_code106.default)(new Error("publicKey must be an instance of PublicKey"), codes5.ERR_INVALID_PARAMETERS);
    }
    log83.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log83.trace("set got write lock");
    let updatedKey = false;
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
        if (peer.pubKey != null && equals15(peer.pubKey, publicKey)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: publicKey
      });
      updatedKey = true;
    } finally {
      log83.trace("set release write lock");
      release();
    }
    if (updatedKey) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
        detail: {
          peerId,
          publicKey,
          oldPublicKey: peer == null ? void 0 : peer.pubKey
        }
      }));
    }
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log83.trace("get await write lock");
    const release = await this.store.lock.readLock();
    log83.trace("get got write lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.pubKey;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log83("get release write lock");
      release();
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log83.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log83.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: void 0
      });
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log83.trace("delete release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
      detail: {
        peerId,
        publicKey: void 0,
        oldPublicKey: peer == null ? void 0 : peer.pubKey
      }
    }));
  }
};

// node_modules/@libp2p/peer-store/dist/src/metadata-book.js
var import_err_code107 = __toESM(require_err_code(), 1);
var log84 = logger("libp2p:peer-store:metadata-book");
var EVENT_NAME3 = "change:metadata";
var PeerStoreMetadataBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log84.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("get release read lock");
      release();
    }
    return /* @__PURE__ */ new Map();
  }
  async getValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("getValue await read lock");
    const release = await this.store.lock.readLock();
    log84.trace("getValue got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata.get(key);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("getValue release write lock");
      release();
    }
  }
  async set(peerId, metadata) {
    peerId = peerIdFromPeerId(peerId);
    if (!(metadata instanceof Map)) {
      log84.error("valid metadata must be provided to store data");
      throw (0, import_err_code107.default)(new Error("valid metadata must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log84.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("set got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.mergeOrCreate(peerId, {
        metadata
      });
    } finally {
      log84.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async setValue(peerId, key, value2) {
    peerId = peerIdFromPeerId(peerId);
    if (typeof key !== "string" || !(value2 instanceof Uint8Array)) {
      log84.error("valid key and value must be provided to store data");
      throw (0, import_err_code107.default)(new Error("valid key and value must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log84.trace("setValue await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("setValue got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const existingValue = peer.metadata.get(key);
        if (existingValue != null && equals15(value2, existingValue)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        metadata: /* @__PURE__ */ new Map([[key, value2]])
      });
    } finally {
      log84.trace("setValue release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata: updatedPeer.metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      if (peer != null) {
        await this.store.patch(peerId, {
          metadata: /* @__PURE__ */ new Map()
        });
      }
    } finally {
      log84.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata: /* @__PURE__ */ new Map(),
          oldMetadata: peer.metadata
        }
      }));
    }
  }
  async deleteValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("deleteValue await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("deleteValue got write lock");
    let metadata;
    let peer;
    try {
      peer = await this.store.load(peerId);
      metadata = peer.metadata;
      metadata.delete(key);
      await this.store.patch(peerId, {
        metadata
      });
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("deleteValue release write lock");
      release();
    }
    if (metadata != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata,
          oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
        }
      }));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/proto-book.js
var import_err_code108 = __toESM(require_err_code(), 1);
var log85 = logger("libp2p:peer-store:proto-book");
var EVENT_NAME4 = "change:protocols";
var PeerStoreProtoBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    log85.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log85.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.protocols;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log85.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code108.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("set got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
      log85("stored provided protocols for %p", peerId);
    } finally {
      log85.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async add(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code108.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("add got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...peer.protocols,
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        protocols
      });
      log85("added provided protocols for %p", peerId);
    } finally {
      log85.trace("add release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async remove(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code108.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("remove await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("remove got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const protocolSet = new Set(peer.protocols);
        for (const protocol4 of protocols) {
          protocolSet.delete(protocol4);
        }
        if (peer.protocols.length === protocolSet.size) {
          return;
        }
        protocols = Array.from(protocolSet);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
    } finally {
      log85.trace("remove release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log85.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        protocols: []
      });
    } finally {
      log85.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
        detail: {
          peerId,
          protocols: [],
          oldProtocols: peer.protocols
        }
      }));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/store.js
var import_err_code109 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer2;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            writer5.uint32(10);
            Address2.codec().encode(value2, writer5);
          }
        } else {
          throw new Error('Protocol error: required field "addresses" was not found in object');
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            writer5.uint32(18);
            writer5.string(value2);
          }
        } else {
          throw new Error('Protocol error: required field "protocols" was not found in object');
        }
        if (obj.metadata != null) {
          for (const value2 of obj.metadata) {
            writer5.uint32(26);
            Metadata3.codec().encode(value2, writer5);
          }
        } else {
          throw new Error('Protocol error: required field "metadata" was not found in object');
        }
        if (obj.pubKey != null) {
          writer5.uint32(34);
          writer5.bytes(obj.pubKey);
        }
        if (obj.peerRecordEnvelope != null) {
          writer5.uint32(42);
          writer5.bytes(obj.peerRecordEnvelope);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: []
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address2.codec().decode(reader6, reader6.uint32()));
              break;
            case 2:
              obj.protocols.push(reader6.string());
              break;
            case 3:
              obj.metadata.push(Metadata3.codec().decode(reader6, reader6.uint32()));
              break;
            case 4:
              obj.pubKey = reader6.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage2(obj, Peer3.codec());
  };
  Peer3.decode = (buf2) => {
    return decodeMessage2(buf2, Peer3.codec());
  };
})(Peer2 || (Peer2 = {}));
var Address2;
(function(Address3) {
  let _codec;
  Address3.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.multiaddr != null) {
          writer5.uint32(10);
          writer5.bytes(obj.multiaddr);
        } else {
          throw new Error('Protocol error: required field "multiaddr" was not found in object');
        }
        if (obj.isCertified != null) {
          writer5.uint32(16);
          writer5.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader6.bytes();
              break;
            case 2:
              obj.isCertified = reader6.bool();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        if (obj.multiaddr == null) {
          throw new Error('Protocol error: value for required field "multiaddr" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Address3.encode = (obj) => {
    return encodeMessage2(obj, Address3.codec());
  };
  Address3.decode = (buf2) => {
    return decodeMessage2(buf2, Address3.codec());
  };
})(Address2 || (Address2 = {}));
var Metadata3;
(function(Metadata4) {
  let _codec;
  Metadata4.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.key != null) {
          writer5.uint32(10);
          writer5.string(obj.key);
        } else {
          throw new Error('Protocol error: required field "key" was not found in object');
        }
        if (obj.value != null) {
          writer5.uint32(18);
          writer5.bytes(obj.value);
        } else {
          throw new Error('Protocol error: required field "value" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          key: "",
          value: new Uint8Array(0)
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader6.string();
              break;
            case 2:
              obj.value = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        if (obj.key == null) {
          throw new Error('Protocol error: value for required field "key" was not found in protobuf');
        }
        if (obj.value == null) {
          throw new Error('Protocol error: value for required field "value" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata4.encode = (obj) => {
    return encodeMessage2(obj, Metadata4.codec());
  };
  Metadata4.decode = (buf2) => {
    return decodeMessage2(buf2, Metadata4.codec());
  };
})(Metadata3 || (Metadata3 = {}));

// node_modules/@libp2p/peer-store/dist/src/store.js
var log86 = logger("libp2p:peer-store:store");
var NAMESPACE_COMMON = "/peers/";
var PersistentStore = class {
  constructor() {
    this.components = new Components();
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  init(components) {
    this.components = components;
  }
  _peerIdToDatastoreKey(peerId) {
    if (peerId.type == null) {
      log86.error("peerId must be an instance of peer-id to store data");
      throw (0, import_err_code109.default)(new Error("peerId must be an instance of peer-id"), codes5.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }
  async has(peerId) {
    return await this.components.getDatastore().has(this._peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    await this.components.getDatastore().delete(this._peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf2 = await this.components.getDatastore().get(this._peerIdToDatastoreKey(peerId));
    const peer = Peer2.decode(buf2);
    const metadata = /* @__PURE__ */ new Map();
    for (const meta of peer.metadata) {
      metadata.set(meta.key, meta.value);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata,
      pubKey: peer.pubKey ?? void 0,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0
    };
  }
  async save(peer) {
    if (peer.pubKey != null && peer.id.publicKey != null && !equals15(peer.pubKey, peer.id.publicKey)) {
      log86.error("peer publicKey bytes do not match peer id publicKey bytes");
      throw (0, import_err_code109.default)(new Error("publicKey bytes do not match peer id publicKey bytes"), codes5.ERR_INVALID_PARAMETERS);
    }
    const addressSet = /* @__PURE__ */ new Set();
    const addresses = peer.addresses.filter((address) => {
      if (addressSet.has(address.multiaddr.toString())) {
        return false;
      }
      addressSet.add(address.multiaddr.toString());
      return true;
    }).sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ multiaddr: multiaddr2, isCertified }) => ({
      multiaddr: multiaddr2.bytes,
      isCertified
    }));
    const metadata = [];
    [...peer.metadata.keys()].sort().forEach((key) => {
      const value2 = peer.metadata.get(key);
      if (value2 != null) {
        metadata.push({ key, value: value2 });
      }
    });
    const buf2 = Peer2.encode({
      addresses,
      protocols: peer.protocols.sort(),
      pubKey: peer.pubKey,
      metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope
    });
    await this.components.getDatastore().put(this._peerIdToDatastoreKey(peer.id), buf2.subarray());
    return await this.load(peer.id);
  }
  async patch(peerId, data) {
    const peer = await this.load(peerId);
    return await this._patch(peerId, data, peer);
  }
  async patchOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._patch(peerId, data, peer);
  }
  async _patch(peerId, data, peer) {
    return await this.save({
      ...peer,
      ...data,
      id: peerId
    });
  }
  async merge(peerId, data) {
    const peer = await this.load(peerId);
    return await this._merge(peerId, data, peer);
  }
  async mergeOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._merge(peerId, data, peer);
  }
  async _merge(peerId, data, peer) {
    const addresses = /* @__PURE__ */ new Map();
    peer.addresses.forEach((addr) => {
      addresses.set(addr.multiaddr.toString(), addr.isCertified);
    });
    (data.addresses ?? []).forEach((addr) => {
      const addrString = addr.multiaddr.toString();
      const isAlreadyCertified = Boolean(addresses.get(addrString));
      const isCertified = isAlreadyCertified || addr.isCertified;
      addresses.set(addrString, isCertified);
    });
    return await this.save({
      id: peerId,
      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
        return {
          multiaddr: multiaddr(addrStr),
          isCertified
        };
      }),
      protocols: Array.from(/* @__PURE__ */ new Set([
        ...peer.protocols ?? [],
        ...data.protocols ?? []
      ])),
      metadata: new Map([
        ...peer.metadata?.entries() ?? [],
        ...data.metadata?.entries() ?? []
      ]),
      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : void 0),
      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : void 0)
    });
  }
  async *all() {
    for await (const key of this.components.getDatastore().queryKeys({
      prefix: NAMESPACE_COMMON
    })) {
      const base32Str = key.toString().split("/")[2];
      const buf2 = base322.decode(base32Str);
      yield this.load(peerIdFromBytes(buf2));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var import_err_code110 = __toESM(require_err_code());

// node_modules/@libp2p/peer-store/dist/src/pb/tags.js
var Tags;
(function(Tags2) {
  let _codec;
  Tags2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.tags != null) {
          for (const value2 of obj.tags) {
            writer5.uint32(10);
            Tag.codec().encode(value2, writer5);
          }
        } else {
          throw new Error('Protocol error: required field "tags" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          tags: []
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.tags.push(Tag.codec().decode(reader6, reader6.uint32()));
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tags2.encode = (obj) => {
    return encodeMessage2(obj, Tags2.codec());
  };
  Tags2.decode = (buf2) => {
    return decodeMessage2(buf2, Tags2.codec());
  };
})(Tags || (Tags = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.name != null) {
          writer5.uint32(10);
          writer5.string(obj.name);
        } else {
          throw new Error('Protocol error: required field "name" was not found in object');
        }
        if (obj.value != null) {
          writer5.uint32(16);
          writer5.uint32(obj.value);
        }
        if (obj.expiry != null) {
          writer5.uint32(24);
          writer5.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          name: ""
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.name = reader6.string();
              break;
            case 2:
              obj.value = reader6.uint32();
              break;
            case 3:
              obj.expiry = reader6.uint64();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        if (obj.name == null) {
          throw new Error('Protocol error: value for required field "name" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage2(obj, Tag2.codec());
  };
  Tag2.decode = (buf2) => {
    return decodeMessage2(buf2, Tag2.codec());
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/index.js
var log87 = logger("libp2p:peer-store");
var PersistentPeerStore = class extends EventEmitter2 {
  constructor(init = {}) {
    super();
    this.components = new Components();
    this.store = new PersistentStore();
    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter);
    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);
    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);
    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);
  }
  init(components) {
    this.components = components;
    this.store.init(components);
  }
  async forEach(fn) {
    log87.trace("getPeers await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("getPeers got read lock");
    try {
      for await (const peer of this.store.all()) {
        if (peer.id.equals(this.components.getPeerId())) {
          continue;
        }
        fn(peer);
      }
    } finally {
      log87.trace("getPeers release read lock");
      release();
    }
  }
  async all() {
    const output = [];
    await this.forEach((peer) => {
      output.push(peer);
    });
    return output;
  }
  async delete(peerId) {
    log87.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log87.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log87.trace("delete release write lock");
      release();
    }
  }
  async get(peerId) {
    log87.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log87.trace("get release read lock");
      release();
    }
  }
  async has(peerId) {
    log87.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log87.trace("has release read lock");
      release();
    }
  }
  async tagPeer(peerId, tag, options = {}) {
    const providedValue = options.value ?? 0;
    const value2 = Math.round(providedValue);
    const ttl2 = options.ttl ?? void 0;
    if (value2 !== providedValue || value2 < 0 || value2 > 100) {
      throw (0, import_err_code110.default)(new Error("Tag value must be between 0-100"), "ERR_TAG_VALUE_OUT_OF_BOUNDS");
    }
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    for (const t of tags) {
      if (t.name === tag) {
        throw (0, import_err_code110.default)(new Error("Peer already tagged"), "ERR_DUPLICATE_TAG");
      }
    }
    tags.push({
      name: tag,
      value: value2,
      expiry: ttl2 == null ? void 0 : BigInt(Date.now() + ttl2)
    });
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async unTagPeer(peerId, tag) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    tags = tags.filter((t) => t.name !== tag);
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async getTags(peerId) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    const now = BigInt(Date.now());
    const unexpiredTags = tags.filter((tag) => tag.expiry == null || tag.expiry > now);
    if (unexpiredTags.length !== tags.length) {
      await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags: unexpiredTags }).subarray());
    }
    return unexpiredTags.map((t) => ({
      name: t.name,
      value: t.value ?? 0
    }));
  }
};

// node_modules/libp2p/dist/src/dht/dht-content-routing.js
var import_it_drain13 = __toESM(require_it_drain(), 1);
var import_err_code111 = __toESM(require_err_code(), 1);
var DHTContentRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid) {
    await (0, import_it_drain13.default)(this.dht.provide(cid));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value2, options) {
    await (0, import_it_drain13.default)(this.dht.put(key, value2, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw (0, import_err_code111.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
};

// node_modules/libp2p/dist/src/connection-manager/dialer/auto-dialer.js
var import_timeout_abort_controller11 = __toESM(require_timeout_abort_controller(), 1);
var import_events28 = __toESM(require_events(), 1);
var log88 = logger("libp2p:dialer:auto-dialer");
var AutoDialer = class {
  constructor(components, init) {
    this.components = components;
    this.enabled = init.enabled;
    this.minConnections = init.minConnections;
    this.dialTimeout = init.dialTimeout;
  }
  handle(evt) {
    const { detail: peer } = evt;
    if (!this.enabled) {
      return;
    }
    const connections = this.components.getConnectionManager().getConnections(peer.id);
    if (connections.length === 0) {
      const minConnections = this.minConnections ?? 0;
      const allConnections = this.components.getConnectionManager().getConnections();
      if (minConnections > allConnections.length) {
        log88("auto-dialing discovered peer %p with timeout %d", peer.id, this.dialTimeout);
        const controller = new import_timeout_abort_controller11.TimeoutController(this.dialTimeout);
        try {
          (0, import_events28.setMaxListeners)?.(Infinity, controller.signal);
        } catch {
        }
        void this.components.getConnectionManager().openConnection(peer.id, {
          signal: controller.signal
        }).catch((err2) => {
          log88.error("could not connect to discovered peer %p with %o", peer.id, err2);
        }).finally(() => {
          controller.clear();
        });
      }
    }
  }
};

// node_modules/dns-over-http-resolver/dist/src/index.js
var import_debug11 = __toESM(require_browser());
var import_receptacle = __toESM(require_receptacle());

// node_modules/native-fetch/esm/src/index.js
var globalFetch = globalThis.fetch;
var globalHeaders = globalThis.Headers;
var globalRequest = globalThis.Request;
var globalResponse = globalThis.Response;

// node_modules/dns-over-http-resolver/dist/src/utils.js
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await globalFetch(resource, {
    headers: new globalHeaders({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}

// node_modules/dns-over-http-resolver/dist/src/index.js
var log89 = Object.assign((0, import_debug11.default)("dns-over-http-resolver"), {
  error: (0, import_debug11.default)("dns-over-http-resolver:error")
});
var Resolver = class {
  constructor(options = {}) {
    this._cache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._TXTcache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  cancel() {
    this._abortControllers.forEach((controller) => controller.abort());
  }
  getServers() {
    return this._servers;
  }
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i2 = newServers.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * i2);
      const temp = newServers[i2];
      newServers[i2] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return await this.resolve4(hostname);
      case "AAAA":
        return await this.resolve6(hostname);
      case "TXT":
        return await this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log89.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log89.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log89.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default2 = Resolver;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dns.browser.js
var dns_browser_default = src_default2;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
var { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new dns_browser_default();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]);
  if (peerId != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId));
  }
  return addresses;
}

// node_modules/libp2p/dist/src/config.js
var import_err_code112 = __toESM(require_err_code(), 1);
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    maxConnections: 300,
    minConnections: 50,
    autoDial: true,
    autoDialInterval: 1e4,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialsPerPeer: MAX_PER_PEER_DIALS,
    dialTimeout: DIAL_TIMEOUT,
    inboundUpgradeTimeout: INBOUND_UPGRADE_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  connectionGater: {},
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  metrics: {
    enabled: false,
    computeThrottleMaxQueueSize: 1e3,
    computeThrottleTimeout: 2e3,
    movingAverageIntervals: [
      60 * 1e3,
      5 * 60 * 1e3,
      15 * 60 * 1e3
    ],
    maxOldPeersRetention: 50
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 1e4
    }
  },
  nat: {
    enabled: true,
    ttl: 7200,
    keepAlive: true
  },
  relay: {
    enabled: true,
    advertise: {
      bootDelay: ADVERTISE_BOOT_DELAY,
      enabled: false,
      ttl: ADVERTISE_TTL
    },
    hop: {
      enabled: false,
      active: false,
      timeout: 3e4
    },
    autoRelay: {
      enabled: false,
      maxListeners: 2
    }
  },
  identify: {
    protocolPrefix: "ipfs",
    host: {
      agentVersion: AGENT_VERSION
    },
    timeout: 6e4,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1
  },
  ping: {
    protocolPrefix: "ipfs",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  },
  fetch: {
    protocolPrefix: "libp2p",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  }
};
function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw (0, import_err_code112.default)(new Error(messages2.ERR_TRANSPORTS_REQUIRED), codes4.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionEncryption == null || resultingOptions.connectionEncryption.length === 0) {
    throw (0, import_err_code112.default)(new Error(messages2.CONN_ENCRYPTION_REQUIRED), codes4.CONN_ENCRYPTION_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw (0, import_err_code112.default)(new Error(messages2.ERR_PROTECTOR_REQUIRED), codes4.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.identify.host.agentVersion === AGENT_VERSION) {
    if (isNode2 || isElectronMain) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
    } else if (isBrowser3 || isWebWorker2 || isElectronRenderer || isReactNative2) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
    }
  }
  return resultingOptions;
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity_exports23 = {};
__export(identity_exports23, {
  identity: () => identity23
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/vendor/base-x.js
function base18(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src14 = base18;
var _brrp__multiformats_scope_baseX14 = src14;
var base_x_default14 = _brrp__multiformats_scope_baseX14;

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bytes.js
var empty15 = new Uint8Array(0);
var equals31 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce14 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString22 = (str) => new TextEncoder().encode(str);
var toString24 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base.js
var Encoder15 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder15 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or15(this, decoder);
  }
};
var ComposedDecoder14 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or15(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or15 = (left, right) => new ComposedDecoder14({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec14 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder15(name22, prefix, baseEncode);
    this.decoder = new Decoder15(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from25 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec14(name22, prefix, encode81, decode97);
var baseX14 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default14(alphabet16, name22);
  return from25({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce14(decode97(text))
  });
};
var decode75 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode64 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464814 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from25({
    prefix,
    name: name22,
    encode(input) {
      return encode64(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode75(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity23 = from25({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString24(buf2),
  decode: (str) => fromString22(str)
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base2.js
var base2_exports12 = {};
__export(base2_exports12, {
  base2: () => base213
});
var base213 = rfc464814({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base8.js
var base8_exports12 = {};
__export(base8_exports12, {
  base8: () => base812
});
var base812 = rfc464814({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base10_exports12 = {};
__export(base10_exports12, {
  base10: () => base1012
});
var base1012 = baseX14({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base16.js
var base16_exports12 = {};
__export(base16_exports12, {
  base16: () => base1612,
  base16upper: () => base16upper12
});
var base1612 = rfc464814({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper12 = rfc464814({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base32.js
var base32_exports12 = {};
__export(base32_exports12, {
  base32: () => base3214,
  base32hex: () => base32hex14,
  base32hexpad: () => base32hexpad14,
  base32hexpadupper: () => base32hexpadupper14,
  base32hexupper: () => base32hexupper14,
  base32pad: () => base32pad14,
  base32padupper: () => base32padupper14,
  base32upper: () => base32upper14,
  base32z: () => base32z14
});
var base3214 = rfc464814({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper14 = rfc464814({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad14 = rfc464814({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper14 = rfc464814({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex14 = rfc464814({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper14 = rfc464814({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad14 = rfc464814({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper14 = rfc464814({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z14 = rfc464814({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base36.js
var base36_exports12 = {};
__export(base36_exports12, {
  base36: () => base3612,
  base36upper: () => base36upper12
});
var base3612 = baseX14({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper12 = baseX14({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base58.js
var base58_exports12 = {};
__export(base58_exports12, {
  base58btc: () => base58btc14,
  base58flickr: () => base58flickr14
});
var base58btc14 = baseX14({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr14 = baseX14({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base64.js
var base64_exports12 = {};
__export(base64_exports12, {
  base64: () => base6413,
  base64pad: () => base64pad13,
  base64url: () => base64url13,
  base64urlpad: () => base64urlpad13
});
var base6413 = rfc464814({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad13 = rfc464814({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url13 = rfc464814({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad13 = rfc464814({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports12 = {};
__export(base256emoji_exports12, {
  base256emoji: () => base256emoji12
});
var alphabet13 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars12 = alphabet13.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes12 = alphabet13.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode65(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars12[c];
    return p;
  }, "");
}
function decode76(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes12[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji12 = from25({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode65,
  decode: decode76
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports12 = {};
__export(sha2_browser_exports12, {
  sha256: () => sha25612,
  sha512: () => sha51212
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/vendor/varint.js
var encode_113 = encode66;
var MSB13 = 128;
var REST13 = 127;
var MSBALL13 = ~REST13;
var INT13 = Math.pow(2, 31);
function encode66(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT13) {
    out[offset++] = num & 255 | MSB13;
    num /= 128;
  }
  while (num & MSBALL13) {
    out[offset++] = num & 255 | MSB13;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode66.bytes = offset - oldOffset + 1;
  return out;
}
var decode77 = read14;
var MSB$113 = 128;
var REST$113 = 127;
function read14(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read14.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$113) << shift : (b & REST$113) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$113);
  read14.bytes = counter - offset;
  return res;
}
var N114 = Math.pow(2, 7);
var N214 = Math.pow(2, 14);
var N314 = Math.pow(2, 21);
var N414 = Math.pow(2, 28);
var N514 = Math.pow(2, 35);
var N614 = Math.pow(2, 42);
var N714 = Math.pow(2, 49);
var N814 = Math.pow(2, 56);
var N914 = Math.pow(2, 63);
var length16 = function(value2) {
  return value2 < N114 ? 1 : value2 < N214 ? 2 : value2 < N314 ? 3 : value2 < N414 ? 4 : value2 < N514 ? 5 : value2 < N614 ? 6 : value2 < N714 ? 7 : value2 < N814 ? 8 : value2 < N914 ? 9 : 10;
};
var varint19 = {
  encode: encode_113,
  decode: decode77,
  encodingLength: length16
};
var _brrp_varint13 = varint19;
var varint_default13 = _brrp_varint13;

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/varint.js
var decode78 = (data, offset = 0) => {
  const code22 = varint_default13.decode(data, offset);
  return [code22, varint_default13.decode.bytes];
};
var encodeTo13 = (int, target, offset = 0) => {
  varint_default13.encode(int, target, offset);
  return target;
};
var encodingLength13 = (int) => {
  return varint_default13.encodingLength(int);
};

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/hashes/digest.js
var create19 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength13(code22);
  const digestOffset = sizeOffset + encodingLength13(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo13(code22, bytes2, 0);
  encodeTo13(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest13(code22, size, digest15, bytes2);
};
var decode79 = (multihash) => {
  const bytes2 = coerce14(multihash);
  const [code22, sizeOffset] = decode78(bytes2);
  const [size, digestOffset] = decode78(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest13(code22, size, digest15, bytes2);
};
var equals32 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals31(a.bytes, data.bytes);
  }
};
var Digest13 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/hashes/hasher.js
var from26 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher12(name22, code22, encode81);
var Hasher12 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create19(this.code, result) : result.then((digest15) => create19(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha12 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25612 = from26({
  name: "sha2-256",
  code: 18,
  encode: sha12("SHA-256")
});
var sha51212 = from26({
  name: "sha2-512",
  code: 19,
  encode: sha12("SHA-512")
});

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var identity_exports24 = {};
__export(identity_exports24, {
  identity: () => identity24
});
var code18 = 0;
var name19 = "identity";
var encode67 = coerce14;
var digest12 = (input) => create19(code18, encode67(input));
var identity24 = { code: code18, name: name19, encode: encode67, digest: digest12 };

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/codecs/json.js
var textEncoder15 = new TextEncoder();
var textDecoder14 = new TextDecoder();

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/cid.js
var format12 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV013(
        bytes2,
        baseCache12(link),
        base30 || base58btc14.encoder
      );
    default:
      return toStringV113(
        bytes2,
        baseCache12(link),
        base30 || base3214.encoder
      );
  }
};
var cache14 = /* @__PURE__ */ new WeakMap();
var baseCache12 = (cid) => {
  const baseCache16 = cache14.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache14.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID13 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE13) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE13) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID13.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create19(code22, digest15);
        return CID13.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID13.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals32(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format12(this, base30);
  }
  toJSON() {
    return { "/": format12(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID13) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID13(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID14(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol13] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode79(multihash);
      return CID13.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE13) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE13}) block encoding`
          );
        } else {
          return new CID13(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID14(version4, code22, digest15.bytes);
        return new CID13(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID13.create(0, DAG_PB_CODE13, digest15);
  }
  static createV1(code22, digest15) {
    return CID13.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID13.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID13.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce14(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest13(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID13.createV0(digest15) : CID13.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode78(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE13;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes13(source, base30);
    const cid = CID13.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache12(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes13 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc14;
      return [
        base58btc14.prefix,
        decoder.decode(`${base58btc14.prefix}${source}`)
      ];
    }
    case base58btc14.prefix: {
      const decoder = base30 || base58btc14;
      return [base58btc14.prefix, decoder.decode(source)];
    }
    case base3214.prefix: {
      const decoder = base30 || base3214;
      return [base3214.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV013 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc14.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV113 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE13 = 112;
var SHA_256_CODE13 = 18;
var encodeCID14 = (version4, code22, multihash) => {
  const codeOffset = encodingLength13(version4);
  const hashOffset = codeOffset + encodingLength13(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo13(version4, bytes2, 0);
  encodeTo13(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol13 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/node_modules/multiformats/src/basics.js
var bases12 = { ...identity_exports23, ...base2_exports12, ...base8_exports12, ...base10_exports12, ...base16_exports12, ...base32_exports12, ...base36_exports12, ...base58_exports12, ...base64_exports12, ...base256emoji_exports12 };
var hashes12 = { ...sha2_browser_exports12, ...identity_exports24 };

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array13(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe14(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array13(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec15(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string11 = createCodec15("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii11 = createCodec15("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe14(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES11 = {
  utf8: string11,
  "utf-8": string11,
  hex: bases12.base16,
  latin1: ascii11,
  ascii: ascii11,
  binary: ascii11,
  ...bases12
};

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/utils.js
var import_reader4 = __toESM(require_reader(), 1);
var import_reader_buffer4 = __toESM(require_reader_buffer(), 1);
var import_writer5 = __toESM(require_writer(), 1);
var import_writer_buffer4 = __toESM(require_writer_buffer(), 1);
var import_minimal12 = __toESM(require_minimal(), 1);
function configure5() {
  import_minimal12.default._configure();
  import_reader4.default._configure(import_reader_buffer4.default);
  import_writer5.default._configure(import_writer_buffer4.default);
}
configure5();
var methods6 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader4(obj) {
  for (const method of methods6) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader5(buf2) {
  return patchReader4(new import_reader4.default(buf2));
}
function patchWriter4(obj) {
  for (const method of methods6) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer4() {
  return patchWriter4(import_writer5.default.create());
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage5(buf2, codec) {
  const r = reader5(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage5(message6, codec) {
  const w = writer4();
  codec.encode(message6, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES5;
(function(CODEC_TYPES6) {
  CODEC_TYPES6[CODEC_TYPES6["VARINT"] = 0] = "VARINT";
  CODEC_TYPES6[CODEC_TYPES6["BIT64"] = 1] = "BIT64";
  CODEC_TYPES6[CODEC_TYPES6["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES6[CODEC_TYPES6["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES6[CODEC_TYPES6["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES5 || (CODEC_TYPES5 = {}));
function createCodec16(name22, type, encode81, decode97) {
  return {
    name: name22,
    type,
    encode: encode81,
    decode: decode97
  };
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/codecs/message.js
function message5(encode81, decode97) {
  return createCodec16("message", CODEC_TYPES5.LENGTH_DELIMITED, encode81, decode97);
}

// node_modules/@libp2p/peer-id-factory/dist/src/proto.js
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message5((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w.uint32(18);
          w.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w.uint32(26);
          w.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          id: new Uint8Array(0)
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader6.bytes();
              break;
            case 2:
              obj.pubKey = reader6.bytes();
              break;
            case 3:
              obj.privKey = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage5(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf2) => {
    return decodeMessage5(buf2, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = async () => {
  const key = await generateKeyPair4("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
var createRSAPeerId = async (opts) => {
  const key = await generateKeyPair4("RSA", opts?.bits ?? 2048);
  const id = await createFromPrivKey(key);
  if (id.type === "RSA") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey2(privateKey.public), marshalPrivateKey(privateKey));
}

// node_modules/libp2p/dist/src/libp2p.js
init_concat();
var import_err_code117 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/dht/dummy-dht.js
var import_err_code113 = __toESM(require_err_code(), 1);
var DummyDHT = class extends EventEmitter2 {
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dummy-dht";
  }
  get wan() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  get lan() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  get() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  findProviders() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  findPeer() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  getClosestPeers() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  provide() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  put() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async getMode() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async setMode() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async refreshRoutingTable() {
    throw (0, import_err_code113.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
};

// node_modules/libp2p/dist/src/pubsub/dummy-pubsub.js
var import_err_code114 = __toESM(require_err_code(), 1);
var DummyPubSub = class extends EventEmitter2 {
  isStarted() {
    return false;
  }
  start() {
  }
  stop() {
  }
  get globalSignaturePolicy() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  get multicodecs() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getPeers() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getTopics() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  subscribe() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  unsubscribe() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getSubscribers() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  async publish() {
    throw (0, import_err_code114.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
};

// node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var import_it_all10 = __toESM(require_it_all(), 1);
var import_it_filter12 = __toESM(require_it_filter(), 1);
var import_err_code116 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller12 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal7 = __toESM(require_any_signal(), 1);
var import_events32 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/connection-manager/dialer/dial-request.js
var import_err_code115 = __toESM(require_err_code(), 1);
var import_any_signal6 = __toESM(require_any_signal(), 1);
var import_p_fifo = __toESM(require_p_fifo(), 1);
var import_events31 = __toESM(require_events(), 1);
var log90 = logger("libp2p:dialer:dial-request");
var DialRequest = class {
  constructor(options) {
    const { addrs, dialAction, dialer } = options;
    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  async run(options = {}) {
    const tokens = this.dialer.getTokens(this.addrs.length);
    if (tokens.length < 1) {
      throw (0, import_err_code115.default)(new Error("No dial tokens available"), codes4.ERR_NO_DIAL_TOKENS);
    }
    const tokenHolder = new import_p_fifo.default();
    for (const token of tokens) {
      void tokenHolder.push(token).catch((err2) => {
        log90.error(err2);
      });
    }
    const dialAbortControllers = this.addrs.map(() => {
      const controller = new AbortController();
      try {
        (0, import_events31.setMaxListeners)?.(Infinity, controller.signal);
      } catch {
      }
      return controller;
    });
    if (options.signal != null) {
      try {
        (0, import_events31.setMaxListeners)?.(Infinity, options.signal);
      } catch {
      }
    }
    let completedDials = 0;
    let done = false;
    try {
      return await Promise.any(this.addrs.map(async (addr, i2) => {
        const token = await tokenHolder.shift();
        if (done) {
          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          throw (0, import_err_code115.default)(new Error("dialAction already succeeded"), codes4.ERR_ALREADY_SUCCEEDED);
        }
        const controller = dialAbortControllers[i2];
        if (controller == null) {
          throw (0, import_err_code115.default)(new Error("dialAction did not come with an AbortController"), codes4.ERR_INVALID_PARAMETERS);
        }
        let conn;
        try {
          const signal = controller.signal;
          conn = await this.dialAction(addr, { ...options, signal: options.signal != null ? (0, import_any_signal6.anySignal)([signal, options.signal]) : signal });
          dialAbortControllers[i2] = void 0;
        } finally {
          completedDials++;
          if (this.addrs.length - completedDials >= tokens.length) {
            void tokenHolder.push(token).catch((err2) => {
              log90.error(err2);
            });
          } else {
            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          }
        }
        if (conn == null) {
          throw (0, import_err_code115.default)(new Error("dialAction led to empty object"), codes4.ERR_TRANSPORT_DIAL_FAILED);
        } else {
          done = true;
        }
        return conn;
      }));
    } finally {
      dialAbortControllers.forEach((c) => {
        if (c !== void 0) {
          c.abort();
        }
      });
      tokens.forEach((token) => this.dialer.releaseToken(token));
    }
  }
};

// node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var import_it_sort4 = __toESM(require_it_sort(), 1);
var import_it_map14 = __toESM(require_it_map(), 1);
var log91 = logger("libp2p:dialer");
var METRICS_COMPONENT2 = "dialler";
var METRICS_PENDING_DIALS = "pending-dials";
var METRICS_PENDING_DIAL_TARGETS = "pending-dial-targets";
var DefaultDialer = class {
  constructor(components, init = {}) {
    this.started = false;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;
    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;
    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;
    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);
    this.components = components;
    this.pendingDials = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIALS,
      metrics: init.metrics
    });
    this.pendingDialTargets = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIAL_TARGETS,
      metrics: components.getMetrics()
    });
    for (const [key, value2] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value2);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
    for (const dial of this.pendingDials.values()) {
      try {
        dial.controller.abort();
      } catch (err2) {
        log91.error(err2);
      }
    }
    this.pendingDials.clear();
    for (const pendingTarget of this.pendingDialTargets.values()) {
      pendingTarget.reject(new AbortError3("Dialer was destroyed"));
    }
    this.pendingDialTargets.clear();
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (this.components.getPeerId().equals(id)) {
      throw (0, import_err_code116.default)(new Error("Tried to dial self"), codes4.ERR_DIALED_SELF);
    }
    log91("check multiaddrs %p", id);
    if (multiaddrs != null && multiaddrs.length > 0) {
      log91("storing multiaddrs %p", id, multiaddrs);
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    if (await this.components.getConnectionGater().denyDialPeer(id)) {
      throw (0, import_err_code116.default)(new Error("The dial request is blocked by gater.allowDialPeer"), codes4.ERR_PEER_DIAL_INTERCEPTED);
    }
    log91("creating dial target for %p", id);
    const dialTarget = await this._createCancellableDialTarget(id, options);
    if (dialTarget.addrs.length === 0) {
      throw (0, import_err_code116.default)(new Error("The dial request has no valid addresses"), codes4.ERR_NO_VALID_ADDRESSES);
    }
    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);
    try {
      const connection = await pendingDial.promise;
      log91("dial succeeded to %s", dialTarget.id);
      return connection;
    } catch (err2) {
      log91("dial failed to %s", dialTarget.id, err2);
      if (pendingDial.controller.signal.aborted) {
        err2.code = codes4.ERR_TIMEOUT;
      }
      log91.error(err2);
      throw err2;
    } finally {
      pendingDial.destroy();
    }
  }
  async _createCancellableDialTarget(peer, options) {
    const id = `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    const cancellablePromise = new Promise((resolve7, reject) => {
      this.pendingDialTargets.set(id, { resolve: resolve7, reject });
    });
    try {
      const dialTarget = await Promise.race([
        this._createDialTarget(peer, options),
        cancellablePromise
      ]);
      return dialTarget;
    } finally {
      this.pendingDialTargets.delete(id);
    }
  }
  async _createDialTarget(peer, options) {
    const _resolve = this._resolve.bind(this);
    const addrs = await pipe(
      await this.components.getPeerStore().addressBook.get(peer),
      (source) => (0, import_it_filter12.default)(source, async (address) => {
        return !await this.components.getConnectionGater().denyDialMultiaddr(peer, address.multiaddr);
      }),
      (source) => (0, import_it_sort4.default)(source, this.addressSorter),
      async function* resolve7(source) {
        for await (const a of source) {
          yield* await _resolve(a.multiaddr, options);
        }
      },
      (source) => (0, import_it_filter12.default)(source, (ma) => Boolean(this.components.getTransportManager().transportForMultiaddr(ma))),
      (source) => (0, import_it_map14.default)(source, (ma) => {
        if (peer.toString() === ma.getPeerId()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${peer.toString()}`);
      }),
      async (source) => await (0, import_it_all10.default)(source)
    );
    if (addrs.length > this.maxAddrsToDial) {
      await this.components.getPeerStore().delete(peer);
      throw (0, import_err_code116.default)(new Error("dial with more addresses than allowed"), codes4.ERR_TOO_MANY_ADDRESSES);
    }
    return {
      id: peer.toString(),
      addrs
    };
  }
  _createPendingDial(dialTarget, options = {}) {
    const dialAction = async (addr, options2 = {}) => {
      if (options2.signal?.aborted === true) {
        throw (0, import_err_code116.default)(new Error("already aborted"), codes4.ERR_ALREADY_ABORTED);
      }
      return await this.components.getTransportManager().dial(addr, options2).catch((err2) => {
        log91.error("dial to %s failed", addr, err2);
        throw err2;
      });
    };
    const dialRequest = new DialRequest({
      addrs: dialTarget.addrs,
      dialAction,
      dialer: this
    });
    const timeoutController = new import_timeout_abort_controller12.TimeoutController(this.timeout);
    const signals = [timeoutController.signal];
    options.signal != null && signals.push(options.signal);
    const signal = (0, import_any_signal7.anySignal)(signals);
    try {
      (0, import_events32.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const pendingDial = {
      dialRequest,
      controller: timeoutController,
      promise: dialRequest.run({ ...options, signal }),
      destroy: () => {
        timeoutController.clear();
        this.pendingDials.delete(dialTarget.id);
      }
    };
    this.pendingDials.set(dialTarget.id, pendingDial);
    return pendingDial;
  }
  getTokens(num) {
    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
    const tokens = this.tokens.splice(0, total);
    log91("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
    return tokens;
  }
  releaseToken(token) {
    if (this.tokens.includes(token)) {
      return;
    }
    log91("token %d released", token);
    this.tokens.push(token);
  }
  async _resolve(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await this._resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return await this._resolve(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    return addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
  }
  async _resolveRecord(ma, options) {
    try {
      ma = multiaddr(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err2) {
      log91.error(`multiaddr ${ma.toString()} could not be resolved`, err2);
      return [];
    }
  }
};

// node_modules/libp2p/dist/src/libp2p.js
var log92 = logger("libp2p");
var Libp2pNode = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.initializables = [];
    this.started = false;
    this.peerId = init.peerId;
    this.components = new Components({
      peerId: init.peerId,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: {
        denyDialPeer: async () => await Promise.resolve(false),
        denyDialMultiaddr: async () => await Promise.resolve(false),
        denyInboundConnection: async () => await Promise.resolve(false),
        denyOutboundConnection: async () => await Promise.resolve(false),
        denyInboundEncryptedConnection: async () => await Promise.resolve(false),
        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),
        denyInboundUpgradedConnection: async () => await Promise.resolve(false),
        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),
        filterMultiaddrForPeer: async () => await Promise.resolve(true),
        ...init.connectionGater
      }
    });
    this.components.setPeerStore(new PersistentPeerStore({
      addressFilter: this.components.getConnectionGater().filterMultiaddrForPeer,
      ...init.peerStore
    }));
    this.services = [
      this.components
    ];
    if (init.metrics.enabled) {
      this.metrics = this.components.setMetrics(new DefaultMetrics(init.metrics));
    }
    this.peerStore = this.components.getPeerStore();
    this.peerStore.addEventListener("peer", (evt) => {
      const { detail: peerData } = evt;
      this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peerData }));
    });
    if (init.connectionProtector != null) {
      this.components.setConnectionProtector(init.connectionProtector);
    }
    this.components.setUpgrader(new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((component) => this.configureComponent(component)),
      muxers: (init.streamMuxers ?? []).map((component) => this.configureComponent(component)),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    }));
    this.components.setDialer(new DefaultDialer(this.components, init.connectionManager));
    this.connectionManager = this.components.setConnectionManager(new DefaultConnectionManager(init.connectionManager));
    this.registrar = this.components.setRegistrar(new DefaultRegistrar(this.components));
    this.components.setTransportManager(new DefaultTransportManager(this.components, init.transportManager));
    this.components.setAddressManager(new DefaultAddressManager(this.components, init.addresses));
    this.configureComponent(new PeerRecordUpdater(this.components));
    this.configureComponent(new AutoDialler(this.components, {
      enabled: init.connectionManager.autoDial,
      minConnections: init.connectionManager.minConnections,
      autoDialInterval: init.connectionManager.autoDialInterval
    }));
    const keychainOpts = KeyChain.generateOptions();
    this.keychain = this.configureComponent(new KeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    this.services.push(new NatManager(this.components, init.nat));
    init.transports.forEach((transport) => {
      this.components.getTransportManager().add(this.configureComponent(transport));
    });
    if (init.streamMuxers != null && init.streamMuxers.length > 0) {
      this.identifyService = new IdentifyService(this.components, {
        ...init.identify
      });
      this.configureComponent(this.identifyService);
    }
    if (init.dht != null) {
      this.dht = this.components.setDHT(init.dht);
    } else {
      this.dht = new DummyDHT();
    }
    if (init.pubsub != null) {
      this.pubsub = this.components.setPubSub(init.pubsub);
    } else {
      this.pubsub = new DummyPubSub();
    }
    const peerRouters = (init.peerRouters ?? []).map((component) => this.configureComponent(component));
    if (init.dht != null) {
      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)));
      this.dht.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
    this.peerRouting = this.components.setPeerRouting(this.configureComponent(new DefaultPeerRouting(this.components, {
      ...init.peerRouting,
      routers: peerRouters
    })));
    const contentRouters = (init.contentRouters ?? []).map((component) => this.configureComponent(component));
    if (init.dht != null) {
      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));
    }
    this.contentRouting = this.components.setContentRouting(this.configureComponent(new CompoundContentRouting(this.components, {
      routers: contentRouters
    })));
    if (init.relay.enabled) {
      this.components.getTransportManager().add(this.configureComponent(new Circuit2(init.relay)));
      this.configureComponent(new Relay(this.components, {
        addressSorter: init.connectionManager.addressSorter,
        ...init.relay
      }));
    }
    this.fetchService = this.configureComponent(new FetchService(this.components, {
      ...init.fetch
    }));
    this.pingService = this.configureComponent(new PingService(this.components, {
      ...init.ping
    }));
    const autoDialer = this.configureComponent(new AutoDialer(this.components, {
      enabled: init.connectionManager.autoDial !== false,
      minConnections: init.connectionManager.minConnections,
      dialTimeout: init.connectionManager.dialTimeout ?? 3e4
    }));
    this.addEventListener("peer:discovery", (evt) => {
      if (!this.isStarted()) {
        return;
      }
      autoDialer.handle(evt);
    });
    for (const service of init.peerDiscovery ?? []) {
      this.configureComponent(service);
      service.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
  }
  configureComponent(component) {
    if (isStartable(component)) {
      this.services.push(component);
    }
    if (isInitializable(component)) {
      this.initializables.push(component);
    }
    return component;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    log92("libp2p is starting");
    try {
      this.initializables.forEach((obj) => {
        obj.init(this.components);
      });
      await Promise.all(this.services.map(async (service) => {
        if (service.beforeStart != null) {
          await service.beforeStart();
        }
      }));
      await Promise.all(this.services.map((service) => service.start()));
      await Promise.all(this.services.map(async (service) => {
        if (service.afterStart != null) {
          await service.afterStart();
        }
      }));
      log92("libp2p has started");
    } catch (err2) {
      log92.error("An error occurred starting libp2p", err2);
      await this.stop();
      throw err2;
    }
  }
  async stop() {
    if (!this.started) {
      return;
    }
    log92("libp2p is stopping");
    this.started = false;
    await Promise.all(this.services.map(async (service) => {
      if (service.beforeStop != null) {
        await service.beforeStop();
      }
    }));
    await Promise.all(this.services.map((service) => service.stop()));
    await Promise.all(this.services.map(async (service) => {
      if (service.afterStop != null) {
        await service.afterStop();
      }
    }));
    log92("libp2p has stopped");
  }
  isStarted() {
    return this.started;
  }
  getConnections(peerId) {
    return this.components.getConnectionManager().getConnections(peerId);
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.getConnectionManager().getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    return await this.components.getConnectionManager().openConnection(id, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw (0, import_err_code117.default)(new Error("no protocols were provided to open a stream"), codes4.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw (0, import_err_code117.default)(new Error("no protocols were provided to open a stream"), codes4.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return await connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.getAddressManager().getAddresses();
  }
  async hangUp(peer) {
    const { id } = getPeer(peer);
    await this.components.getConnectionManager().closeConnections(id);
  }
  async getPublicKey(peer, options = {}) {
    log92("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.pubKey != null) {
      return peerInfo.pubKey;
    }
    if (this.dht == null) {
      throw (0, import_err_code117.default)(new Error("Public key was not in the peer store and the DHT is not enabled"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    const peerKey = concat4([
      fromString3("/pk/"),
      peer.multihash.digest
    ]);
    for await (const event of this.dht.get(peerKey, options)) {
      if (event.name === "VALUE") {
        const key = unmarshalPublicKey2(event.value);
        await this.peerStore.keyBook.set(peer, event.value);
        return key.bytes;
      }
    }
    throw (0, import_err_code117.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), codes4.ERR_INVALID_RECORD);
  }
  async fetch(peer, key, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs != null) {
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    return await this.fetchService.fetch(id, key, options);
  }
  async ping(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs.length > 0) {
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    return await this.pingService.ping(id, options);
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol4) => {
      await this.components.getRegistrar().handle(protocol4, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol4) => {
      await this.components.getRegistrar().unhandle(protocol4);
    }));
  }
  onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log92.error(new Error(codes4.ERR_DISCOVERED_SELF));
      return;
    }
    if (peer.multiaddrs.length > 0) {
      void this.components.getPeerStore().addressBook.add(peer.id, peer.multiaddrs).catch((err2) => log92.error(err2));
    }
    if (peer.protocols.length > 0) {
      void this.components.getPeerStore().protoBook.set(peer.id, peer.protocols).catch((err2) => log92.error(err2));
    }
    this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peer }));
  }
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options) {
  return await createLibp2pNode(options);
}

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var import_k_bucket = __toESM(require_k_bucket(), 1);

// node_modules/@libp2p/kad-dht/dist/src/utils.js
init_concat();
var import_private_ip3 = __toESM(require_private_ip(), 1);

// node_modules/@libp2p/kad-dht/dist/src/constants.js
var second2 = 1e3;
var minute4 = 60 * second2;
var hour2 = 60 * minute4;
var MAX_RECORD_AGE = 36 * hour2;
var LAN_PREFIX = "/lan";
var PROTOCOL_PREFIX = "/ipfs";
var PROTOCOL_DHT = "/kad/1.0.0";
var RECORD_KEY_PREFIX = "/dht/record";
var PROVIDER_KEY_PREFIX = "/dht/provider";
var PROVIDERS_LRU_CACHE_SIZE = 256;
var PROVIDERS_VALIDITY = 24 * hour2;
var PROVIDERS_CLEANUP_INTERVAL = hour2;
var READ_MESSAGE_TIMEOUT = 10 * second2;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = Number(5 * minute4);
var QUERY_SELF_TIMEOUT = Number(30 * second2);
var TABLE_REFRESH_INTERVAL = Number(5 * minute4);
var TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second2);
var DEFAULT_QUERY_TIMEOUT = Number(30 * second2);

// node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString3("/pk/");
function removePrivateAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return !(0, import_private_ip3.default)(addr);
    })
  };
}
function removePublicAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return (0, import_private_ip3.default)(addr);
    })
  };
}
async function convertBuffer(buf2) {
  const multihash = await sha256.digest(buf2);
  return multihash.digest;
}
async function convertPeerId(peerId) {
  return await convertBuffer(peerId.toBytes());
}
function bufferToRecordKey(buf2) {
  return new Key(`${RECORD_KEY_PREFIX}/${toString11(buf2, "base32")}`, false);
}
function keyForPublicKey(peer) {
  return concat4([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
function isPublicKeyKey(key) {
  return toString11(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
function createPutRecord(key, value2) {
  const timeReceived = new Date();
  const rec = new Libp2pRecord(key, value2, timeReceived);
  return rec.serialize();
}
function debounce(callback, wait = 100) {
  let timeout;
  return () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => callback(), wait);
  };
}

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var import_timeout_abort_controller13 = __toESM(require_timeout_abort_controller(), 1);
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var KBUCKET_SIZE = 20;
var PING_TIMEOUT = 1e4;
var PING_CONCURRENCY = 10;
var METRIC_ROUTING_TABLE_SIZE = "routing-table-size";
var METRIC_PING_QUEUE_SIZE = "ping-queue-size";
var METRIC_PING_RUNNING = "ping-running";
var RoutingTable = class {
  constructor(init) {
    this.components = new Components();
    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol: protocol4, tagName, tagValue } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;
    this.lan = lan;
    this.running = false;
    this.protocol = protocol4;
    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;
    const updatePingQueueSizeMetric = () => {
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_QUEUE_SIZE,
        value: this.pingQueue.size
      });
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_RUNNING,
        value: this.pingQueue.pending
      });
    };
    this.pingQueue = new PQueue({ concurrency: this.pingConcurrency });
    this.pingQueue.addListener("add", updatePingQueueSizeMetric);
    this.pingQueue.addListener("next", updatePingQueueSizeMetric);
    this._onPing = this._onPing.bind(this);
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    const kBuck = new import_k_bucket.default({
      localNodeId: await convertPeerId(this.components.getPeerId()),
      numberOfNodesPerKBucket: this.kBucketSize,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.on("ping", this._onPing);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map((contact) => contact.peer));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.getPeerStore().tagPeer(peer, this.tagName, {
            value: this.tagValue
          });
        }
        for (const peer of removedPeers) {
          await this.components.getPeerStore().unTagPeer(peer, this.tagName);
        }
      }).catch((err2) => {
        this.log.error("Could not update peer tags", err2);
      });
      kClosest = newClosest;
    });
    kBuck.on("added", () => {
      updatePeerTags();
    });
    kBuck.on("removed", () => {
      updatePeerTags();
    });
  }
  _onPing(oldContacts, newContact) {
    this.pingQueue.add(async () => {
      if (!this.running) {
        return;
      }
      let responded = 0;
      try {
        await Promise.all(oldContacts.map(async (oldContact) => {
          let timeoutController;
          try {
            timeoutController = new import_timeout_abort_controller13.TimeoutController(this.pingTimeout);
            const options = {
              signal: timeoutController.signal
            };
            this.log("pinging old contact %p", oldContact.peer);
            const connection = await this.components.getConnectionManager().openConnection(oldContact.peer, options);
            const stream = await connection.newStream(this.protocol, options);
            stream.close();
            responded++;
          } catch (err2) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peer, err2);
              this.log("evicting old contact after ping failed %p", oldContact);
              this.kb.remove(oldContact.id);
            }
          } finally {
            if (timeoutController != null) {
              timeoutController.clear();
            }
            this.components.getMetrics()?.updateComponentMetric({
              system: "libp2p",
              component: `kad-dht-${this.lan ? "lan" : "wan"}`,
              metric: METRIC_ROUTING_TABLE_SIZE,
              value: this.size
            });
          }
        }));
        if (this.running && responded < oldContacts.length && this.kb != null) {
          this.log("adding new contact %p", newContact.peer);
          this.kb.add(newContact);
        }
      } catch (err2) {
        this.log.error("could not process k-bucket ping event", err2);
      }
    }).catch((err2) => {
      this.log.error("could not process k-bucket ping event", err2);
    });
  }
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  async find(peer) {
    const key = await convertPeerId(peer);
    const closest = this.closestPeer(key);
    if (closest != null && peer.equals(closest)) {
      return closest;
    }
    return void 0;
  }
  closestPeer(key) {
    const res = this.closestPeers(key, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  closestPeers(key, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    const closest = this.kb.closest(key, count);
    return closest.map((p) => p.peer);
  }
  async add(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.add({ id, peer });
    this.log("added %p with kad id %b", peer, id);
    this.components.getMetrics()?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.components.getMetrics()?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var import_it_length3 = __toESM(require_it_length(), 1);
var import_timeout_abort_controller14 = __toESM(require_timeout_abort_controller(), 1);
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  constructor(init) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  init(components) {
  }
  async start() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err2) {
              this.log.error(err2);
            }
          }
        }
      } catch (err2) {
        this.log.error(err2);
      }
    })).catch((err2) => {
      this.log.error(err2);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const controller = new import_timeout_abort_controller14.TimeoutController(this.refreshQueryTimeout);
    try {
      const peers = await (0, import_it_length3.default)(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
    } finally {
      controller.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i2 = 0; i2 <= maxCommonPrefix; i2++) {
      dates[i2] = this.commonPrefixLengthRefreshedAt[i2] ?? new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length23 of this._prefixLengths()) {
      if (length23 > prefixLength) {
        prefixLength = length23;
      }
    }
    return prefixLength;
  }
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length23 of this._prefixLengths()) {
      if (length23 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { id } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localNodeId, id);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/network.js
var import_err_code118 = __toESM(require_err_code(), 1);
var import_it_drain14 = __toESM(require_it_drain(), 1);
var import_it_first9 = __toESM(require_it_first(), 1);

// node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.key != null) {
          writer5.uint32(10);
          writer5.bytes(obj.key);
        }
        if (obj.value != null) {
          writer5.uint32(18);
          writer5.bytes(obj.value);
        }
        if (obj.author != null) {
          writer5.uint32(26);
          writer5.bytes(obj.author);
        }
        if (obj.signature != null) {
          writer5.uint32(34);
          writer5.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          writer5.uint32(42);
          writer5.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {};
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader6.bytes();
              break;
            case 2:
              obj.value = reader6.bytes();
              break;
            case 3:
              obj.author = reader6.bytes();
              break;
            case 4:
              obj.signature = reader6.bytes();
              break;
            case 5:
              obj.timeReceived = reader6.string();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage2(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage2(buf2, Record3.codec());
  };
})(Record2 || (Record2 = {}));
var Message;
(function(Message4) {
  let MessageType;
  (function(MessageType2) {
    MessageType2["PUT_VALUE"] = "PUT_VALUE";
    MessageType2["GET_VALUE"] = "GET_VALUE";
    MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType2["FIND_NODE"] = "FIND_NODE";
    MessageType2["PING"] = "PING";
  })(MessageType = Message4.MessageType || (Message4.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType2) {
    MessageType2.codec = () => {
      return enumeration2(__MessageTypeValues);
    };
  })(MessageType = Message4.MessageType || (Message4.MessageType = {}));
  let ConnectionType;
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(ConnectionType = Message4.ConnectionType || (Message4.ConnectionType = {}));
  let __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration2(__ConnectionTypeValues);
    };
  })(ConnectionType = Message4.ConnectionType || (Message4.ConnectionType = {}));
  let Peer3;
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message2((obj, writer5, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer5.fork();
          }
          if (obj.id != null) {
            writer5.uint32(10);
            writer5.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              writer5.uint32(18);
              writer5.bytes(value2);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (obj.connection != null) {
            writer5.uint32(24);
            Message4.ConnectionType.codec().encode(obj.connection, writer5);
          }
          if (opts.lengthDelimited !== false) {
            writer5.ldelim();
          }
        }, (reader6, length23) => {
          const obj = {
            addrs: []
          };
          const end = length23 == null ? reader6.len : reader6.pos + length23;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader6.bytes();
                break;
              case 2:
                obj.addrs.push(reader6.bytes());
                break;
              case 3:
                obj.connection = Message4.ConnectionType.codec().decode(reader6);
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage2(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage2(buf2, Peer4.codec());
    };
  })(Peer3 = Message4.Peer || (Message4.Peer = {}));
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, writer5, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer5.fork();
        }
        if (obj.type != null) {
          writer5.uint32(8);
          Message4.MessageType.codec().encode(obj.type, writer5);
        }
        if (obj.clusterLevelRaw != null) {
          writer5.uint32(80);
          writer5.int32(obj.clusterLevelRaw);
        }
        if (obj.key != null) {
          writer5.uint32(18);
          writer5.bytes(obj.key);
        }
        if (obj.record != null) {
          writer5.uint32(26);
          writer5.bytes(obj.record);
        }
        if (obj.closerPeers != null) {
          for (const value2 of obj.closerPeers) {
            writer5.uint32(66);
            Message4.Peer.codec().encode(value2, writer5);
          }
        } else {
          throw new Error('Protocol error: required field "closerPeers" was not found in object');
        }
        if (obj.providerPeers != null) {
          for (const value2 of obj.providerPeers) {
            writer5.uint32(74);
            Message4.Peer.codec().encode(value2, writer5);
          }
        } else {
          throw new Error('Protocol error: required field "providerPeers" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer5.ldelim();
        }
      }, (reader6, length23) => {
        const obj = {
          closerPeers: [],
          providerPeers: []
        };
        const end = length23 == null ? reader6.len : reader6.pos + length23;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message4.MessageType.codec().decode(reader6);
              break;
            case 10:
              obj.clusterLevelRaw = reader6.int32();
              break;
            case 2:
              obj.key = reader6.bytes();
              break;
            case 3:
              obj.record = reader6.bytes();
              break;
            case 8:
              obj.closerPeers.push(Message4.Peer.codec().decode(reader6, reader6.uint32()));
              break;
            case 9:
              obj.providerPeers.push(Message4.Peer.codec().decode(reader6, reader6.uint32()));
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage2(obj, Message4.codec());
  };
  Message4.decode = (buf2) => {
    return decodeMessage2(buf2, Message4.codec());
  };
})(Message || (Message = {}));

// node_modules/@libp2p/kad-dht/dist/src/message/index.js
var MESSAGE_TYPE = Message.MessageType;
var CONNECTION_TYPE = Message.ConnectionType;
var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
var Message2 = class {
  constructor(type, key, level) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("Key must be a Uint8Array");
    }
    this.type = type;
    this.key = key;
    this.clusterLevelRaw = level;
    this.closerPeers = [];
    this.providerPeers = [];
    this.record = void 0;
  }
  get clusterLevel() {
    const level = this.clusterLevelRaw - 1;
    if (level < 0) {
      return 0;
    }
    return level;
  }
  set clusterLevel(level) {
    this.clusterLevelRaw = level;
  }
  serialize() {
    return Message.encode({
      key: this.key,
      type: this.type,
      clusterLevelRaw: this.clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer),
      record: this.record == null ? void 0 : this.record.serialize().subarray()
    });
  }
  static deserialize(raw) {
    const dec = Message.decode(raw);
    const msg = new Message2(dec.type ?? Message.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);
    msg.closerPeers = dec.closerPeers.map(fromPbPeer);
    msg.providerPeers = dec.providerPeers.map(fromPbPeer);
    if (dec.record?.length != null) {
      msg.record = Libp2pRecord.deserialize(dec.record);
    }
    return msg;
  }
};
function toPbPeer(peer) {
  const output = {
    id: peer.id.toBytes(),
    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output;
}
function fromPbPeer(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),
    protocols: []
  };
}

// node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendingQueryEvent(fields) {
  return {
    ...fields,
    name: "SENDING_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: MESSAGE_TYPE_LOOKUP.indexOf(fields.type.toString())
  };
}
function peerResponseEvent(fields) {
  return {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer != null ? fields.closer : [],
    providers: fields.providers != null ? fields.providers : []
  };
}
function finalPeerEvent(fields) {
  return {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
}
function queryErrorEvent(fields) {
  return {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
}
function providerEvent(fields) {
  return {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
}
function valueEvent(fields) {
  return {
    ...fields,
    name: "VALUE",
    type: 5
  };
}
function dialingPeerEvent(fields) {
  return {
    ...fields,
    name: "DIALING_PEER",
    type: 7
  };
}

// node_modules/@libp2p/kad-dht/dist/src/network.js
var Network = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.components = new Components();
    const { protocol: protocol4, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
    this.running = false;
    this.protocol = protocol4;
  }
  init(components) {
    this.components = components;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  async stop() {
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  async *sendRequest(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    let stream;
    try {
      const connection = await this.components.getConnectionManager().openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      const response = await this._writeReadMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closerPeers,
        providers: response.providerPeers,
        record: response.record
      });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  async *sendMessage(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    let stream;
    try {
      const connection = await this.components.getConnectionManager().openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      await this._writeMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({ from: to, messageType: msg.type });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  async _writeMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    await pipe([msg], encode52(), stream, import_it_drain14.default);
  }
  async _writeReadMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    const res = await pipe([msg], encode52(), stream, decode62(), async (source) => {
      const buf2 = await (0, import_it_first9.default)(source);
      if (buf2 != null) {
        return buf2;
      }
      throw (0, import_err_code118.default)(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
    });
    const message6 = Message2.deserialize(res);
    message6.closerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    message6.providerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    return message6;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var import_err_code121 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/record/dist/src/validators.js
var import_err_code119 = __toESM(require_err_code());

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity_exports25 = {};
__export(identity_exports25, {
  identity: () => identity25
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/vendor/base-x.js
function base19(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src15 = base19;
var _brrp__multiformats_scope_baseX15 = src15;
var base_x_default15 = _brrp__multiformats_scope_baseX15;

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bytes.js
var empty16 = new Uint8Array(0);
var equals33 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce15 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString24 = (str) => new TextEncoder().encode(str);
var toString25 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base.js
var Encoder16 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder16 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or16(this, decoder);
  }
};
var ComposedDecoder15 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or16(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or16 = (left, right) => new ComposedDecoder15({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec15 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder16(name22, prefix, baseEncode);
    this.decoder = new Decoder16(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from27 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec15(name22, prefix, encode81, decode97);
var baseX15 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default15(alphabet16, name22);
  return from27({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce15(decode97(text))
  });
};
var decode80 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode68 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464815 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from27({
    prefix,
    name: name22,
    encode(input) {
      return encode68(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode80(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity25 = from27({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString25(buf2),
  decode: (str) => fromString24(str)
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base2.js
var base2_exports13 = {};
__export(base2_exports13, {
  base2: () => base214
});
var base214 = rfc464815({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base8.js
var base8_exports13 = {};
__export(base8_exports13, {
  base8: () => base813
});
var base813 = rfc464815({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base10_exports13 = {};
__export(base10_exports13, {
  base10: () => base1013
});
var base1013 = baseX15({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base16.js
var base16_exports13 = {};
__export(base16_exports13, {
  base16: () => base1613,
  base16upper: () => base16upper13
});
var base1613 = rfc464815({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper13 = rfc464815({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base32.js
var base32_exports13 = {};
__export(base32_exports13, {
  base32: () => base3215,
  base32hex: () => base32hex15,
  base32hexpad: () => base32hexpad15,
  base32hexpadupper: () => base32hexpadupper15,
  base32hexupper: () => base32hexupper15,
  base32pad: () => base32pad15,
  base32padupper: () => base32padupper15,
  base32upper: () => base32upper15,
  base32z: () => base32z15
});
var base3215 = rfc464815({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper15 = rfc464815({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad15 = rfc464815({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper15 = rfc464815({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex15 = rfc464815({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper15 = rfc464815({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad15 = rfc464815({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper15 = rfc464815({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z15 = rfc464815({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base36.js
var base36_exports13 = {};
__export(base36_exports13, {
  base36: () => base3613,
  base36upper: () => base36upper13
});
var base3613 = baseX15({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper13 = baseX15({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base58.js
var base58_exports13 = {};
__export(base58_exports13, {
  base58btc: () => base58btc15,
  base58flickr: () => base58flickr15
});
var base58btc15 = baseX15({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr15 = baseX15({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base64.js
var base64_exports13 = {};
__export(base64_exports13, {
  base64: () => base6414,
  base64pad: () => base64pad14,
  base64url: () => base64url14,
  base64urlpad: () => base64urlpad14
});
var base6414 = rfc464815({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad14 = rfc464815({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url14 = rfc464815({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad14 = rfc464815({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports13 = {};
__export(base256emoji_exports13, {
  base256emoji: () => base256emoji13
});
var alphabet14 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars13 = alphabet14.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes13 = alphabet14.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode69(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars13[c];
    return p;
  }, "");
}
function decode81(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes13[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji13 = from27({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode69,
  decode: decode81
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports13 = {};
__export(sha2_browser_exports13, {
  sha256: () => sha25613,
  sha512: () => sha51213
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/vendor/varint.js
var encode_114 = encode70;
var MSB14 = 128;
var REST14 = 127;
var MSBALL14 = ~REST14;
var INT14 = Math.pow(2, 31);
function encode70(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT14) {
    out[offset++] = num & 255 | MSB14;
    num /= 128;
  }
  while (num & MSBALL14) {
    out[offset++] = num & 255 | MSB14;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode70.bytes = offset - oldOffset + 1;
  return out;
}
var decode82 = read15;
var MSB$114 = 128;
var REST$114 = 127;
function read15(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read15.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$114) << shift : (b & REST$114) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$114);
  read15.bytes = counter - offset;
  return res;
}
var N115 = Math.pow(2, 7);
var N215 = Math.pow(2, 14);
var N315 = Math.pow(2, 21);
var N415 = Math.pow(2, 28);
var N515 = Math.pow(2, 35);
var N615 = Math.pow(2, 42);
var N715 = Math.pow(2, 49);
var N815 = Math.pow(2, 56);
var N915 = Math.pow(2, 63);
var length18 = function(value2) {
  return value2 < N115 ? 1 : value2 < N215 ? 2 : value2 < N315 ? 3 : value2 < N415 ? 4 : value2 < N515 ? 5 : value2 < N615 ? 6 : value2 < N715 ? 7 : value2 < N815 ? 8 : value2 < N915 ? 9 : 10;
};
var varint20 = {
  encode: encode_114,
  decode: decode82,
  encodingLength: length18
};
var _brrp_varint14 = varint20;
var varint_default14 = _brrp_varint14;

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/varint.js
var decode83 = (data, offset = 0) => {
  const code22 = varint_default14.decode(data, offset);
  return [code22, varint_default14.decode.bytes];
};
var encodeTo14 = (int, target, offset = 0) => {
  varint_default14.encode(int, target, offset);
  return target;
};
var encodingLength14 = (int) => {
  return varint_default14.encodingLength(int);
};

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/digest.js
var create20 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength14(code22);
  const digestOffset = sizeOffset + encodingLength14(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo14(code22, bytes2, 0);
  encodeTo14(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest14(code22, size, digest15, bytes2);
};
var decode84 = (multihash) => {
  const bytes2 = coerce15(multihash);
  const [code22, sizeOffset] = decode83(bytes2);
  const [size, digestOffset] = decode83(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest14(code22, size, digest15, bytes2);
};
var equals34 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals33(a.bytes, data.bytes);
  }
};
var Digest14 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/hasher.js
var from28 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher13(name22, code22, encode81);
var Hasher13 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create20(this.code, result) : result.then((digest15) => create20(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha13 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25613 = from28({
  name: "sha2-256",
  code: 18,
  encode: sha13("SHA-256")
});
var sha51213 = from28({
  name: "sha2-512",
  code: 19,
  encode: sha13("SHA-512")
});

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var identity_exports26 = {};
__export(identity_exports26, {
  identity: () => identity26
});
var code19 = 0;
var name20 = "identity";
var encode71 = coerce15;
var digest13 = (input) => create20(code19, encode71(input));
var identity26 = { code: code19, name: name20, encode: encode71, digest: digest13 };

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/codecs/json.js
var textEncoder16 = new TextEncoder();
var textDecoder15 = new TextDecoder();

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/cid.js
var format13 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV014(
        bytes2,
        baseCache13(link),
        base30 || base58btc15.encoder
      );
    default:
      return toStringV114(
        bytes2,
        baseCache13(link),
        base30 || base3215.encoder
      );
  }
};
var cache15 = /* @__PURE__ */ new WeakMap();
var baseCache13 = (cid) => {
  const baseCache16 = cache15.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache15.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID14 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE14) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE14) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID14.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create20(code22, digest15);
        return CID14.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID14.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals34(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format13(this, base30);
  }
  toJSON() {
    return { "/": format13(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID14) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID14(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID15(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol14] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode84(multihash);
      return CID14.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE14) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE14}) block encoding`
          );
        } else {
          return new CID14(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID15(version4, code22, digest15.bytes);
        return new CID14(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID14.create(0, DAG_PB_CODE14, digest15);
  }
  static createV1(code22, digest15) {
    return CID14.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID14.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID14.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce15(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest14(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID14.createV0(digest15) : CID14.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode83(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE14;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes14(source, base30);
    const cid = CID14.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache13(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes14 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc15;
      return [
        base58btc15.prefix,
        decoder.decode(`${base58btc15.prefix}${source}`)
      ];
    }
    case base58btc15.prefix: {
      const decoder = base30 || base58btc15;
      return [base58btc15.prefix, decoder.decode(source)];
    }
    case base3215.prefix: {
      const decoder = base30 || base3215;
      return [base3215.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV014 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc15.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV114 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE14 = 112;
var SHA_256_CODE14 = 18;
var encodeCID15 = (version4, code22, multihash) => {
  const codeOffset = encodingLength14(version4);
  const hashOffset = codeOffset + encodingLength14(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo14(version4, bytes2, 0);
  encodeTo14(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol14 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/record/node_modules/uint8arrays/node_modules/multiformats/src/basics.js
var bases13 = { ...identity_exports25, ...base2_exports13, ...base8_exports13, ...base10_exports13, ...base16_exports13, ...base32_exports13, ...base36_exports13, ...base58_exports13, ...base64_exports13, ...base256emoji_exports13 };
var hashes13 = { ...sha2_browser_exports13, ...identity_exports26 };

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array14(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe15(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array14(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec17(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string12 = createCodec17("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii12 = createCodec17("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe15(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES12 = {
  utf8: string12,
  "utf-8": string12,
  hex: bases13.base16,
  latin1: ascii12,
  ascii: ascii12,
  binary: ascii12,
  ...bases13
};
var bases_default12 = BASES12;

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/to-string.js
function toString26(array, encoding = "utf8") {
  const base30 = bases_default12[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base30.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/record/node_modules/multiformats/src/bytes.js
var empty17 = new Uint8Array(0);

// node_modules/@libp2p/record/node_modules/multiformats/vendor/varint.js
var encode_115 = encode72;
var MSB15 = 128;
var REST15 = 127;
var MSBALL15 = ~REST15;
var INT15 = Math.pow(2, 31);
function encode72(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT15) {
    out[offset++] = num & 255 | MSB15;
    num /= 128;
  }
  while (num & MSBALL15) {
    out[offset++] = num & 255 | MSB15;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode72.bytes = offset - oldOffset + 1;
  return out;
}
var decode85 = read16;
var MSB$115 = 128;
var REST$115 = 127;
function read16(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read16.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$115) << shift : (b & REST$115) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$115);
  read16.bytes = counter - offset;
  return res;
}
var N116 = Math.pow(2, 7);
var N216 = Math.pow(2, 14);
var N316 = Math.pow(2, 21);
var N416 = Math.pow(2, 28);
var N516 = Math.pow(2, 35);
var N616 = Math.pow(2, 42);
var N716 = Math.pow(2, 49);
var N816 = Math.pow(2, 56);
var N916 = Math.pow(2, 63);
var length19 = function(value2) {
  return value2 < N116 ? 1 : value2 < N216 ? 2 : value2 < N316 ? 3 : value2 < N416 ? 4 : value2 < N516 ? 5 : value2 < N616 ? 6 : value2 < N716 ? 7 : value2 < N816 ? 8 : value2 < N916 ? 9 : 10;
};
var varint21 = {
  encode: encode_115,
  decode: decode85,
  encodingLength: length19
};
var _brrp_varint15 = varint21;
var varint_default15 = _brrp_varint15;

// node_modules/@libp2p/record/node_modules/multiformats/src/varint.js
var encodeTo15 = (int, target, offset = 0) => {
  varint_default15.encode(int, target, offset);
  return target;
};
var encodingLength15 = (int) => {
  return varint_default15.encodingLength(int);
};

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/digest.js
var create21 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength15(code22);
  const digestOffset = sizeOffset + encodingLength15(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo15(code22, bytes2, 0);
  encodeTo15(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest15(code22, size, digest15, bytes2);
};
var Digest15 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/hasher.js
var from29 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher14(name22, code22, encode81);
var Hasher14 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create21(this.code, result) : result.then((digest15) => create21(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/sha2-browser.js
var sha14 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25614 = from29({
  name: "sha2-256",
  code: 18,
  encode: sha14("SHA-256")
});
var sha51214 = from29({
  name: "sha2-512",
  code: 19,
  encode: sha14("SHA-512")
});

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/equals.js
function equals36(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/record/dist/src/validators.js
function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString26(key);
  const parts2 = keyString.split("/");
  if (parts2.length < 3) {
    return;
  }
  const validator = validators2[parts2[1].toString()];
  if (validator == null) {
    const errMsg = "Invalid record keytype";
    throw (0, import_err_code119.default)(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
  }
  return validator(key, record.value);
}
var validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw (0, import_err_code119.default)(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw (0, import_err_code119.default)(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString26(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw (0, import_err_code119.default)(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha25614.digest(publicKey);
  if (!equals36(keyhash, publicKeyHash.bytes)) {
    throw (0, import_err_code119.default)(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// node_modules/@libp2p/record/dist/src/selectors.js
var import_err_code120 = __toESM(require_err_code());
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw (0, import_err_code120.default)(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString26(k);
  const parts2 = kStr.split("/");
  if (parts2.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw (0, import_err_code120.default)(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts2[1].toString()];
  if (selector == null) {
    const errMsg = `Unrecognized key prefix: ${parts2[1]}`;
    throw (0, import_err_code120.default)(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
var selectors = {
  pk: publickKey
};

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var import_it_parallel3 = __toESM(require_it_parallel(), 1);
var import_it_map15 = __toESM(require_it_map(), 1);
var ContentFetching = class {
  constructor(init) {
    this.components = new Components();
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, routingTable, network, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.network = network;
  }
  init(components) {
    this.components = components;
  }
  async putLocal(key, rec) {
    const dsKey = bufferToRecordKey(key);
    await this.components.getDatastore().put(dsKey, rec);
  }
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.getDatastore().get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  async *sendCorrectionRecord(key, vals, best, options = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = await createPutRecord(key, best);
    for (const { value: value2, from: from33 } of vals) {
      if (equals15(value2, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.getPeerId().equals(from33)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.getDatastore().put(dsKey, fixupRec.subarray());
        } catch (err2) {
          this.log.error("Failed error correcting self", err2);
        }
        continue;
      }
      let sentCorrection = false;
      const request2 = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
      request2.record = Libp2pRecord.deserialize(fixupRec);
      for await (const event of this.network.sendRequest(from33, request2, options)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals15(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from33, error: (0, import_err_code121.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") });
      }
      this.log.error("Failed error correcting entry");
    }
  }
  async *put(key, value2, options = {}) {
    this.log("put key %b value %b", key, value2);
    const record = await createPutRecord(key, value2);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.getDatastore().put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => (0, import_it_map15.default)(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
        msg.record = Libp2pRecord.deserialize(record);
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals15(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: (0, import_err_code121.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") }));
          }
        }
        return events2;
      };
    }), (source) => (0, import_it_parallel3.default)(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
  }
  async *get(key, options = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i2 = 0;
    try {
      i2 = bestRecord(this.selectors, key, records);
    } catch (err2) {
      if (err2.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err2;
      }
    }
    const best = records[i2];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw (0, import_err_code121.default)(new Error("best value was not found"), "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options);
    yield vals[i2];
  }
  async *getMany(key, options = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.getPeerId()
      });
    } catch (err2) {
      this.log("error getting local value for %b", key, err2);
    }
    const id = await convertBuffer(key);
    const rtp = this.routingTable.closestPeers(id);
    this.log("found %d peers in routing table", rtp.length);
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value });
        }
      }
    };
    yield* this.queryManager.run(key, rtp, getValueQuery, options);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var import_it_parallel4 = __toESM(require_it_parallel(), 1);
var import_it_map16 = __toESM(require_it_map(), 1);
var ContentRouting = class {
  constructor(init) {
    this.components = new Components();
    const { network, peerRouting, queryManager, routingTable, providers, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  init(components) {
    this.components = components;
  }
  async *provide(key, multiaddrs, options = {}) {
    this.log("provide %s", key);
    await this.providers.addProvider(key, this.components.getPeerId());
    const msg = new Message2(MESSAGE_TYPE.ADD_PROVIDER, key.bytes, 0);
    msg.providerPeers = [{
      id: this.components.getPeerId(),
      multiaddrs,
      protocols: []
    }];
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err2) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err2);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err2 }));
        }
        return events2;
      };
    };
    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), (source) => (0, import_it_map16.default)(source, (event) => maybeNotifyPeer(event)), (source) => (0, import_it_parallel4.default)(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  async *findProviders(key, options) {
    const toFind = this.routingTable.kBucketSize;
    const target = key.multihash.bytes;
    const id = await convertBuffer(target);
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        providers2.push({
          id: peerId,
          multiaddrs: (await this.components.getPeerStore().addressBook.get(peerId) ?? []).map((address) => address.multiaddr),
          protocols: []
        });
      }
      yield peerResponseEvent({ from: this.components.getPeerId(), messageType: MESSAGE_TYPE.GET_PROVIDERS, providers: providers2 });
      yield providerEvent({ from: this.components.getPeerId(), providers: providers2 });
    }
    if (provs.length >= toFind) {
      return;
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.GET_PROVIDERS, target, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    const providers = new Set(provs.map((p) => p.toString()));
    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id.toString())) {
            continue;
          }
          providers.add(peer.id.toString());
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders });
        }
        if (providers.size === toFind) {
          return;
        }
      }
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var import_err_code122 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
var PeerDistanceList = class {
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  get length() {
    return this.peerDistances.length;
  }
  get peers() {
    return this.peerDistances.map((pd) => pd.peerId);
  }
  async add(peerId) {
    if (this.peerDistances.find((pd) => pd.peerId.equals(peerId)) != null) {
      return;
    }
    const dhtKey = await convertPeerId(peerId);
    const el = {
      peerId,
      distance: xor(this.originDhtKey, dhtKey)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => compare3(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    if (this.length === 0) {
      return true;
    }
    const dhtKeys = await Promise.all(peerIds.map(convertPeerId));
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    for (const dhtKey of dhtKeys) {
      const keyDistance = xor(this.originDhtKey, dhtKey);
      if (compare3(keyDistance, furthestDistance) < 0) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  constructor(init) {
    this.components = new Components();
    const { routingTable, network, validators: validators2, queryManager, lan } = init;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators2;
    this.queryManager = queryManager;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
  }
  init(components) {
    this.components = components;
  }
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.getPeerStore().get(p);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.getPeerStore().get(peer);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr),
        protocols: []
      };
    }
    return void 0;
  }
  async *_getValueSingle(peer, key, options = {}) {
    const msg = new Message2(MESSAGE_TYPE.GET_VALUE, key, 0);
    yield* this.network.sendRequest(peer, msg, options);
  }
  async *getPublicKeyFromNode(peer, options = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(keys_exports2.marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw (0, import_err_code122.default)(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw (0, import_err_code122.default)(new Error("public key missing"), "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey });
      }
    }
    throw (0, import_err_code122.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), "ERR_INVALID_RECORD");
  }
  async *findPeer(id, options = {}) {
    this.log("findPeer %p", id);
    const pi = await this.findPeerLocal(id);
    if (pi != null) {
      this.log("found local");
      yield finalPeerEvent({
        from: this.components.getPeerId(),
        peer: pi
      });
      return;
    }
    const key = await convertPeerId(id);
    const peers = this.routingTable.closestPeers(key);
    const match = peers.find((p) => p.equals(id));
    if (match != null) {
      try {
        const peer = await this.components.getPeerStore().get(id);
        this.log("found in peerStore");
        yield finalPeerEvent({
          from: this.components.getPeerId(),
          peer: {
            id: peer.id,
            multiaddrs: peer.addresses.map((address) => address.multiaddr),
            protocols: []
          }
        });
        return;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    const self2 = this;
    const findPeerQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);
      for await (const event of self2.network.sendRequest(peer, request2, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          const match2 = event.closer.find((p) => p.id.equals(id));
          if (match2 != null) {
            yield finalPeerEvent({ from: event.from, peer: match2 });
          }
        }
      }
    };
    let foundPeer = false;
    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {
      if (event.name === "FINAL_PEER") {
        foundPeer = true;
      }
      yield event;
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.components.getPeerId(), error: (0, import_err_code122.default)(new Error("Not found"), "ERR_NOT_FOUND") });
    }
  }
  async *getClosestPeers(key, options = {}) {
    this.log("getClosestPeers to %b", key);
    const id = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(id);
    const self2 = this;
    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => await peers.add(peer)));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString11(key, "base32"), peer);
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, key, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => await peers.add(peerData.id)));
      }
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.components.getPeerId(),
        peer: {
          id: peer,
          multiaddrs: (await this.components.getPeerStore().addressBook.get(peer) ?? []).map((addr) => addr.multiaddr),
          protocols: []
        }
      });
    }
  }
  async *getValueOrPeers(peer, key, options = {}) {
    for await (const event of this._getValueSingle(peer, key, options)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err2) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: (0, import_err_code122.default)(new Error(errMsg), "ERR_INVALID_RECORD") });
            continue;
          }
        }
      }
      yield event;
    }
  }
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw (0, import_err_code122.default)(new Error("invalid record received"), "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output = [];
    for (const peerId of ids) {
      if (peerId.equals(closerThan)) {
        continue;
      }
      try {
        const addresses = await this.components.getPeerStore().addressBook.get(peerId);
        const protocols = await this.components.getPeerStore().protoBook.get(peerId);
        output.push({
          id: peerId,
          multiaddrs: addresses.map((address) => address.multiaddr),
          protocols
        });
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (output.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
    }
    return output;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var import_hashlru5 = __toESM(require_hashlru(), 1);
var import_varint22 = __toESM(require_varint(), 1);
var log93 = logger("libp2p:kad-dht:providers");
var Providers = class {
  constructor(init = {}) {
    this.components = new Components();
    const { cacheSize, cleanupInterval, provideValidity } = init;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = (0, import_hashlru5.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new PQueue({ concurrency: 1 });
    this.started = false;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err2) => {
        log93.error(err2);
      });
    }, this.cleanupInterval);
  }
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  async _cleanup() {
    return await this.syncQueue.add(async () => {
      const start = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch3 = this.components.getDatastore().batch();
      const query = this.components.getDatastore().query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          log93("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch3.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err2) {
          log93.error(err2.message);
        }
      }
      if (deleted.size > 0) {
        log93("deleting %d / %d entries", deleteCount, count);
        await batch3.commit();
      } else {
        log93("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId of peers) {
            provs.delete(peerId);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      log93("Cleanup successful (%dms)", Date.now() - start);
    });
  }
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.components.getDatastore(), cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  async addProvider(cid, provider) {
    return await this.syncQueue.add(async () => {
      log93("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      log93("loaded %s provs", provs.size);
      const now = new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.components.getDatastore(), cid, provider, now);
    });
  }
  async getProviders(cid) {
    return await this.syncQueue.add(async () => {
      log93("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    });
  }
};
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString11(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key(dsKey);
  const buffer2 = Uint8Array.from(import_varint22.default.encode(time.getTime()));
  return await store.put(key, buffer2);
}
function parseProviderKey(key) {
  const parts2 = key.toString().split("/");
  if (parts2.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts2[3],
    peerId: parts2[4]
  };
}
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId } = parseProviderKey(entry.key);
    providers.set(peerId, readTime(entry.value));
  }
  return providers;
}
function readTime(buf2) {
  return new Date(import_varint22.default.decode(buf2));
}

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var import_timeout_abort_controller16 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal9 = __toESM(require_any_signal(), 1);

// node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
var import_err_code123 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller15 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal8 = __toESM(require_any_signal(), 1);
var MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
async function* queryPath(options) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log108, peersSeen } = options;
  const queue = new PQueue({
    concurrency: alpha
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = BigInt("0x" + toString11(xor(peerKadId, kadId), "base16"));
    queue.add(async () => {
      let timeout;
      const signals = [signal];
      if (queryFuncTimeout != null) {
        timeout = new import_timeout_abort_controller15.TimeoutController(queryFuncTimeout);
        signals.push(timeout.signal);
      }
      const compoundSignal = (0, import_any_signal8.anySignal)(signals);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log108("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log108("not querying ourselves");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = BigInt("0x" + toString11(xor(closerPeerKadId, kadId), "base16"));
              if (closerPeerXor > peerXor) {
                log108("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log108("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.emit("completed", event);
        }
        timeout?.clear();
      } catch (err2) {
        if (signal.aborted) {
          queue.emit("error", err2);
        } else {
          queue.emit("completed", queryErrorEvent({
            from: peer,
            error: err2
          }));
        }
      } finally {
        timeout?.clear();
      }
    }, {
      priority: MAX_XOR - peerXor
    }).catch((err2) => {
      log108.error(err2);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  yield* toGenerator(queue, signal, cleanUp, log108);
}
async function* toGenerator(queue, signal, cleanUp, log108) {
  let deferred = pDefer();
  let running = true;
  const results = [];
  const cleanup = () => {
    if (!running) {
      return;
    }
    log108("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
    running = false;
    queue.clear();
    results.splice(0, results.length);
  };
  queue.on("completed", (result) => {
    results.push(result);
    deferred.resolve();
  });
  queue.on("error", (err2) => {
    log108("queue error", err2);
    cleanup();
    deferred.reject(err2);
  });
  queue.on("idle", () => {
    log108("queue idle");
    running = false;
    deferred.resolve();
  });
  signal.addEventListener("abort", () => {
    log108("abort queue");
    const wasRunning = running;
    cleanup();
    if (wasRunning) {
      deferred.reject((0, import_err_code123.default)(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
    }
  });
  cleanUp.addEventListener("cleanup", () => {
    cleanup();
    deferred.resolve();
  });
  while (running) {
    await deferred.promise;
    deferred = pDefer();
    while (results.length > 0) {
      const result = results.shift();
      if (result != null) {
        yield result;
      }
    }
  }
  yield* results;
}

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var import_it_merge7 = __toESM(require_it_merge(), 1);
var import_events40 = __toESM(require_events(), 1);
var METRIC_RUNNING_QUERIES = "running-queries";
var QueryManager = class {
  constructor(init) {
    this.components = new Components();
    const { lan = false, disjointPaths = K, alpha = ALPHA } = init;
    this.disjointPaths = disjointPaths ?? K;
    this.controllers = /* @__PURE__ */ new Set();
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.lan = lan;
    this.queries = 0;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
  }
  async stop() {
    this.running = false;
    for (const controller of this.controllers) {
      controller.abort();
    }
    this.controllers.clear();
  }
  async *run(key, peers, queryFunc, options = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    let timeoutController;
    if (options.signal == null) {
      timeoutController = new import_timeout_abort_controller16.TimeoutController(DEFAULT_QUERY_TIMEOUT);
      options.signal = timeoutController.signal;
      try {
        if (import_events40.setMaxListeners != null) {
          (0, import_events40.setMaxListeners)(Infinity, timeoutController.signal);
        }
      } catch {
      }
    }
    const abortController = new AbortController();
    this.controllers.add(abortController);
    const signals = [abortController.signal];
    if (options.signal != null) {
      signals.push(options.signal);
    }
    const signal = (0, import_any_signal9.anySignal)(signals);
    try {
      if (import_events40.setMaxListeners != null) {
        (0, import_events40.setMaxListeners)(Infinity, signal);
      }
    } catch {
    }
    const log108 = logger(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + toString11(key, "base58btc"));
    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
    const startTime = Date.now();
    const cleanUp = new EventEmitter2();
    try {
      log108("query:start");
      this.queries++;
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      if (peers.length === 0) {
        log108.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.components.getPeerId(),
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          cleanUp,
          queryFuncTimeout: options.queryFuncTimeout,
          log: log108,
          peersSeen
        });
      });
      for await (const event of (0, import_it_merge7.default)(...paths)) {
        yield event;
        if (event.name === "QUERY_ERROR") {
          log108("error", event.error);
        }
      }
    } catch (err2) {
      if (!this.running && err2.code === "ERR_QUERY_ABORTED") {
      } else {
        throw err2;
      }
    } finally {
      this.controllers.delete(abortController);
      if (timeoutController != null) {
        timeoutController.clear();
      }
      this.queries--;
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      cleanUp.dispatchEvent(new CustomEvent("cleanup"));
      log108("query:done in %dms", Date.now() - startTime);
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var import_err_code124 = __toESM(require_err_code(), 1);
var log94 = logger("libp2p:kad-dht:rpc:handlers:add-provider");
var AddProviderHandler = class {
  constructor(init) {
    const { providers } = init;
    this.providers = providers;
  }
  init() {
  }
  async handle(peerId, msg) {
    log94("start");
    if (msg.key == null || msg.key.length === 0) {
      throw (0, import_err_code124.default)(new Error("Missing key"), "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code124.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    if (msg.providerPeers == null || msg.providerPeers.length === 0) {
      log94.error("no providers found in message");
    }
    await Promise.all(msg.providerPeers.map(async (pi) => {
      if (!pi.id.equals(peerId)) {
        log94("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        log94("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      log94("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m) => m.toString()));
      await this.providers.addProvider(cid, pi.id);
    }));
    return void 0;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var log95 = logger("libp2p:kad-dht:rpc:handlers:find-node");
var FindNodeHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, lan } = init;
    this.peerRouting = peerRouting;
    this.lan = Boolean(lan);
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    log95("incoming request from %p for peers closer to %b", peerId, msg.key);
    let closer = [];
    if (equals15(this.components.getPeerId().toBytes(), msg.key)) {
      closer = [{
        id: this.components.getPeerId(),
        multiaddrs: this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code)),
        protocols: []
      }];
    } else {
      closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    }
    closer = closer.map(this.lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
    const response = new Message2(msg.type, new Uint8Array(0), msg.clusterLevel);
    if (closer.length > 0) {
      response.closerPeers = closer;
    } else {
      log95("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var import_err_code125 = __toESM(require_err_code(), 1);
var log96 = logger("libp2p:kad-dht:rpc:handlers:get-providers");
var GetProvidersHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, providers, lan } = init;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.lan = Boolean(lan);
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code125.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    log96("%p asking for providers for %s", peerId, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = new Message2(msg.type, msg.key, msg.clusterLevel);
    if (providerPeers.length > 0) {
      response.providerPeers = providerPeers;
    }
    if (closerPeers.length > 0) {
      response.closerPeers = closerPeers;
    }
    log96("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
    return response;
  }
  async _getAddresses(peerId) {
    const addrs = await this.components.getPeerStore().addressBook.get(peerId);
    return addrs.map((address) => address.multiaddr);
  }
  async _getPeers(peerIds) {
    const output = [];
    const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;
    for (const peerId of peerIds) {
      const peer = addrFilter({
        id: peerId,
        multiaddrs: await this._getAddresses(peerId),
        protocols: []
      });
      if (peer.multiaddrs.length > 0) {
        output.push(peer);
      }
    }
    return output;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var import_err_code126 = __toESM(require_err_code(), 1);
var log97 = logger("libp2p:kad-dht:rpc:handlers:get-value");
var GetValueHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting } = init;
    this.peerRouting = peerRouting;
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    log97("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw (0, import_err_code126.default)(new Error("Invalid key"), "ERR_INVALID_KEY");
    }
    const response = new Message2(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
    if (isPublicKeyKey(key)) {
      log97("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const key2 = await this.components.getPeerStore().keyBook.get(idFromKey);
        if (key2 == null) {
          throw (0, import_err_code126.default)(new Error("No public key found in key book"), "ERR_NOT_FOUND");
        }
        pubKey = key2;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
      if (pubKey != null) {
        log97("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, new Date());
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    if (record != null) {
      log97("had record for %b in local datastore", key);
      response.record = record;
    }
    if (closer.length > 0) {
      log97("had %s closer peers in routing table", closer.length);
      response.closerPeers = closer;
    }
    return response;
  }
  async _checkLocalDatastore(key) {
    log97("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.components.getDatastore().get(dsKey);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err2;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw (0, import_err_code126.default)(new Error("Invalid record"), "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.components.getDatastore().delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var log98 = logger("libp2p:kad-dht:rpc:handlers:ping");
var PingHandler = class {
  async handle(peerId, msg) {
    log98("ping from %p", peerId);
    return msg;
  }
  init() {
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var import_err_code127 = __toESM(require_err_code(), 1);
var PutValueHandler = class {
  constructor(init) {
    this.components = new Components();
    const { validators: validators2 } = init;
    this.log = logger("libp2p:kad-dht:rpc:handlers:put-value");
    this.validators = validators2;
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    const record = msg.record;
    if (record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw (0, import_err_code127.default)(new Error(errMsg), "ERR_EMPTY_RECORD");
    }
    try {
      await verifyRecord(this.validators, record);
      record.timeReceived = new Date();
      const recordKey = bufferToRecordKey(record.key);
      await this.components.getDatastore().put(recordKey, record.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err2) {
      this.log("did not put record for key %b into datastore %o", key, err2);
    }
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC2 = class {
  constructor(init) {
    const { providers, peerRouting, validators: validators2, lan } = init;
    this.log = logger("libp2p:kad-dht:rpc");
    this.routingTable = init.routingTable;
    this.handlers = {
      [MESSAGE_TYPE.GET_VALUE]: new GetValueHandler({ peerRouting }),
      [MESSAGE_TYPE.PUT_VALUE]: new PutValueHandler({ validators: validators2 }),
      [MESSAGE_TYPE.FIND_NODE]: new FindNodeHandler({ peerRouting, lan }),
      [MESSAGE_TYPE.ADD_PROVIDER]: new AddProviderHandler({ providers }),
      [MESSAGE_TYPE.GET_PROVIDERS]: new GetProvidersHandler({ peerRouting, providers, lan }),
      [MESSAGE_TYPE.PING]: new PingHandler()
    };
  }
  init(components) {
    for (const handler of Object.values(this.handlers)) {
      handler.init(components);
    }
  }
  async handleMessage(peerId, msg) {
    try {
      await this.routingTable.add(peerId);
    } catch (err2) {
      this.log.error("Failed to update the kbucket store", err2);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return await handler.handle(peerId, msg);
  }
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId = connection.remotePeer;
      try {
        await this.routingTable.add(peerId);
      } catch (err2) {
        this.log.error(err2);
      }
      const self2 = this;
      await pipe(stream, decode62(), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message2.deserialize(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield res.serialize();
          }
        }
      }, encode52(), stream);
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.components = new Components();
    const { protocol: protocol4, lan } = init;
    this.log = logger(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}`);
    this.running = false;
    this.protocol = protocol4;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const topology = createTopology({
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
    this.registrarId = await this.components.getRegistrar().register(this.protocol, topology);
  }
  stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.getRegistrar().unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var import_events43 = __toESM(require_events(), 1);
var import_it_take5 = __toESM(require_it_take(), 1);
var import_it_length4 = __toESM(require_it_length(), 1);
var import_timeout_abort_controller17 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal10 = __toESM(require_any_signal(), 1);
var QuerySelf = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, lan, count, interval, queryTimeout } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
    this.running = false;
    this.peerRouting = peerRouting;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this._querySelf();
  }
  async stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  _querySelf() {
    Promise.resolve().then(async () => {
      const timeoutController = new import_timeout_abort_controller17.TimeoutController(this.queryTimeout);
      try {
        this.controller = new AbortController();
        const signal = (0, import_any_signal10.anySignal)([this.controller.signal, timeoutController.signal]);
        try {
          if (import_events43.setMaxListeners != null) {
            (0, import_events43.setMaxListeners)(Infinity, signal);
          }
        } catch {
        }
        const found = await pipe(this.peerRouting.getClosestPeers(this.components.getPeerId().toBytes(), {
          signal
        }), (source) => (0, import_it_take5.default)(source, this.count), async (source) => await (0, import_it_length4.default)(source));
        this.log("query ran successfully - found %d peers", found);
      } catch (err2) {
        this.log("query error", err2);
      } finally {
        this.timeoutId = setTimeout(this._querySelf.bind(this), this.interval);
        timeoutController.clear();
      }
    }).catch((err2) => {
      this.log("query error", err2);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var KadDHT = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.components = new Components();
    const { kBucketSize, clientMode, validators: validators2, selectors: selectors2, querySelfInterval, lan, protocolPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams } = init;
    this.running = false;
    this.lan = Boolean(lan);
    this.log = logger(`libp2p:kad-dht:${lan === true ? "lan" : "wan"}`);
    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ""}${PROTOCOL_DHT}`;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
    this.routingTable = new RoutingTable({
      kBucketSize,
      lan: this.lan,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol
    });
    this.providers = new Providers();
    this.validators = {
      ...validators,
      ...validators2
    };
    this.selectors = {
      ...selectors,
      ...selectors2
    };
    this.network = new Network({
      protocol: this.protocol,
      lan: this.lan
    });
    this.queryManager = new QueryManager({
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      lan
    });
    this.peerRouting = new PeerRouting({
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      lan: this.lan
    });
    this.contentFetching = new ContentFetching({
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      network: this.network,
      lan: this.lan
    });
    this.contentRouting = new ContentRouting({
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      lan: this.lan
    });
    this.routingTableRefresh = new RoutingTableRefresh({
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      lan: this.lan
    });
    this.rpc = new RPC2({
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      lan: this.lan
    });
    this.topologyListener = new TopologyListener({
      protocol: this.protocol,
      lan: this.lan
    });
    this.querySelf = new QuerySelf({
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      lan: this.lan
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err2) => {
        this.log.error("could not add %p to routing table", peerData.id, err2);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const multiaddrs = await this.components.getPeerStore().addressBook.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: multiaddrs.map((addr) => addr.multiaddr),
          protocols: []
        };
        await this.onPeerConnect(peerData);
      }).catch((err2) => {
        this.log.error("could not add %p to routing table", peerId, err2);
      });
    });
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/kad-dht";
  }
  init(components) {
    this.components = components;
    this.routingTable.init(components);
    this.providers.init(components);
    this.network.init(components);
    this.queryManager.init(components);
    this.peerRouting.init(components);
    this.contentFetching.init(components);
    this.contentRouting.init(components);
    this.routingTableRefresh.init(components);
    this.rpc.init(components);
    this.topologyListener.init(components);
    this.querySelf.init(components);
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected with protocols %s", peerData.id, peerData.protocols);
    if (this.lan) {
      peerData = removePublicAddresses(peerData);
    } else {
      peerData = removePrivateAddresses(peerData);
    }
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this.lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err2) {
      this.log.error("could not add %p to routing table", peerData.id, err2);
    }
  }
  isStarted() {
    return this.running;
  }
  async getMode() {
    return this.clientMode ? "client" : "server";
  }
  async setMode(mode) {
    await this.components.getRegistrar().unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.getRegistrar().handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await Promise.all([
      this.providers.start(),
      this.queryManager.start(),
      this.network.start(),
      this.routingTable.start(),
      this.topologyListener.start(),
      this.querySelf.start()
    ]);
    await this.routingTableRefresh.start();
  }
  async stop() {
    this.running = false;
    await Promise.all([
      this.providers.stop(),
      this.queryManager.stop(),
      this.network.stop(),
      this.routingTable.stop(),
      this.routingTableRefresh.stop(),
      this.topologyListener.stop(),
      this.querySelf.stop()
    ]);
  }
  async *put(key, value2, options = {}) {
    yield* this.contentFetching.put(key, value2, options);
  }
  async *get(key, options = {}) {
    yield* this.contentFetching.get(key, options);
  }
  async *provide(key, options = {}) {
    yield* this.contentRouting.provide(key, this.components.getAddressManager().getAddresses(), options);
  }
  async *findProviders(key, options = {}) {
    yield* this.contentRouting.findProviders(key, options);
  }
  async *findPeer(id, options = {}) {
    yield* this.peerRouting.findPeer(id, options);
  }
  async *getClosestPeers(key, options = {}) {
    yield* this.peerRouting.getClosestPeers(key, options);
  }
  async refreshRoutingTable() {
    await this.routingTableRefresh.refreshTable(true);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/dual-kad-dht.js
var import_err_code128 = __toESM(require_err_code(), 1);
var import_it_merge8 = __toESM(require_it_merge(), 1);
var log99 = logger("libp2p:kad-dht");
var DualKadDHT = class extends EventEmitter2 {
  constructor(wan, lan) {
    super();
    this.components = new Components();
    this.wan = wan;
    this.lan = lan;
    this.wan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
    this.lan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dual-kad-dht";
  }
  init(components) {
    this.components = components;
    this.wan.init(components);
    this.lan.init(components);
  }
  isStarted() {
    return this.wan.isStarted() && this.lan.isStarted();
  }
  async getMode() {
    return await this.wan.getMode();
  }
  async setMode(mode) {
    await this.wan.setMode(mode);
  }
  async start() {
    await Promise.all([
      this.lan.start(),
      this.wan.start()
    ]);
  }
  async stop() {
    await Promise.all([
      this.lan.stop(),
      this.wan.stop()
    ]);
  }
  async *put(key, value2, options = {}) {
    for await (const event of (0, import_it_merge8.default)(this.lan.put(key, value2, options), this.wan.put(key, value2, options))) {
      yield event;
    }
  }
  async *get(key, options = {}) {
    let queriedPeers = false;
    let foundValue = false;
    for await (const event of (0, import_it_merge8.default)(this.lan.get(key, options), this.wan.get(key, options))) {
      yield event;
      if (event.name === "DIALING_PEER") {
        queriedPeers = true;
      }
      if (event.name === "VALUE") {
        queriedPeers = true;
        if (event.value != null) {
          foundValue = true;
        }
      }
      if (event.name === "SENDING_QUERY") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code128.default)(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
    }
    if (!foundValue) {
      yield queryErrorEvent({
        from: this.components.getPeerId(),
        error: (0, import_err_code128.default)(new Error("Not found"), "ERR_NOT_FOUND")
      });
    }
  }
  async *provide(key, options = {}) {
    let sent = 0;
    let success = 0;
    const errors2 = [];
    const dhts = [this.lan];
    if (await this.wan.getMode() === "server") {
      dhts.push(this.wan);
    }
    for await (const event of (0, import_it_merge8.default)(...dhts.map((dht) => dht.provide(key, options)))) {
      yield event;
      if (event.name === "SENDING_QUERY") {
        sent++;
      }
      if (event.name === "QUERY_ERROR") {
        errors2.push(event.error);
      }
      if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
        log99("sent provider record for %s to %p", key, event.from);
        success++;
      }
    }
    if (success === 0) {
      if (errors2.length > 0) {
        throw (0, import_err_code128.default)(new Error(`Failed to provide to ${errors2.length} of ${sent} peers`), "ERR_PROVIDES_FAILED", { errors: errors2 });
      }
      throw (0, import_err_code128.default)(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
    }
  }
  async *findProviders(key, options = {}) {
    yield* (0, import_it_merge8.default)(this.lan.findProviders(key, options), this.wan.findProviders(key, options));
  }
  async *findPeer(id, options = {}) {
    let queriedPeers = false;
    for await (const event of (0, import_it_merge8.default)(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {
      yield event;
      if (event.name === "SENDING_QUERY" || event.name === "FINAL_PEER") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code128.default)(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
    }
  }
  async *getClosestPeers(key, options = {}) {
    yield* (0, import_it_merge8.default)(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));
  }
  async refreshRoutingTable() {
    await Promise.all([
      this.lan.refreshRoutingTable(),
      this.wan.refreshRoutingTable()
    ]);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/index.js
var KadDHT2 = class extends DualKadDHT {
  constructor(init) {
    super(new KadDHT({
      protocolPrefix: "/ipfs",
      ...init,
      lan: false
    }), new KadDHT({
      protocolPrefix: "/ipfs",
      ...init,
      clientMode: false,
      lan: true
    }));
  }
};

// node_modules/@libp2p/bootstrap/dist/src/index.js
var log100 = logger("libp2p:bootstrap");
var Bootstrap = class extends EventEmitter2 {
  constructor(options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.interval = options.interval ?? 1e4;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log100.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log100.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/bootstrap";
  }
  isStarted() {
    return Boolean(this.timer);
  }
  start() {
    if (this.timer != null) {
      return;
    }
    this.timer = setInterval(() => this._discoverBootstrapPeers(), this.interval);
    log100("Starting bootstrap node discovery");
    this._discoverBootstrapPeers();
  }
  _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    this.list.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", { detail: peerData }));
    });
  }
  stop() {
    if (this.timer != null) {
      clearInterval(this.timer);
    }
    this.timer = void 0;
  }
};
Bootstrap.tag = "bootstrap";

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);

// node_modules/it-ws/node_modules/multiformats/src/bases/identity.js
var identity_exports27 = {};
__export(identity_exports27, {
  identity: () => identity27
});

// node_modules/it-ws/node_modules/multiformats/vendor/base-x.js
function base20(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src16 = base20;
var _brrp__multiformats_scope_baseX16 = src16;
var base_x_default16 = _brrp__multiformats_scope_baseX16;

// node_modules/it-ws/node_modules/multiformats/src/bytes.js
var empty18 = new Uint8Array(0);
var equals37 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce17 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString25 = (str) => new TextEncoder().encode(str);
var toString27 = (b) => new TextDecoder().decode(b);

// node_modules/it-ws/node_modules/multiformats/src/bases/base.js
var Encoder17 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder17 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or17(this, decoder);
  }
};
var ComposedDecoder16 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or17(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or17 = (left, right) => new ComposedDecoder16({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec16 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder17(name22, prefix, baseEncode);
    this.decoder = new Decoder17(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from30 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec16(name22, prefix, encode81, decode97);
var baseX16 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default16(alphabet16, name22);
  return from30({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce17(decode97(text))
  });
};
var decode87 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode73 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464816 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from30({
    prefix,
    name: name22,
    encode(input) {
      return encode73(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode87(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/it-ws/node_modules/multiformats/src/bases/identity.js
var identity27 = from30({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString27(buf2),
  decode: (str) => fromString25(str)
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base2.js
var base2_exports14 = {};
__export(base2_exports14, {
  base2: () => base215
});
var base215 = rfc464816({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base8.js
var base8_exports14 = {};
__export(base8_exports14, {
  base8: () => base814
});
var base814 = rfc464816({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base10.js
var base10_exports14 = {};
__export(base10_exports14, {
  base10: () => base1014
});
var base1014 = baseX16({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base16.js
var base16_exports14 = {};
__export(base16_exports14, {
  base16: () => base1614,
  base16upper: () => base16upper14
});
var base1614 = rfc464816({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper14 = rfc464816({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base32.js
var base32_exports14 = {};
__export(base32_exports14, {
  base32: () => base3216,
  base32hex: () => base32hex16,
  base32hexpad: () => base32hexpad16,
  base32hexpadupper: () => base32hexpadupper16,
  base32hexupper: () => base32hexupper16,
  base32pad: () => base32pad16,
  base32padupper: () => base32padupper16,
  base32upper: () => base32upper16,
  base32z: () => base32z16
});
var base3216 = rfc464816({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper16 = rfc464816({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad16 = rfc464816({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper16 = rfc464816({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex16 = rfc464816({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper16 = rfc464816({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad16 = rfc464816({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper16 = rfc464816({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z16 = rfc464816({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base36.js
var base36_exports14 = {};
__export(base36_exports14, {
  base36: () => base3614,
  base36upper: () => base36upper14
});
var base3614 = baseX16({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper14 = baseX16({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base58.js
var base58_exports14 = {};
__export(base58_exports14, {
  base58btc: () => base58btc16,
  base58flickr: () => base58flickr16
});
var base58btc16 = baseX16({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr16 = baseX16({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base64.js
var base64_exports14 = {};
__export(base64_exports14, {
  base64: () => base6415,
  base64pad: () => base64pad15,
  base64url: () => base64url15,
  base64urlpad: () => base64urlpad15
});
var base6415 = rfc464816({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad15 = rfc464816({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url15 = rfc464816({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad15 = rfc464816({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/it-ws/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports14 = {};
__export(base256emoji_exports14, {
  base256emoji: () => base256emoji14
});
var alphabet15 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars14 = alphabet15.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes14 = alphabet15.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode74(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars14[c];
    return p;
  }, "");
}
function decode88(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes14[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji14 = from30({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode74,
  decode: decode88
});

// node_modules/it-ws/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports14 = {};
__export(sha2_browser_exports14, {
  sha256: () => sha25615,
  sha512: () => sha51215
});

// node_modules/it-ws/node_modules/multiformats/vendor/varint.js
var encode_116 = encode75;
var MSB16 = 128;
var REST16 = 127;
var MSBALL16 = ~REST16;
var INT16 = Math.pow(2, 31);
function encode75(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT16) {
    out[offset++] = num & 255 | MSB16;
    num /= 128;
  }
  while (num & MSBALL16) {
    out[offset++] = num & 255 | MSB16;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode75.bytes = offset - oldOffset + 1;
  return out;
}
var decode89 = read17;
var MSB$116 = 128;
var REST$116 = 127;
function read17(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read17.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$116) << shift : (b & REST$116) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$116);
  read17.bytes = counter - offset;
  return res;
}
var N117 = Math.pow(2, 7);
var N217 = Math.pow(2, 14);
var N317 = Math.pow(2, 21);
var N417 = Math.pow(2, 28);
var N517 = Math.pow(2, 35);
var N617 = Math.pow(2, 42);
var N717 = Math.pow(2, 49);
var N817 = Math.pow(2, 56);
var N917 = Math.pow(2, 63);
var length21 = function(value2) {
  return value2 < N117 ? 1 : value2 < N217 ? 2 : value2 < N317 ? 3 : value2 < N417 ? 4 : value2 < N517 ? 5 : value2 < N617 ? 6 : value2 < N717 ? 7 : value2 < N817 ? 8 : value2 < N917 ? 9 : 10;
};
var varint23 = {
  encode: encode_116,
  decode: decode89,
  encodingLength: length21
};
var _brrp_varint16 = varint23;
var varint_default16 = _brrp_varint16;

// node_modules/it-ws/node_modules/multiformats/src/varint.js
var decode90 = (data, offset = 0) => {
  const code22 = varint_default16.decode(data, offset);
  return [code22, varint_default16.decode.bytes];
};
var encodeTo16 = (int, target, offset = 0) => {
  varint_default16.encode(int, target, offset);
  return target;
};
var encodingLength16 = (int) => {
  return varint_default16.encodingLength(int);
};

// node_modules/it-ws/node_modules/multiformats/src/hashes/digest.js
var create22 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength16(code22);
  const digestOffset = sizeOffset + encodingLength16(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo16(code22, bytes2, 0);
  encodeTo16(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest16(code22, size, digest15, bytes2);
};
var decode91 = (multihash) => {
  const bytes2 = coerce17(multihash);
  const [code22, sizeOffset] = decode90(bytes2);
  const [size, digestOffset] = decode90(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest16(code22, size, digest15, bytes2);
};
var equals38 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals37(a.bytes, data.bytes);
  }
};
var Digest16 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/it-ws/node_modules/multiformats/src/hashes/hasher.js
var from31 = ({ name: name22, code: code22, encode: encode81 }) => new Hasher15(name22, code22, encode81);
var Hasher15 = class {
  constructor(name22, code22, encode81) {
    this.name = name22;
    this.code = code22;
    this.encode = encode81;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create22(this.code, result) : result.then((digest15) => create22(this.code, digest15));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/it-ws/node_modules/multiformats/src/hashes/sha2-browser.js
var sha15 = (name22) => async (data) => new Uint8Array(await crypto.subtle.digest(name22, data));
var sha25615 = from31({
  name: "sha2-256",
  code: 18,
  encode: sha15("SHA-256")
});
var sha51215 = from31({
  name: "sha2-512",
  code: 19,
  encode: sha15("SHA-512")
});

// node_modules/it-ws/node_modules/multiformats/src/hashes/identity.js
var identity_exports28 = {};
__export(identity_exports28, {
  identity: () => identity28
});
var code20 = 0;
var name21 = "identity";
var encode76 = coerce17;
var digest14 = (input) => create22(code20, encode76(input));
var identity28 = { code: code20, name: name21, encode: encode76, digest: digest14 };

// node_modules/it-ws/node_modules/multiformats/src/codecs/json.js
var textEncoder17 = new TextEncoder();
var textDecoder16 = new TextDecoder();

// node_modules/it-ws/node_modules/multiformats/src/cid.js
var format14 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV015(
        bytes2,
        baseCache14(link),
        base30 || base58btc16.encoder
      );
    default:
      return toStringV115(
        bytes2,
        baseCache14(link),
        base30 || base3216.encoder
      );
  }
};
var cache17 = /* @__PURE__ */ new WeakMap();
var baseCache14 = (cid) => {
  const baseCache16 = cache17.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache17.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID15 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE15) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE15) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID15.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create22(code22, digest15);
        return CID15.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID15.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals38(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format14(this, base30);
  }
  toJSON() {
    return { "/": format14(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID15) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID15(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID16(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol15] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode91(multihash);
      return CID15.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE15) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE15}) block encoding`
          );
        } else {
          return new CID15(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID16(version4, code22, digest15.bytes);
        return new CID15(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID15.create(0, DAG_PB_CODE15, digest15);
  }
  static createV1(code22, digest15) {
    return CID15.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID15.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID15.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce17(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest16(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID15.createV0(digest15) : CID15.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode90(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE15;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes15(source, base30);
    const cid = CID15.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache14(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes15 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc16;
      return [
        base58btc16.prefix,
        decoder.decode(`${base58btc16.prefix}${source}`)
      ];
    }
    case base58btc16.prefix: {
      const decoder = base30 || base58btc16;
      return [base58btc16.prefix, decoder.decode(source)];
    }
    case base3216.prefix: {
      const decoder = base30 || base3216;
      return [base3216.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV015 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc16.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV115 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE15 = 112;
var SHA_256_CODE15 = 18;
var encodeCID16 = (version4, code22, multihash) => {
  const codeOffset = encodingLength16(version4);
  const hashOffset = codeOffset + encodingLength16(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo16(version4, bytes2, 0);
  encodeTo16(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol15 = Symbol.for("@ipld/js-cid/CID");

// node_modules/it-ws/node_modules/multiformats/src/basics.js
var bases14 = { ...identity_exports27, ...base2_exports14, ...base8_exports14, ...base10_exports14, ...base16_exports14, ...base32_exports14, ...base36_exports14, ...base58_exports14, ...base64_exports14, ...base256emoji_exports14 };
var hashes14 = { ...sha2_browser_exports14, ...identity_exports28 };

// node_modules/it-ws/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array15(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/it-ws/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe16(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array15(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/it-ws/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec18(name22, prefix, encode81, decode97) {
  return {
    name: name22,
    prefix,
    encoder: {
      name: name22,
      prefix,
      encode: encode81
    },
    decoder: {
      decode: decode97
    }
  };
}
var string13 = createCodec18("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii13 = createCodec18("ascii", "a", (buf2) => {
  let string14 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string14 += String.fromCharCode(buf2[i2]);
  }
  return string14;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe16(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES13 = {
  utf8: string13,
  "utf-8": string13,
  hex: bases14.base16,
  latin1: ascii13,
  ascii: ascii13,
  binary: ascii13,
  ...bases14
};
var bases_default13 = BASES13;

// node_modules/it-ws/node_modules/uint8arrays/dist/src/from-string.js
function fromString26(string14, encoding = "utf8") {
  const base30 = bases_default13[encoding];
  if (base30 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array15(globalThis.Buffer.from(string14, "utf-8"));
  }
  return base30.decoder.decode(`${base30.prefix}${string14}`);
}

// node_modules/it-ws/dist/src/source.js
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => await new Promise((resolve7, reject) => {
    if (isConnected) {
      return resolve7();
    }
    if (connError != null) {
      return reject(connError);
    }
    const cleanUp = (cont) => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("error", onError);
      cont();
    };
    const onOpen = () => cleanUp(resolve7);
    const onError = (event) => {
      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)));
    };
    socket.addEventListener("open", onOpen);
    socket.addEventListener("error", onError);
  });
  const source = async function* () {
    const messages3 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString26(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => fail(event.error ?? new Error("Socket error"));
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages3) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/ready.js
var ready_default = (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  return new Promise((resolve7, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve7();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err2) {
        if (err2.message === "socket closed")
          break;
        throw err2;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      return await new Promise((resolve7, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve7();
          } else {
            const err2 = Object.assign(new Error("ws error"), { event });
            reject(err2);
          }
        });
        setTimeout(() => socket.close());
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url2 = new URL(socket.url);
      remoteAddress = url2.hostname;
      remotePort = parseInt(url2.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => await connectedSource.connected(),
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve7) => {
          socket.addEventListener("close", () => {
            resolve7();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/ws-url.js
var import_iso_url2 = __toESM(require_iso_url(), 1);
var map18 = { http: "ws", https: "wss" };
var def = "ws";
var ws_url_default = (url2, location2) => (0, import_iso_url2.relative)(url2, location2, map18, def);

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location2 = typeof window === "undefined" ? "" : window.location;
  opts = opts ?? {};
  const url2 = ws_url_default(addr, location2.toString());
  const socket = new web_socket_browser_default(url2, opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener3() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/constants.js
var CODE_P2P2 = 421;
var CODE_CIRCUIT2 = 290;
var CODE_TCP = 6;
var CODE_WSS = 478;
var CLOSE_TIMEOUT2 = 2e3;

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
var log101 = logger("libp2p:websockets:socket");
function socketToMaConn(stream, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source) {
      if (options?.signal != null) {
        source = abortableSource(source, options.signal);
      }
      try {
        await stream.sink(source);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log101.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close() {
      const start = Date.now();
      try {
        await pTimeout2(stream.close(), {
          milliseconds: CLOSE_TIMEOUT2
        });
      } catch (err2) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log101("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        stream.destroy();
      } finally {
        maConn.timeline.close = Date.now();
      }
    }
  };
  stream.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/filters.js
function all11(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT2)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P2);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function dnsWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT2)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P2);
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}

// node_modules/@libp2p/websockets/dist/src/index.js
var log102 = logger("libp2p:websockets");
var WebSockets2 = class {
  constructor(init) {
    this.init = init;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/websockets";
  }
  get [symbol4]() {
    return true;
  }
  async dial(ma, options) {
    log102("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log102("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log102("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options?.signal?.aborted === true) {
      throw new AbortError3();
    }
    const cOpts = ma.toOptions();
    log102("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const errfn = (err2) => {
      log102.error("connection error:", err2);
      errorPromise.reject(err2);
    };
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    if (rawSocket.socket.on != null) {
      rawSocket.socket.on("error", errfn);
    } else {
      rawSocket.socket.onerror = errfn;
    }
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log102("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve7, reject) => {
      onAbort = () => {
        reject(new AbortError3());
        rawSocket.close().catch((err2) => {
          log102.error("error closing raw socket", err2);
        });
      };
      if (options?.signal?.aborted === true) {
        return onAbort();
      }
      options?.signal?.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        options?.signal?.removeEventListener("abort", onAbort);
      }
    }
    log102("connected %s", ma);
    return rawSocket;
  }
  createListener(options) {
    return createListener3({ ...this.init, ...options });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser3 || isWebWorker2) {
      return dnsWss(multiaddrs);
    }
    return all11(multiaddrs);
  }
};

// node_modules/@libp2p/mplex/dist/src/encode.js
var import_varint24 = __toESM(require_varint(), 1);

// node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js
function allocUnsafe17(size) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder18 = class {
  constructor() {
    this._pool = allocUnsafe17(POOL_SIZE);
    this._poolOffset = 0;
  }
  write(msg) {
    const pool = this._pool;
    let offset = this._poolOffset;
    import_varint24.default.encode(msg.id << 3 | msg.type, pool, offset);
    offset += import_varint24.default.encode.bytes;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      import_varint24.default.encode(msg.data.length, pool, offset);
    } else {
      import_varint24.default.encode(0, pool, offset);
    }
    offset += import_varint24.default.encode.bytes;
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe17(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      return [
        header,
        ...msg.data instanceof Uint8Array ? [msg.data] : msg.data
      ];
    }
    return [
      header
    ];
  }
};
var encoder = new Encoder18();
async function* encode77(source) {
  for await (const msg of source) {
    if (Array.isArray(msg)) {
      for (const m of msg) {
        yield* encoder.write(m);
      }
    } else {
      yield* encoder.write(msg);
    }
  }
}

// node_modules/@libp2p/mplex/dist/src/decode.js
var Decoder18 = class {
  constructor() {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (_) {
          break;
        }
      }
      const { id, type, length: length23, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length23) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length23);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length23);
      this._headerInfo = null;
    }
    return msgs;
  }
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length23, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    return { id: h >> 3, type, offset: offset + end, length: length23 };
  }
};
var MSB17 = 128;
var REST17 = 127;
function readVarInt(buf2, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf2.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2.get(counter++);
    res += shift < 28 ? (b & REST17) << shift : (b & REST17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB17);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}
async function* decode92(source) {
  const decoder = new Decoder18();
  for await (const chunk of source) {
    const msgs = decoder.write(chunk);
    if (msgs.length > 0) {
      yield msgs;
    }
  }
}

// node_modules/@libp2p/mplex/dist/src/restrict-size.js
var MAX_MSG_SIZE = 1 << 20;
function restrictSize(max) {
  const maxSize = max ?? MAX_MSG_SIZE;
  const checkSize = (msg) => {
    if (msg.type !== MessageTypes.NEW_STREAM && msg.type !== MessageTypes.MESSAGE_INITIATOR && msg.type !== MessageTypes.MESSAGE_RECEIVER) {
      return;
    }
    if (msg.data.byteLength > maxSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
  };
  return (source) => {
    return async function* restrictSize2() {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          msg.forEach(checkSize);
          yield* msg;
        } else {
          checkSize(msg);
          yield msg;
        }
      }
    }();
  };
}

// node_modules/@libp2p/mplex/dist/src/stream.js
var import_err_code129 = __toESM(require_err_code(), 1);
var import_any_signal11 = __toESM(require_any_signal(), 1);
var log103 = logger("libp2p:mplex:stream");
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_SINK_ENDED = "ERR_SINK_ENDED";
var ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function createStream(options) {
  const { id, name: name22, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  const abortController = new AbortController();
  const resetController = new AbortController();
  const closeController = new AbortController();
  const Types2 = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
  const externalId = type === "initiator" ? `i${id}` : `r${id}`;
  const streamName = `${name22 == null ? id : name22}`;
  let sourceEnded = false;
  let sinkEnded = false;
  let sinkSunk = false;
  let endErr;
  const timeline = {
    open: Date.now()
  };
  const onSourceEnd = (err2) => {
    if (sourceEnded) {
      return;
    }
    sourceEnded = true;
    log103.trace("%s stream %s source end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sinkEnded) {
      stream.stat.timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const onSinkEnd = (err2) => {
    if (sinkEnded) {
      return;
    }
    sinkEnded = true;
    log103.trace("%s stream %s sink end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sourceEnded) {
      timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const streamSource = pushable({
    onEnd: onSourceEnd
  });
  const stream = {
    close: () => {
      log103.trace("%s stream %s close", type, streamName);
      stream.closeRead();
      stream.closeWrite();
    },
    closeRead: () => {
      log103.trace("%s stream %s closeRead", type, streamName);
      if (sourceEnded) {
        return;
      }
      streamSource.end();
    },
    closeWrite: () => {
      log103.trace("%s stream %s closeWrite", type, streamName);
      if (sinkEnded) {
        return;
      }
      closeController.abort();
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log103.trace("%s stream %s error sending close", type, name22, err2);
      }
      onSinkEnd();
    },
    abort: (err2) => {
      log103.trace("%s stream %s abort", type, streamName, err2);
      streamSource.end(err2);
      abortController.abort();
      onSinkEnd(err2);
    },
    reset: () => {
      const err2 = (0, import_err_code129.default)(new Error("stream reset"), ERR_STREAM_RESET);
      resetController.abort();
      streamSource.end(err2);
      onSinkEnd(err2);
    },
    sink: async (source) => {
      if (sinkSunk) {
        throw (0, import_err_code129.default)(new Error("sink already called on stream"), ERR_DOUBLE_SINK);
      }
      sinkSunk = true;
      if (sinkEnded) {
        throw (0, import_err_code129.default)(new Error("stream closed for writing"), ERR_SINK_ENDED);
      }
      source = abortableSource(source, (0, import_any_signal11.anySignal)([
        abortController.signal,
        resetController.signal,
        closeController.signal
      ]));
      try {
        if (type === "initiator") {
          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString3(streamName)) });
        }
        const uint8ArrayList = new Uint8ArrayList();
        for await (const data of source) {
          if (data.length <= maxMsgSize) {
            send({ id, type: Types2.MESSAGE, data: data instanceof Uint8ArrayList ? data : new Uint8ArrayList(data) });
          } else {
            uint8ArrayList.append(data);
            while (uint8ArrayList.length !== 0) {
              if (uint8ArrayList.length <= maxMsgSize) {
                send({ id, type: Types2.MESSAGE, data: uint8ArrayList.sublist() });
                uint8ArrayList.consume(uint8ArrayList.length);
                break;
              }
              send({ id, type: Types2.MESSAGE, data: uint8ArrayList.sublist(0, maxMsgSize) });
              uint8ArrayList.consume(maxMsgSize);
            }
          }
        }
      } catch (err2) {
        if (err2.type === "aborted" && err2.message === "The operation was aborted") {
          if (closeController.signal.aborted) {
            return;
          }
          if (resetController.signal.aborted) {
            err2.message = "stream reset";
            err2.code = ERR_STREAM_RESET;
          }
          if (abortController.signal.aborted) {
            err2.message = "stream aborted";
            err2.code = ERR_STREAM_ABORT;
          }
        }
        if (err2.code === ERR_STREAM_RESET) {
          log103.trace("%s stream %s reset", type, name22);
        } else {
          log103.trace("%s stream %s error", type, name22, err2);
          try {
            send({ id, type: Types2.RESET });
          } catch (err3) {
            log103.trace("%s stream %s error sending reset", type, name22, err3);
          }
        }
        streamSource.end(err2);
        onSinkEnd(err2);
        return;
      }
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log103.trace("%s stream %s error sending close", type, name22, err2);
      }
      onSinkEnd();
    },
    source: streamSource,
    sourcePush: (data) => {
      streamSource.push(data);
    },
    sourceReadableLength() {
      return streamSource.readableLength;
    },
    stat: {
      direction: type === "initiator" ? "outbound" : "inbound",
      timeline
    },
    metadata: {},
    id: externalId
  };
  return stream;
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var import_err_code130 = __toESM(require_err_code(), 1);
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);
var import_any_signal12 = __toESM(require_any_signal(), 1);
var log104 = logger("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString11(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString11(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(components, init) {
    this.protocol = "/mplex/6.7.0";
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      initiators: /* @__PURE__ */ new Map(),
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.sink = this._createSink();
    const source = this._createSource();
    this._source = source;
    this.source = source;
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  init(components) {
  }
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  newStream(name22) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name22 = name22 == null ? id.toString() : name22.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name22, type: "initiator", registry });
  }
  close(err2) {
    if (this.closeController.signal.aborted)
      return;
    if (err2 != null) {
      this.streams.forEach((s) => s.abort(err2));
    } else {
      this.streams.forEach((s) => s.close());
    }
    this.closeController.abort();
  }
  _newReceiverStream(options) {
    const { id, name: name22 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name22, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name22, type, registry } = options;
    log104("new %s stream %s %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw (0, import_err_code130.default)(new Error("Too many outbound streams open"), "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = (msg) => {
      if (log104.enabled) {
        log104.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log104("%s stream with id %s and protocol %s ended", type, id, stream.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name22, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  _createSink() {
    const sink = async (source) => {
      const abortSignals = [this.closeController.signal];
      if (this._init.signal != null) {
        abortSignals.push(this._init.signal);
      }
      source = abortableSource(source, (0, import_any_signal12.default)(abortSignals));
      try {
        await pipe(source, decode92, restrictSize(this._init.maxMsgSize), async (source2) => {
          for await (const msg of source2) {
            await this._handleIncoming(msg);
          }
        });
        this._source.end();
      } catch (err2) {
        log104("error in sink", err2);
        this._source.end(err2);
      }
    };
    return sink;
  }
  _createSource() {
    const onEnd = (err2) => {
      this.close(err2);
    };
    const source = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode77(source), {
      push: source.push,
      end: source.end,
      return: source.return
    });
  }
  async _handleIncoming(message6) {
    const { id, type } = message6;
    if (log104.enabled) {
      log104.trace("incoming message", printMessage(message6));
    }
    if (message6.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log104("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log104("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString11(message6.data instanceof Uint8Array ? message6.data : message6.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log104("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message6.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error = (0, import_err_code130.default)(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
          stream.abort(error);
          return;
        }
        stream.sourcePush(message6.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset();
        break;
      default:
        log104("unknown message type %s", type);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  constructor(init = {}) {
    this.protocol = "/mplex/6.7.0";
    this.components = new Components();
    this._init = init;
  }
  init(components) {
    this.components = components;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/stablelib.js
var import_hkdf = __toESM(require_hkdf(), 1);
var x25519 = __toESM(require_x25519(), 1);
var import_sha256 = __toESM(require_sha2562(), 1);
var import_chacha20poly1305 = __toESM(require_chacha20poly1305(), 1);
var stablelib = {
  hashSHA256(data) {
    return (0, import_sha256.hash)(data);
  },
  getHKDF(ck, ikm) {
    const hkdf = new import_hkdf.HKDF(import_sha256.SHA256, ikm, ck);
    const okmU8Array = hkdf.expand(96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const keypair = x25519.generateKeyPair();
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed2) {
    const keypair = x25519.generateKeyPairFromSeed(seed2);
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.sharedKey(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.seal(nonce, plaintext, ad);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.open(nonce, ciphertext, ad);
  }
};

// node_modules/it-pb-stream/dist/src/index.js
function pbStream(duplex, opts = {}) {
  const shake = handshake(duplex);
  const lpReader = decode62.fromReader(shake.reader, opts);
  const W = {
    read: async (bytes2) => {
      const { value: value2 } = await shake.reader.next(bytes2);
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readLP: async () => {
      const { value: value2 } = await lpReader.next();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readPB: async (proto) => {
      const value2 = await W.readLP();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      const buf2 = value2 instanceof Uint8Array ? value2 : value2.subarray();
      return proto.decode(buf2);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        shake.writer.push(data);
      } else {
        shake.writer.push(data.subarray());
      }
    },
    writeLP: (data) => {
      W.write(encode52.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => await W.readPB(proto),
        write: (d) => {
          W.writePB(d, proto);
        }
      };
    },
    unwrap: () => {
      shake.rest();
      return shake.stream;
    }
  };
  return W;
}

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/streaming.js
function encryptStream(handshake2) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i2, end), handshake2.session);
        yield data;
      }
    }
  };
}
function decryptStream(handshake2) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const { plaintext: decrypted, valid } = await handshake2.decrypt(chunk.subarray(i2, end), handshake2.session);
        if (!valid) {
          throw new Error("Failed to validate decrypted chunk");
        }
        yield decrypted;
      }
    }
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
init_concat();
var allocUnsafe18 = (len) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
};
var uint16BEEncode = (value2) => {
  const target = allocUnsafe18(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value2, false);
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(message6) {
  return concat4([message6.ne, message6.ciphertext], message6.ne.length + message6.ciphertext.length);
}
function encode1(message6) {
  return concat4([message6.ne, message6.ns, message6.ciphertext], message6.ne.length + message6.ns.length + message6.ciphertext.length);
}
function encode210(message6) {
  return concat4([message6.ns, message6.ciphertext], message6.ns.length + message6.ciphertext.length);
}
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
function decode210(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}

// node_modules/@libp2p/interface-connection-encrypter/dist/src/errors.js
var UnexpectedPeerError = class extends Error {
  constructor(message6 = "Unexpected Peer") {
    super(message6);
    this.code = UnexpectedPeerError.code;
  }
  static get code() {
    return "ERR_UNEXPECTED_PEER";
  }
};
var InvalidCryptoExchangeError = class extends Error {
  constructor(message6 = "Invalid crypto exchange") {
    super(message6);
    this.code = InvalidCryptoExchangeError.code;
  }
  static get code() {
    return "ERR_INVALID_CRYPTO_EXCHANGE";
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
init_concat();

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var pb3;
(function(pb4) {
  let NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message2((obj, writer5, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer5.fork();
          }
          if (obj.identityKey != null) {
            writer5.uint32(10);
            writer5.bytes(obj.identityKey);
          } else {
            throw new Error('Protocol error: required field "identityKey" was not found in object');
          }
          if (obj.identitySig != null) {
            writer5.uint32(18);
            writer5.bytes(obj.identitySig);
          } else {
            throw new Error('Protocol error: required field "identitySig" was not found in object');
          }
          if (obj.data != null) {
            writer5.uint32(26);
            writer5.bytes(obj.data);
          } else {
            throw new Error('Protocol error: required field "data" was not found in object');
          }
          if (opts.lengthDelimited !== false) {
            writer5.ldelim();
          }
        }, (reader6, length23) => {
          const obj = {
            identityKey: new Uint8Array(0),
            identitySig: new Uint8Array(0),
            data: new Uint8Array(0)
          };
          const end = length23 == null ? reader6.len : reader6.pos + length23;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.identityKey = reader6.bytes();
                break;
              case 2:
                obj.identitySig = reader6.bytes();
                break;
              case 3:
                obj.data = reader6.bytes();
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          if (obj.identityKey == null) {
            throw new Error('Protocol error: value for required field "identityKey" was not found in protobuf');
          }
          if (obj.identitySig == null) {
            throw new Error('Protocol error: value for required field "identitySig" was not found in protobuf');
          }
          if (obj.data == null) {
            throw new Error('Protocol error: value for required field "data" was not found in protobuf');
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage2(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf2) => {
      return decodeMessage2(buf2, NoiseHandshakePayload2.codec());
    };
  })(NoiseHandshakePayload = pb4.NoiseHandshakePayload || (pb4.NoiseHandshakePayload = {}));
})(pb3 || (pb3 = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
var NoiseHandshakePayloadProto = pb3.NoiseHandshakePayload;
async function getPayload(localPeer, staticPublicKey, earlyData) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  const earlyDataPayload = earlyData ?? new Uint8Array(0);
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, earlyDataPayload);
}
function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
  return NoiseHandshakePayloadProto.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    data: earlyData ?? new Uint8Array(0)
  }).subarray();
}
async function signPayload(peerId, payload) {
  if (peerId.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
  return await privateKey.sign(payload);
}
async function getPeerIdFromPayload(payload) {
  return await peerIdFromKeys(payload.identityKey);
}
function decodePayload2(payload) {
  return NoiseHandshakePayloadProto.decode(payload);
}
function getHandshakePayload(publicKey) {
  const prefix = fromString3("noise-libp2p-static-key:");
  return concat4([prefix, publicKey], prefix.length + publicKey.length);
}
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error("Peer ID doesn't match libp2p public key.");
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey2(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
init_concat();

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
var log105 = logger("libp2p:noise");
var keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log105;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString11(s.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString11(s.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString11(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString11(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString11(rs, "hex")}`);
}
function logRemoteEphemeralKey(re2) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString11(re2, "hex")}`);
}
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString11(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString11(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var AbstractHandshake = class {
  constructor(crypto4) {
    this.crypto = crypto4;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals15(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err2 = e;
      log105(err2.message);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b) {
    const u = this.crypto.hashSHA256(concat4([a, b], a.length + b.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString3(protocolName, "utf-8");
    const h = this.hashProtocolName(protocolNameBytes);
    const ck = h;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h = new Uint8Array(32);
      h.set(protocolName);
      return h;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message6) {
    return this.decryptWithAd(cs, new Uint8Array(0), message6.ciphertext);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var XX = class extends AbstractHandshake {
  initializeInitiator(prologue, s, rs, psk) {
    const name22 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name22);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s, rs, psk, re: re2 };
  }
  initializeResponder(prologue, s, rs, psk) {
    const name22 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name22);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s, rs, psk, re: re2 };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message6) {
    if (isValidPublicKey(message6.ne)) {
      hs.re = message6.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message6.ciphertext);
  }
  readMessageB(hs, message6) {
    if (isValidPublicKey(message6.ne)) {
      hs.re = message6.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message6.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message6.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message6) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message6.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message6.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message6, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message6, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message6);
    } else if (session.mc === 2) {
      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message6);
      messageBuffer = resultingBuffer;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message6);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message6);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message6) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message6));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message6));
    } else if (session.mc === 2) {
      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message6);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var XXHandshake = class {
  constructor(isInitiator, payload, prologue, crypto4, staticKeypair, connection, remotePeer, handshake2) {
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto4);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
    this.remoteEarlyData = new Uint8Array(0);
  }
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log105("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      this.connection.writeLP(encode0(messageBuffer));
      log105("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log105("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log105("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  async exchange() {
    if (this.isInitiator) {
      log105("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log105("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log105("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload2(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
      log105("All good with the signature!");
    } else {
      log105("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode1(messageBuffer));
      log105("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  async finish() {
    if (this.isInitiator) {
      log105("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode210(messageBuffer));
      log105("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log105("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode210((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log105("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload2(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteEarlyData(data) {
    if (data) {
      this.remoteEarlyData = data;
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  constructor(staticNoiseKey, earlyData, crypto4 = stablelib, prologueBytes) {
    this.protocol = "/noise";
    this.earlyData = earlyData ?? new Uint8Array(0);
    this.crypto = crypto4;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteEarlyData: handshake2.remoteEarlyData,
      remotePeer: handshake2.remotePeer
    };
  }
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteEarlyData: handshake2.remoteEarlyData,
      remotePeer: handshake2.remotePeer
    };
  }
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
    return await this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
    } catch (e) {
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      encryptStream(handshake2),
      encode52({ lengthEncoder: uint16BEEncode }),
      network,
      decode62({ lengthDecoder: uint16BEDecode }),
      decryptStream(handshake2),
      secure
    );
    return user;
  }
};

// node_modules/ipfs-core/src/components/libp2p.js
var mergeOptions14 = merge_options_default.bind({ ignoreUndefined: true, concatArrays: true });
function createLibp2p2({
  options = {},
  peerId,
  multiaddrs = [],
  repo,
  keychainConfig = {},
  config: config2 = {}
}) {
  const { datastore } = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config: config2,
    datastore,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === "function") {
    return options.libp2p({ libp2pOptions, options, config: config2, datastore, peerId });
  }
  return createLibp2p(libp2pOptions);
}
function getLibp2pOptions({ options, config: config2, datastore, keychainConfig, peerId, multiaddrs }) {
  const getPubsubRouter = () => {
    const router = dlv_es_default(config2, "Pubsub.Router") || "gossipsub";
    const availableRouters = routers();
    if (!availableRouters[router]) {
      throw (0, import_err_code131.default)(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
    }
    return availableRouters[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId
  };
  const libp2pOptions = {
    addresses: {
      listen: multiaddrs.map((ma) => ma.toString()),
      announce: dlv_es_default(options, "addresses.announce", dlv_es_default(config2, "Addresses.Announce", [])),
      noAnnounce: dlv_es_default(options, "addresses.noAnnounce", dlv_es_default(config2, "Addresses.NoAnnounce", []))
    },
    connectionManager: dlv_es_default(options, "connectionManager", {
      maxConnections: dlv_es_default(options, "config.Swarm.ConnMgr.HighWater", dlv_es_default(config2, "Swarm.ConnMgr.HighWater")),
      minConnections: dlv_es_default(options, "config.Swarm.ConnMgr.LowWater", dlv_es_default(config2, "Swarm.ConnMgr.LowWater"))
    }),
    keychain: keychainConfig,
    identify: {
      host: {
        agentVersion: `js-ipfs/${ipfsCore}`
      }
    },
    contentRouters: [],
    peerRouters: [],
    peerDiscovery: [],
    transports: [],
    streamMuxers: [
      new Mplex({
        maxInboundStreams: 256,
        maxOutboundStreams: 1024
      })
    ],
    connectionEncryption: [
      new Noise()
    ],
    relay: {
      enabled: dlv_es_default(options, "relay.enabled", dlv_es_default(config2, "relay.enabled", true)),
      hop: {
        enabled: dlv_es_default(options, "relay.hop.enabled", dlv_es_default(config2, "relay.hop.enabled", false)),
        active: dlv_es_default(options, "relay.hop.active", dlv_es_default(config2, "relay.hop.active", false))
      }
    },
    nat: {
      enabled: !dlv_es_default(config2, "Swarm.DisableNatPortMap", false)
    }
  };
  if (dlv_es_default(options, "config.Pubsub.Enabled", dlv_es_default(config2, "Pubsub.Enabled", true))) {
    libp2pOptions.pubsub = getPubsubRouter();
  }
  if (dlv_es_default(config2, "Routing.Type", "dhtclient") !== "none") {
    libp2pOptions.dht = new KadDHT2({
      clientMode: dlv_es_default(config2, "Routing.Type", "dht") !== "dhtserver",
      kBucketSize: dlv_es_default(options, "dht.kBucketSize", 20),
      validators: {
        ipns: ipnsValidator
      },
      selectors: {
        ipns: ipnsSelector
      }
    });
  }
  const boostrapNodes = dlv_es_default(options, "config.Bootstrap", dlv_es_default(config2, "Bootstrap", []));
  if (boostrapNodes.length > 0) {
    libp2pOptions.peerDiscovery?.push(
      new Bootstrap({
        list: boostrapNodes
      })
    );
  }
  let constructorOptions = dlv_es_default(options, "libp2p", void 0);
  if (typeof constructorOptions === "function") {
    constructorOptions = void 0;
  }
  const libp2pFinalConfig = mergeOptions14(
    libp2pDefaults,
    libp2pConfig(),
    libp2pOptions,
    constructorOptions
  );
  const delegateHosts = dlv_es_default(
    options,
    "config.Addresses.Delegates",
    dlv_es_default(config2, "Addresses.Delegates", [])
  );
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
      port: delegateAddr.port
    };
    const delegateHttpClient = create16(delegateApiOptions);
    libp2pFinalConfig.contentRouters?.push(new DelegatedContentRouting(delegateHttpClient));
    libp2pFinalConfig.peerRouters?.push(new DelegatedPeerRouting(delegateHttpClient));
  }
  if (!dlv_es_default(options, "config.Discovery.MDNS.Enabled", dlv_es_default(config2, "Discovery.MDNS.Enabled", true))) {
    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter((d) => {
      return d != null && d[Symbol.toStringTag] !== "@libp2p/mdns";
    });
  }
  if (libp2pFinalConfig.transports == null) {
    libp2pFinalConfig.transports = [];
  }
  if (libp2pFinalConfig.transports.find((t) => t[Symbol.toStringTag] === "@libp2p/websockets") == null) {
    libp2pFinalConfig.transports.push(new WebSockets2());
  }
  return libp2pFinalConfig;
}

// node_modules/ipfs-core/src/components/storage.js
var import_err_code132 = __toESM(require_err_code(), 1);
var mergeOptions15 = merge_options_default.bind({ ignoreUndefined: true });
var log106 = logger("ipfs:components:peer:storage");
var Storage = class {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs2, options) {
    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options;
    const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo2(print, codecs2, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress
    }) : inputRepo;
    const { peerId, keychain, isNew } = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
};
var loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return { ...await configureRepo(repo, options), isNew: false };
  }
  try {
    await repo.open();
    return { ...await configureRepo(repo, options), isNew: false };
  } catch (err2) {
    if (err2.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err2;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
    }
    return { ...await initRepo(print, repo, options), isNew: true };
  }
};
var initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists2 = await repo.exists();
  log106("repo exists?", exists2);
  if (exists2 === true) {
    throw new Error("repo already exists");
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity29 = peerIdToIdentity(peerId);
  log106("peer identity: %s", identity29.PeerID);
  const config2 = {
    ...mergeOptions15(applyProfiles(config_browser_default(), initOptions.profiles), options.config),
    Identity: identity29
  };
  await repo.init(config2);
  await repo.open();
  log106("repo opened");
  const keychainConfig = {
    pass: options.pass
  };
  try {
    keychainConfig.dek = await repo.config.get("Keychain.DEK");
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: config2,
    keychainConfig
  });
  if (!await repo.datastore.has(new Key("/info/self"))) {
    await libp2p.keychain.importPeer("self", peerId);
  }
  await repo.config.set("Keychain", {
    DEK: libp2p.keychain.init.dek
  });
  return { peerId, keychain: libp2p.keychain };
};
var decodePeerId = async (peerId) => {
  log106("using user-supplied private-key");
  if (isPeerId(peerId)) {
    return peerId;
  }
  const rawPrivateKey = fromString3(peerId, "base64pad");
  const key = await unmarshalPrivateKey3(rawPrivateKey);
  return await peerIdFromKeys(key.public.bytes, key.bytes);
};
var initPeerId = (print, { algorithm = "Ed25519", bits: bits2 = 2048 }) => {
  print("generating %s keypair...", algorithm);
  if (algorithm === "Ed25519") {
    return createEd25519PeerId();
  }
  if (algorithm === "RSA") {
    return createRSAPeerId({ bits: bits2 });
  }
  throw (0, import_err_code132.default)(new Error("Unknown PeerId algorithm"), "ERR_UNKNOWN_PEER_ID_ALGORITHM");
};
var peerIdToIdentity = (peerId) => {
  if (peerId.privateKey == null) {
    throw (0, import_err_code132.default)(new Error("Private key missing"), "ERR_MISSING_PRIVATE_KEY");
  }
  return {
    PeerID: peerId.toString(),
    PrivKey: toString11(peerId.privateKey, "base64pad")
  };
};
var configureRepo = async (repo, options) => {
  const config2 = options.config;
  const profiles2 = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError("No private key was found in the config, please intialize the repo");
  }
  const buf2 = fromString3(changed.Identity.PrivKey, "base64pad");
  const key = await unmarshalPrivateKey3(buf2);
  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  return { peerId, keychain: libp2p.keychain };
};
var mergeConfigs = (config2, changes) => changes ? mergeOptions15(config2, changes) : config2;
var applyProfiles = (config2, profiles2) => {
  return (profiles2 || []).reduce((config3, name22) => {
    const profile = profiles[name22];
    if (!profile) {
      throw new Error(`Could not find profile with name '${name22}'`);
    }
    log106("applying profile %s", name22);
    return profile.transform(config3);
  }, config2);
};

// node_modules/ipfs-bitswap/src/message/index.js
var import_varint_decoder = __toESM(require_src5(), 1);

// node_modules/ipfs-bitswap/src/utils/varint-encoder.js
var varint25 = __toESM(require_varint(), 1);
function varintEncoder(buf2) {
  let out = new Uint8Array(buf2.reduce((acc, curr) => {
    return acc + varint25.default.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf2) {
    out = varint25.encode(num, out, offset);
    offset += varint25.default.encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// node_modules/ipfs-bitswap/src/utils/index.js
var import_debug12 = __toESM(require_browser(), 1);

// node_modules/ipfs-bitswap/src/wantlist/entry.js
var WantListEntry = class {
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority || 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc2);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
};

// node_modules/ipfs-bitswap/src/message/message.js
var import_minimal13 = __toESM(require_minimal2(), 1);
var $Reader8 = import_minimal13.default.Reader;
var $Writer8 = import_minimal13.default.Writer;
var $util8 = import_minimal13.default.util;
var $root8 = import_minimal13.default.roots["ipfs-bitswap"] || (import_minimal13.default.roots["ipfs-bitswap"] = {});
var Message3 = $root8.Message = (() => {
  function Message4(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Message4.prototype.wantlist = null;
  Message4.prototype.blocks = $util8.emptyArray;
  Message4.prototype.payload = $util8.emptyArray;
  Message4.prototype.blockPresences = $util8.emptyArray;
  Message4.prototype.pendingBytes = 0;
  Message4.encode = function encode81(m, w) {
    if (!w)
      w = $Writer8.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
      $root8.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i2 = 0; i2 < m.blocks.length; ++i2)
        w.uint32(18).bytes(m.blocks[i2]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i2 = 0; i2 < m.payload.length; ++i2)
        $root8.Message.Block.encode(m.payload[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i2 = 0; i2 < m.blockPresences.length; ++i2)
        $root8.Message.BlockPresence.encode(m.blockPresences[i2], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message4.decode = function decode97(r, l) {
    if (!(r instanceof $Reader8))
      r = $Reader8.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1: {
          m.wantlist = $root8.Message.Wantlist.decode(r, r.uint32());
          break;
        }
        case 2: {
          if (!(m.blocks && m.blocks.length))
            m.blocks = [];
          m.blocks.push(r.bytes());
          break;
        }
        case 3: {
          if (!(m.payload && m.payload.length))
            m.payload = [];
          m.payload.push($root8.Message.Block.decode(r, r.uint32()));
          break;
        }
        case 4: {
          if (!(m.blockPresences && m.blockPresences.length))
            m.blockPresences = [];
          m.blockPresences.push($root8.Message.BlockPresence.decode(r, r.uint32()));
          break;
        }
        case 5: {
          m.pendingBytes = r.int32();
          break;
        }
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Message4.fromObject = function fromObject(d) {
    if (d instanceof $root8.Message)
      return d;
    var m = new $root8.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== "object")
        throw TypeError(".Message.wantlist: object expected");
      m.wantlist = $root8.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError(".Message.blocks: array expected");
      m.blocks = [];
      for (var i2 = 0; i2 < d.blocks.length; ++i2) {
        if (typeof d.blocks[i2] === "string")
          $util8.base64.decode(d.blocks[i2], m.blocks[i2] = $util8.newBuffer($util8.base64.length(d.blocks[i2])), 0);
        else if (d.blocks[i2].length >= 0)
          m.blocks[i2] = d.blocks[i2];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError(".Message.payload: array expected");
      m.payload = [];
      for (var i2 = 0; i2 < d.payload.length; ++i2) {
        if (typeof d.payload[i2] !== "object")
          throw TypeError(".Message.payload: object expected");
        m.payload[i2] = $root8.Message.Block.fromObject(d.payload[i2]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError(".Message.blockPresences: array expected");
      m.blockPresences = [];
      for (var i2 = 0; i2 < d.blockPresences.length; ++i2) {
        if (typeof d.blockPresences[i2] !== "object")
          throw TypeError(".Message.blockPresences: object expected");
        m.blockPresences[i2] = $root8.Message.BlockPresence.fromObject(d.blockPresences[i2]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
      d.wantlist = $root8.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util8.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root8.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root8.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal13.default.util.toJSONOptions);
  };
  Message4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
    if (typeUrlPrefix === void 0) {
      typeUrlPrefix = "type.googleapis.com";
    }
    return typeUrlPrefix + "/Message";
  };
  Message4.Wantlist = function() {
    function Wantlist2(p) {
      this.entries = [];
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Wantlist2.prototype.entries = $util8.emptyArray;
    Wantlist2.prototype.full = false;
    Wantlist2.encode = function encode81(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.entries != null && m.entries.length) {
        for (var i2 = 0; i2 < m.entries.length; ++i2)
          $root8.Message.Wantlist.Entry.encode(m.entries[i2], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, "full"))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist2.decode = function decode97(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            if (!(m.entries && m.entries.length))
              m.entries = [];
            m.entries.push($root8.Message.Wantlist.Entry.decode(r, r.uint32()));
            break;
          }
          case 2: {
            m.full = r.bool();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Wantlist2.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Wantlist)
        return d;
      var m = new $root8.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError(".Message.Wantlist.entries: array expected");
        m.entries = [];
        for (var i2 = 0; i2 < d.entries.length; ++i2) {
          if (typeof d.entries[i2] !== "object")
            throw TypeError(".Message.Wantlist.entries: object expected");
          m.entries[i2] = $root8.Message.Wantlist.Entry.fromObject(d.entries[i2]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root8.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty("full")) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal13.default.util.toJSONOptions);
    };
    Wantlist2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Wantlist";
    };
    Wantlist2.WantType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Block"] = 0;
      values[valuesById[1] = "Have"] = 1;
      return values;
    }();
    Wantlist2.Entry = function() {
      function Entry(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Entry.prototype.block = $util8.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode81(m, w) {
        if (!w)
          w = $Writer8.create();
        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode97(r, l) {
        if (!(r instanceof $Reader8))
          r = $Reader8.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1: {
              m.block = r.bytes();
              break;
            }
            case 2: {
              m.priority = r.int32();
              break;
            }
            case 3: {
              m.cancel = r.bool();
              break;
            }
            case 4: {
              m.wantType = r.int32();
              break;
            }
            case 5: {
              m.sendDontHave = r.bool();
              break;
            }
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root8.Message.Wantlist.Entry)
          return d;
        var m = new $root8.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === "string")
            $util8.base64.decode(d.block, m.block = $util8.newBuffer($util8.base64.length(d.block)), 0);
          else if (d.block.length >= 0)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
          case "Block":
          case 0:
            m.wantType = 0;
            break;
          case "Have":
          case 1:
            m.wantType = 1;
            break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = "";
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util8.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? "Block" : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty("block")) {
          d.block = o.bytes === String ? $util8.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty("priority")) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty("cancel")) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty("wantType")) {
          d.wantType = o.enums === String ? $root8.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal13.default.util.toJSONOptions);
      };
      Entry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === void 0) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Message.Wantlist.Entry";
      };
      return Entry;
    }();
    return Wantlist2;
  }();
  Message4.Block = function() {
    function Block2(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Block2.prototype.prefix = $util8.newBuffer([]);
    Block2.prototype.data = $util8.newBuffer([]);
    Block2.encode = function encode81(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, "data"))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block2.decode = function decode97(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.prefix = r.bytes();
            break;
          }
          case 2: {
            m.data = r.bytes();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Block2.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Block)
        return d;
      var m = new $root8.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === "string")
          $util8.base64.decode(d.prefix, m.prefix = $util8.newBuffer($util8.base64.length(d.prefix)), 0);
        else if (d.prefix.length >= 0)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === "string")
          $util8.base64.decode(d.data, m.data = $util8.newBuffer($util8.base64.length(d.data)), 0);
        else if (d.data.length >= 0)
          m.data = d.data;
      }
      return m;
    };
    Block2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = "";
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util8.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = "";
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util8.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty("prefix")) {
        d.prefix = o.bytes === String ? $util8.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty("data")) {
        d.data = o.bytes === String ? $util8.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal13.default.util.toJSONOptions);
    };
    Block2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Block";
    };
    return Block2;
  }();
  Message4.BlockPresenceType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Have"] = 0;
    values[valuesById[1] = "DontHave"] = 1;
    return values;
  }();
  Message4.BlockPresence = function() {
    function BlockPresence(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    BlockPresence.prototype.cid = $util8.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode81(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, "type"))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode97(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.cid = r.bytes();
            break;
          }
          case 2: {
            m.type = r.int32();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.BlockPresence)
        return d;
      var m = new $root8.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === "string")
          $util8.base64.decode(d.cid, m.cid = $util8.newBuffer($util8.base64.length(d.cid)), 0);
        else if (d.cid.length >= 0)
          m.cid = d.cid;
      }
      switch (d.type) {
        case "Have":
        case 0:
          m.type = 0;
          break;
        case "DontHave":
        case 1:
          m.type = 1;
          break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = "";
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util8.newBuffer(d.cid);
        }
        d.type = o.enums === String ? "Have" : 0;
      }
      if (m.cid != null && m.hasOwnProperty("cid")) {
        d.cid = o.bytes === String ? $util8.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty("type")) {
        d.type = o.enums === String ? $root8.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal13.default.util.toJSONOptions);
    };
    BlockPresence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.BlockPresence";
    };
    return BlockPresence;
  }();
  return Message4;
})();

// node_modules/ipfs-bitswap/src/wantlist/index.js
var WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
var sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a);
    const bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
};
var Wantlist = class {
  constructor(stats, libp2p) {
    this.set = libp2p ? trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc2);
    const entry = this.set.get(cidStr);
    if (entry) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType.Have && wantType === WantType.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats) {
        this._stats.push(null, "wantListSize", 1);
      }
    }
  }
  remove(cid) {
    const cidStr = cid.toString(base58btc2);
    const entry = this.set.get(cidStr);
    if (!entry) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats) {
      this._stats.push(null, "wantListSize", -1);
    }
  }
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  forEach(fn) {
    return this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  contains(cid) {
    const cidStr = cid.toString(base58btc2);
    return this.set.has(cidStr);
  }
  get(cid) {
    const cidStr = cid.toString(base58btc2);
    return this.set.get(cidStr);
  }
};
Wantlist.Entry = WantListEntry;

// node_modules/ipfs-bitswap/src/message/entry.js
var WantlistEntry = Wantlist.Entry;
var BitswapMessageEntry = class {
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantlistEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc2);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
};

// node_modules/ipfs-bitswap/src/utils/index.js
var logger2 = (id, subsystem) => {
  const name22 = ["bitswap"];
  if (subsystem) {
    name22.push(subsystem);
  }
  if (id) {
    name22.push(`${id.toString().slice(0, 8)}`);
  }
  return Object.assign((0, import_debug12.default)(name22.join(":")), {
    error: (0, import_debug12.default)(name22.concat(["error"]).join(":"))
  });
};
var isMapEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals15(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
};

// node_modules/ipfs-bitswap/src/message/index.js
var import_err_code133 = __toESM(require_err_code(), 1);
var BitswapMessage = class {
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc2);
    const entry = this.wantlist.get(cidStr);
    if (entry) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc2);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58btc2);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc2);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58btc2);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : void 0
      },
      blocks: Array.from(this.blocks.values())
    };
    return Message3.encode(msg).finish();
  }
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : void 0
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID.parse(cidStr);
      const version4 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varint_encoder_default([
        version4,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(
        new Message3.Block({
          prefix,
          data
        })
      );
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new Message3.BlockPresence({
        cid: CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message3.encode(msg).finish();
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
};
BitswapMessage.deserialize = async (raw, hashLoader) => {
  const decoded = Message3.decode(raw);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach((entry) => {
      if (!entry.block) {
        return;
      }
      const cid = CID.decode(entry.block);
      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach((blockPresence) => {
      if (!blockPresence.cid) {
        return;
      }
      const cid = CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async (b) => {
      const hash3 = await sha256.digest(b);
      const cid = CID.createV0(hash3);
      msg.addBlock(cid, b);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async (p) => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values = (0, import_varint_decoder.default)(p.prefix);
      const cidVersion = values[0];
      const multicodec = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw (0, import_err_code133.default)(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
      }
      const hash3 = await hasher.digest(p.data);
      const cid = CID.create(cidVersion, multicodec, hash3);
      msg.addBlock(cid, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = (cid) => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: Message3.BlockPresenceType.Have,
  DontHave: Message3.BlockPresenceType.DontHave
};

// node_modules/ipfs-bitswap/src/constants.js
var SECOND = 1e3;
var maxProvidersPerRequest = 3;
var providerRequestTimeout = 10 * SECOND;
var hasBlockTimeout = 15 * SECOND;
var provideTimeout = 15 * SECOND;
var kMaxPriority = Math.pow(2, 31) - 1;
var maxListeners = 1e3;
var wantlistSendDebounceMs = 1;

// node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce2;
function debounce2(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush3 = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush3;
  return debounceWrapper;
}

// node_modules/ipfs-bitswap/src/want-manager/msg-queue.js
var MsgQueue = class {
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger2(selfPeerId, "msgqueue");
    this.sendEntries = functionDebounce(this._sendEntries.bind(this), wantlistSendDebounceMs);
  }
  addMessage(msg) {
    if (msg.empty) {
      return;
    }
    this.send(msg);
  }
  addEntries(entries) {
    this._entries = this._entries.concat(entries);
    this.sendEntries();
  }
  _sendEntries() {
    if (!this._entries.length) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg);
  }
  async send(msg) {
    try {
      await this.network.connectTo(this.peerId);
    } catch (err2) {
      this._log.error("cant connect to peer %s: %s", this.peerId.toString(), err2.message);
      return;
    }
    this._log("sending message to peer %s", this.peerId.toString());
    this.network.sendMessage(this.peerId, msg).catch((err2) => {
      this._log.error("send error: %s", err2.message);
    });
  }
};

// node_modules/ipfs-bitswap/src/want-manager/index.js
var WantManager = class {
  constructor(peerId, network, stats, libp2p) {
    this.peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "want-manager-peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._stats = stats;
    this._peerId = peerId;
    this._log = logger2(peerId, "want");
  }
  _addEntries(cids, cancel, force) {
    const entries = cids.map((cid, i2) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i2, BitswapMessage.WantType.Block, cancel);
    });
    entries.forEach((e) => {
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid.toString(base58btc2));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wl");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries);
    }
  }
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toString());
    if (mq) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toString(), mq);
    return mq;
  }
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toString());
    if (!mq) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toString());
  }
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false);
    if (options && options.signal) {
      options.signal.addEventListener("abort", () => {
        this.cancelWants(cids);
      });
    }
  }
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => this.disconnected(mq.peerId));
  }
};

// node_modules/ipfs-bitswap/src/network.js
var import_timeout_abort_controller18 = __toESM(require_timeout_abort_controller(), 1);
var BITSWAP100 = "/ipfs/bitswap/1.0.0";
var BITSWAP110 = "/ipfs/bitswap/1.1.0";
var BITSWAP120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 128;
var DEFAULT_INCOMING_STREAM_TIMEOUT = 3e4;
var Network2 = class {
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger2(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection, {
      maxInboundStreams: this._maxInboundStreams,
      maxOutboundStreams: this._maxOutboundStreams
    });
    const topology = createTopology({
      onConnect: this._onPeerConnect,
      onDisconnect: this._onPeerDisconnect
    });
    this._registrarIds = [];
    for (const protocol4 of this._protocols) {
      this._registrarIds.push(await this._libp2p.registrar.register(protocol4, topology));
    }
    this._libp2p.getConnections().forEach((conn) => {
      this._onPeerConnect(conn.remotePeer);
    });
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarIds != null) {
      for (const id of this._registrarIds) {
        this._libp2p.registrar.unregister(id);
      }
      this._registrarIds = [];
    }
  }
  _onConnection({ stream, connection }) {
    if (!this._running) {
      return;
    }
    const controller = new import_timeout_abort_controller18.TimeoutController(this._incomingStreamTimeout);
    Promise.resolve().then(async () => {
      this._log("incoming new bitswap %s connection from %p", stream.stat.protocol, connection.remotePeer);
      await pipe(
        abortableSource(stream.source, controller.signal),
        decode62(),
        async (source) => {
          for await (const data of source) {
            try {
              const message6 = await BitswapMessage.deserialize(data.subarray(), this._hashLoader);
              await this._bitswap._receiveMessage(connection.remotePeer, message6);
            } catch (err2) {
              this._bitswap._receiveError(err2);
              break;
            }
            controller.reset();
          }
        }
      );
    }).catch((err2) => {
      this._log(err2);
      stream.abort(err2);
    }).finally(() => {
      controller.clear();
      stream.close();
    });
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  findProviders(cid, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, options);
  }
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    let found = 0;
    for await (const provider of this.findProviders(cid, options)) {
      this._log(`connecting to provider ${provider.id}`);
      connectAttempts.push(
        this.connectTo(provider.id, options).catch((err2) => {
          this._log.error(err2);
        })
      );
      found++;
      if (found === maxProvidersPerRequest) {
        break;
      }
    }
    await Promise.all(connectAttempts);
  }
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toString();
    this._log("sendMessage to %s", stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);
    await writeMessage(stream, msg, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toString();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
};
async function writeMessage(stream, msg, log108) {
  try {
    let serialized;
    switch (stream.stat.protocol) {
      case BITSWAP100:
        serialized = msg.serializeToBitswap100();
        break;
      case BITSWAP110:
      case BITSWAP120:
        serialized = msg.serializeToBitswap110();
        break;
      default:
        throw new Error("Unknown protocol: " + stream.stat.protocol);
    }
    await pipe(
      [serialized],
      encode52(),
      stream
    );
  } catch (err2) {
    log108(err2);
  } finally {
    stream.close();
  }
}

// node_modules/ipfs-bitswap/src/decision-engine/ledger.js
var Ledger = class {
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.sentToPeer = /* @__PURE__ */ new Map();
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesRecv += n;
  }
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
};

// node_modules/ipfs-bitswap/src/utils/sorted-map.js
var SortedMap = class extends Map {
  constructor(entries, cmp) {
    super();
    this._cmp = cmp || this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries || []) {
      this.set(k, v);
    }
  }
  update(i2) {
    if (i2 < 0 || i2 >= this._keys.length) {
      return;
    }
    const k = this._keys[i2];
    this._keys.splice(i2, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  set(k, v) {
    if (this.has(k)) {
      const i3 = this.indexOf(k);
      this._keys.splice(i3, 1);
    }
    super.set(k, v);
    const i2 = this._find(k);
    this._keys.splice(i2, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i2 = this.indexOf(k);
    this._keys.splice(i2, 1);
    return super.delete(k);
  }
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i2 = this._find(k);
    if (this._keys[i2] === k) {
      return i2;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i2 + j] === k)
        return i2 + j;
      if (this._keys[i2 - j] === k)
        return i2 - j;
    }
    return -1;
  }
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  *entries() {
    for (const k of this._keys) {
      yield [k, this.get(k)];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  forEach(cb, thisArg) {
    if (!cb) {
      return;
    }
    for (const k of this._keys) {
      cb.apply(thisArg, [[k, this.get(k)]]);
    }
  }
  _defaultSort(a, b) {
    if (a[0] < b[0])
      return -1;
    if (b[0] < a[0])
      return 1;
    return 0;
  }
  _kCmp(a, b) {
    return this._cmp(
      [a, this.get(a)],
      [b, this.get(b)]
    );
  }
};

// node_modules/ipfs-bitswap/src/decision-engine/req-queue.js
var DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
var RequestQueue = class {
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toString(), peerTasks);
  }
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return { tasks: [], pendingSize: 0 };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return { tasks, pendingSize };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toString());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toString());
    peerTasks && peerTasks.remove(topic);
  }
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      return;
    }
    const i2 = this._byPeer.indexOf(peerId.toString());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i2);
  }
};
var PeerTasks = class {
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  popTasks(targetMinBytes) {
    let size = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i2 = 0; i2 < pendingTasks.length && size < targetMinBytes; i2++) {
      const task = pendingTasks[i2];
      tasks.push(task);
      size += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  remove(topic) {
    this._pending.delete(topic);
  }
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  static compare(a, b) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
      return b[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b[1]._activeTotalSize;
  }
};
var PendingTasks = class {
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  get(topic) {
    return (this._tasks.get(topic) || {}).task;
  }
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  delete(topic) {
    this._tasks.delete(topic);
  }
  tasks() {
    return [...this._tasks.values()].map((i2) => i2.task);
  }
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (!obj) {
      return;
    }
    const i2 = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i2);
  }
  _compare(a, b) {
    if (a[1].task.priority === b[1].task.priority) {
      return a[1].created - b[1].created;
    }
    return b[1].task.priority - a[1].task.priority;
  }
};

// node_modules/ipfs-bitswap/src/decision-engine/task-merger.js
var TaskMerger = {
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};

// node_modules/ipfs-bitswap/src/decision-engine/index.js
var WantType2 = BitswapMessage.WantType;
var TARGET_MESSAGE_SIZE = 16 * 1024;
var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DecisionEngine = class {
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger2(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "ledger-map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(TaskMerger);
  }
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks();
    });
  }
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID.parse(topic);
      const blk = blocks.get(topic);
      if (blk) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId && this.messageSent(peerId, CID.parse(cidStr), block);
      }
    } catch (err2) {
      this._log.error(err2);
    }
    peerId && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (!ledger) {
      return null;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  receivedBlocks(blocks) {
    if (!blocks.length) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const block of blocks) {
        const want = ledger.wantlistContains(block.cid);
        if (!want) {
          continue;
        }
        const blockSize = block.data.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc2),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc2), peerId);
    }
  }
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc2);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType2.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [k, v.length]));
  }
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc2), block);
      } catch (e) {
        if (e.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, e);
        }
      }
    }));
    return res;
  }
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toString());
  }
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
};

// node_modules/ipfs-bitswap/src/notifications.js
var import_events48 = __toESM(require_events(), 1);
var unwantEvent = (cid) => `unwant:${toString11(cid.multihash.bytes, "base64")}`;
var blockEvent = (cid) => `block:${toString11(cid.multihash.bytes, "base64")}`;
var Notifications = class extends import_events48.EventEmitter {
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger2(peerId, "notif");
  }
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  wantBlock(cid, options = {}) {
    if (!cid) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve7, reject) => {
      const onUnwant = () => {
        this.removeListener(blockEvt, onBlock);
        reject(new Error(`Block for ${cid} unwanted`));
      };
      const onBlock = (data) => {
        this.removeListener(unwantEvt, onUnwant);
        resolve7(data);
      };
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.removeListener(blockEvt, onBlock);
          this.removeListener(unwantEvt, onUnwant);
          reject(new Error(`Want for ${cid} aborted`));
        });
      }
    });
  }
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
};

// node_modules/ipfs-bitswap/src/stats/index.js
var import_events50 = __toESM(require_events(), 1);

// node_modules/ipfs-bitswap/src/stats/stat.js
var import_events49 = __toESM(require_events(), 1);
var import_moving_average2 = __toESM(require_moving_average(), 1);
var Stat = class extends import_events49.EventEmitter {
  constructor(initialCounters2, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters2.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = (0, import_moving_average2.default)(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._disabled = true;
  }
  stop() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  push(counter, inc) {
    if (this._enabled) {
      this._queue.push([counter, inc, Date.now()]);
      this._resetComputeTimeout();
    }
  }
  _resetComputeTimeout() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  _update() {
    this._timeout = null;
    if (this._queue.length) {
      let last14;
      while (this._queue.length) {
        const op = last14 = this._queue.shift();
        op && this._applyOp(op);
      }
      last14 && this._updateFrequency(last14[2]);
      this.emit("update", this._stats);
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval];
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average2.default)(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    });
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
};

// node_modules/ipfs-bitswap/src/stats/index.js
var defaultOptions19 = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ]
};
var Stats = class extends import_events50.EventEmitter {
  constructor(libp2p, initialCounters2 = [], _options = defaultOptions19) {
    super();
    const options = Object.assign({}, defaultOptions19, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters2;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters2, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "stats-peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  forPeer(peerId) {
    const peerIdStr = typeof peerId !== "string" && peerId.toString ? peerId.toString() : `${peerId}`;
    return this._peers.get(peerIdStr);
  }
  push(peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc);
      if (peer) {
        let peerStats = this._peers.get(peer);
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter, inc);
      }
    }
  }
  disconnected(peer) {
    const peerId = peer.toString();
    const peerStats = this._peers.get(peerId);
    if (peerStats) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
};

// node_modules/ipfs-bitswap/src/bitswap.js
var import_any_signal13 = __toESM(require_any_signal(), 1);
var defaultOptions20 = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
var statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
var Bitswap = class extends BaseBlockstore {
  constructor(libp2p, blockstore, options = {}) {
    super();
    this._libp2p = libp2p;
    this._log = logger2(this.peerId);
    this._options = Object.assign({}, defaultOptions20, options);
    this._stats = new Stats(libp2p, statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network2(libp2p, this, this._stats, {
      hashLoader: options.hashLoader,
      maxInboundStreams: options.maxInboundStreams,
      maxOutboundStreams: options.maxOutboundStreams,
      incomingStreamTimeout: options.incomingStreamTimeout
    });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  get peerId() {
    return this._libp2p.peerId;
  }
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err2) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(
      received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid)
    );
    await Promise.all(
      received.map(
        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)
      )
    );
  }
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toString(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  _updateReceiveCounters(peerIdStr, cid, data, exists2) {
    this._stats.push(peerIdStr, "blocksReceived", 1);
    this._stats.push(peerIdStr, "dataReceived", data.length);
    if (exists2) {
      this._stats.push(peerIdStr, "dupBlksReceived", 1);
      this._stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  _receiveError(err2) {
    this._log.error("ReceiveError: %s", err2.message);
  }
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this._stats.disconnected(peerId);
  }
  enableStats() {
    this._stats.enable();
  }
  disableStats() {
    this._stats.disable();
  }
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  async get(cid, options = {}) {
    const fetchFromNetwork = (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    };
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = async (cid2, options2) => {
      try {
        const block = await this.blockstore.get(cid2, options2);
        return block;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2, options2).catch((err3) => this._log.error(err3));
        }
        return fetchFromNetwork(cid2, options2);
      }
    };
    const controller = new AbortController();
    const signal = options.signal ? (0, import_any_signal13.anySignal)([options.signal, controller.signal]) : controller.signal;
    try {
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          signal
        })
      ]);
      return block;
    } finally {
      controller.abort();
    }
  }
  async *getMany(cids, options = {}) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
  }
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this._sendHaveBlockNotifications(cid, block);
  }
  async *putMany(source, options) {
    for await (const { key, value: value2 } of this.blockstore.putMany(source, options)) {
      this._sendHaveBlockNotifications(key, value2);
      yield { key, value: value2 };
    }
  }
  _sendHaveBlockNotifications(cid, data) {
    this.notifications.hasBlock(cid, data);
    this.engine.receivedBlocks([{ cid, data }]);
    this.network.provide(cid).catch((err2) => {
      this._log.error("Failed to provide: %s", err2.message);
    });
  }
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  peers() {
    return this.engine.peers();
  }
  stat() {
    return this._stats;
  }
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  async stop() {
    this._stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
  unwrap() {
    return this.blockstore;
  }
};

// node_modules/ipfs-bitswap/src/index.js
var createBitswap2 = (libp2p, blockstore, options = {}) => {
  return new Bitswap(libp2p, blockstore, options);
};

// node_modules/ipfs-core/src/components/network.js
var import_err_code135 = __toESM(require_err_code(), 1);

// node_modules/blockstore-core/src/errors.js
var errors_exports5 = {};
__export(errors_exports5, {
  abortedError: () => abortedError2,
  notFoundError: () => notFoundError2
});
var import_err_code134 = __toESM(require_err_code(), 1);
function notFoundError2(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code134.default)(err2, "ERR_NOT_FOUND");
}
function abortedError2(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code134.default)(err2, "ERR_ABORTED");
}

// node_modules/blockstore-core/node_modules/multiformats/vendor/base-x.js
function base21(ALPHABET, name22) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode81(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length23 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length23) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      pbegin++;
    }
    var it2 = size - length23;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length23 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length23) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length23 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length23;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode97(string14) {
    var buffer2 = decodeUnsafe(string14);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name22} character`);
  }
  return {
    encode: encode81,
    decodeUnsafe,
    decode: decode97
  };
}
var src17 = base21;
var _brrp__multiformats_scope_baseX17 = src17;
var base_x_default17 = _brrp__multiformats_scope_baseX17;

// node_modules/blockstore-core/node_modules/multiformats/src/bytes.js
var empty19 = new Uint8Array(0);
var equals39 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce18 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/blockstore-core/node_modules/multiformats/src/bases/base.js
var Encoder19 = class {
  constructor(name22, prefix, baseEncode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder19 = class {
  constructor(name22, prefix, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or18(this, decoder);
  }
};
var ComposedDecoder17 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or18(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or18 = (left, right) => new ComposedDecoder17({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec17 = class {
  constructor(name22, prefix, baseEncode, baseDecode) {
    this.name = name22;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder19(name22, prefix, baseEncode);
    this.decoder = new Decoder19(name22, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from32 = ({ name: name22, prefix, encode: encode81, decode: decode97 }) => new Codec17(name22, prefix, encode81, decode97);
var baseX17 = ({ prefix, name: name22, alphabet: alphabet16 }) => {
  const { encode: encode81, decode: decode97 } = base_x_default17(alphabet16, name22);
  return from32({
    prefix,
    name: name22,
    encode: encode81,
    decode: (text) => coerce18(decode97(text))
  });
};
var decode93 = (string14, alphabet16, bitsPerChar, name22) => {
  const codes6 = {};
  for (let i2 = 0; i2 < alphabet16.length; ++i2) {
    codes6[alphabet16[i2]] = i2;
  }
  let end = string14.length;
  while (string14[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes6[string14[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name22} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode79 = (data, alphabet16, bitsPerChar) => {
  const pad = alphabet16[alphabet16.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet16[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet16[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464817 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet16 }) => {
  return from32({
    prefix,
    name: name22,
    encode(input) {
      return encode79(input, alphabet16, bitsPerChar);
    },
    decode(input) {
      return decode93(input, alphabet16, bitsPerChar, name22);
    }
  });
};

// node_modules/blockstore-core/node_modules/multiformats/src/bases/base32.js
var base3217 = rfc464817({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper17 = rfc464817({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad17 = rfc464817({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper17 = rfc464817({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex17 = rfc464817({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper17 = rfc464817({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad17 = rfc464817({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper17 = rfc464817({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z17 = rfc464817({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/blockstore-core/node_modules/multiformats/vendor/varint.js
var encode_117 = encode80;
var MSB18 = 128;
var REST18 = 127;
var MSBALL17 = ~REST18;
var INT17 = Math.pow(2, 31);
function encode80(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT17) {
    out[offset++] = num & 255 | MSB18;
    num /= 128;
  }
  while (num & MSBALL17) {
    out[offset++] = num & 255 | MSB18;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode80.bytes = offset - oldOffset + 1;
  return out;
}
var decode94 = read18;
var MSB$117 = 128;
var REST$117 = 127;
function read18(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read18.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$117) << shift : (b & REST$117) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$117);
  read18.bytes = counter - offset;
  return res;
}
var N118 = Math.pow(2, 7);
var N218 = Math.pow(2, 14);
var N318 = Math.pow(2, 21);
var N418 = Math.pow(2, 28);
var N518 = Math.pow(2, 35);
var N618 = Math.pow(2, 42);
var N718 = Math.pow(2, 49);
var N818 = Math.pow(2, 56);
var N918 = Math.pow(2, 63);
var length22 = function(value2) {
  return value2 < N118 ? 1 : value2 < N218 ? 2 : value2 < N318 ? 3 : value2 < N418 ? 4 : value2 < N518 ? 5 : value2 < N618 ? 6 : value2 < N718 ? 7 : value2 < N818 ? 8 : value2 < N918 ? 9 : 10;
};
var varint26 = {
  encode: encode_117,
  decode: decode94,
  encodingLength: length22
};
var _brrp_varint17 = varint26;
var varint_default17 = _brrp_varint17;

// node_modules/blockstore-core/node_modules/multiformats/src/varint.js
var decode95 = (data, offset = 0) => {
  const code22 = varint_default17.decode(data, offset);
  return [code22, varint_default17.decode.bytes];
};
var encodeTo17 = (int, target, offset = 0) => {
  varint_default17.encode(int, target, offset);
  return target;
};
var encodingLength17 = (int) => {
  return varint_default17.encodingLength(int);
};

// node_modules/blockstore-core/node_modules/multiformats/src/hashes/digest.js
var create23 = (code22, digest15) => {
  const size = digest15.byteLength;
  const sizeOffset = encodingLength17(code22);
  const digestOffset = sizeOffset + encodingLength17(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo17(code22, bytes2, 0);
  encodeTo17(size, bytes2, sizeOffset);
  bytes2.set(digest15, digestOffset);
  return new Digest17(code22, size, digest15, bytes2);
};
var decode96 = (multihash) => {
  const bytes2 = coerce18(multihash);
  const [code22, sizeOffset] = decode95(bytes2);
  const [size, digestOffset] = decode95(bytes2.subarray(sizeOffset));
  const digest15 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest15.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest17(code22, size, digest15, bytes2);
};
var equals40 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals39(a.bytes, data.bytes);
  }
};
var Digest17 = class {
  constructor(code22, size, digest15, bytes2) {
    this.code = code22;
    this.size = size;
    this.digest = digest15;
    this.bytes = bytes2;
  }
};

// node_modules/blockstore-core/node_modules/multiformats/src/bases/base58.js
var base58btc17 = baseX17({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr17 = baseX17({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/blockstore-core/node_modules/multiformats/src/cid.js
var format15 = (link, base30) => {
  const { bytes: bytes2, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV016(
        bytes2,
        baseCache15(link),
        base30 || base58btc17.encoder
      );
    default:
      return toStringV116(
        bytes2,
        baseCache15(link),
        base30 || base3217.encoder
      );
  }
};
var cache18 = /* @__PURE__ */ new WeakMap();
var baseCache15 = (cid) => {
  const baseCache16 = cache18.get(cid);
  if (baseCache16 == null) {
    const baseCache17 = /* @__PURE__ */ new Map();
    cache18.set(cid, baseCache17);
    return baseCache17;
  }
  return baseCache16;
};
var CID16 = class {
  constructor(version4, code22, multihash, bytes2) {
    this.code = code22;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code22, multihash } = this;
        if (code22 !== DAG_PB_CODE16) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE16) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID16.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code22, digest: digest15 } = this.multihash;
        const multihash = create23(code22, digest15);
        return CID16.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID16.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals40(self2.multihash, unknown.multihash);
  }
  toString(base30) {
    return format15(this, base30);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID16) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version4, code: code22, multihash, bytes: bytes2 } = value2;
      return new CID16(
        version4,
        code22,
        multihash,
        bytes2 || encodeCID17(version4, code22, multihash.bytes)
      );
    } else if (value2[cidSymbol16] === true) {
      const { version: version4, multihash, code: code22 } = value2;
      const digest15 = decode96(multihash);
      return CID16.create(version4, code22, digest15);
    } else {
      return null;
    }
  }
  static create(version4, code22, digest15) {
    if (typeof code22 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest15.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code22 !== DAG_PB_CODE16) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE16}) block encoding`
          );
        } else {
          return new CID16(version4, code22, digest15, digest15.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID17(version4, code22, digest15.bytes);
        return new CID16(version4, code22, digest15, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest15) {
    return CID16.create(0, DAG_PB_CODE16, digest15);
  }
  static createV1(code22, digest15) {
    return CID16.create(1, code22, digest15);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID16.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID16.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce18(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest15 = new Digest17(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID16.createV0(digest15) : CID16.createV1(specs.codec, digest15);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length23] = decode95(initialBytes.subarray(offset));
      offset += length23;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE16;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  static parse(source, base30) {
    const [prefix, bytes2] = parseCIDtoBytes16(source, base30);
    const cid = CID16.decode(bytes2);
    baseCache15(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes16 = (source, base30) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base30 || base58btc17;
      return [
        base58btc17.prefix,
        decoder.decode(`${base58btc17.prefix}${source}`)
      ];
    }
    case base58btc17.prefix: {
      const decoder = base30 || base58btc17;
      return [base58btc17.prefix, decoder.decode(source)];
    }
    case base3217.prefix: {
      const decoder = base30 || base3217;
      return [base3217.prefix, decoder.decode(source)];
    }
    default: {
      if (base30 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source[0], base30.decode(source)];
    }
  }
};
var toStringV016 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  if (prefix !== base58btc17.prefix) {
    throw Error(`Cannot string encode V0 in ${base30.name} encoding`);
  }
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2).slice(1);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV116 = (bytes2, cache19, base30) => {
  const { prefix } = base30;
  const cid = cache19.get(prefix);
  if (cid == null) {
    const cid2 = base30.encode(bytes2);
    cache19.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE16 = 112;
var SHA_256_CODE16 = 18;
var encodeCID17 = (version4, code22, multihash) => {
  const codeOffset = encodingLength17(version4);
  const hashOffset = codeOffset + encodingLength17(code22);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo17(version4, bytes2, 0);
  encodeTo17(code22, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol16 = Symbol.for("@ipld/js-cid/CID");

// node_modules/blockstore-core/src/index.js
var Errors = {
  ...errors_exports5
};

// node_modules/ipfs-core/src/block-storage.js
var import_it_merge9 = __toESM(require_it_merge(), 1);
var import_it_filter13 = __toESM(require_it_filter(), 1);
var BlockStorage = class extends BaseBlockstore {
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  async *putMany(blocks, options = {}) {
    const missingBlocks = (0, import_it_filter13.default)(blocks, async ({ key }) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  async *getMany(cids, options = {}) {
    const getFromBitswap = pushable({ objectMode: true });
    const getFromChild = pushable({ objectMode: true });
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* (0, import_it_merge9.default)(
      this.bitswap.getMany(getFromBitswap, options),
      this.child.getMany(getFromChild, options)
    );
  }
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
};

// node_modules/ipfs-core/src/components/network.js
var Network3 = class {
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  static async start({ peerId, repo, print, hashers, options }) {
    if (repo.closed) {
      await repo.open();
    }
    const config2 = await repo.config.getAll();
    const libp2p = await createLibp2p2({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config2),
      config: config2,
      keychainConfig: void 0
    });
    await libp2p.start();
    for (const ma of libp2p.getMultiaddrs()) {
      print(`Swarm listening on ${ma.toString()}`);
    }
    const bitswap = createBitswap2(libp2p, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers,
      maxInboundStreams: 1024,
      maxOutboundStreams: 1024
    });
    await bitswap.start();
    const blockstore = new BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network3(peerId, libp2p, bitswap, repo, blockstore);
  }
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await network.bitswap.stop();
    await network.libp2p.stop();
  }
};
var readAddrs = (peerId, config2) => {
  const peerIdStr = peerId.toString();
  const addrs = [];
  const swarm = config2.Addresses && config2.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw (0, import_err_code135.default)(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${peerIdStr}`);
    }
    addrs.push(ma);
  }
  return addrs;
};
var WEBSOCKET_STAR_PROTO_CODE = 479;

// node_modules/ipfs-core/src/components/swarm/addrs.js
function createAddrs2({ network }) {
  async function addrs(options = {}) {
    const peers = [];
    const { libp2p } = await network.use(options);
    await libp2p.peerStore.forEach((peer) => {
      peers.push({
        id: peer.id,
        addrs: peer.addresses.map((mi) => mi.multiaddr)
      });
    });
    return peers;
  }
  return withTimeoutOption(addrs);
}

// node_modules/ipfs-core/src/components/swarm/connect.js
function createConnect2({ network }) {
  async function connect2(multiaddrOrPeerId, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.dial(multiaddrOrPeerId, options);
  }
  return withTimeoutOption(connect2);
}

// node_modules/ipfs-core/src/components/swarm/disconnect.js
function createDisconnect2({ network }) {
  async function disconnect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.hangUp(addr);
  }
  return withTimeoutOption(disconnect);
}

// node_modules/ipfs-core/src/components/swarm/local-addrs.js
function createLocalAddrs2({ network }) {
  async function localAddrs(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.getMultiaddrs();
  }
  return withTimeoutOption(localAddrs);
}

// node_modules/ipfs-core/src/components/swarm/peers.js
function createPeers3({ network }) {
  async function peers(options = {}) {
    const { libp2p } = await network.use(options);
    if (options.verbose) {
      const peers3 = [];
      for (const connection of libp2p.getConnections()) {
        const peer = {
          addr: connection.remoteAddr,
          peer: connection.remotePeer
        };
        if (options.verbose || options.direction) {
          peer.direction = connection.stat.direction;
        }
        if (options.verbose) {
          peer.muxer = connection.stat.multiplexer;
          peer.latency = "n/a";
          peer.streams = [];
        }
        peers3.push(peer);
      }
      return peers3;
    }
    const peers2 = /* @__PURE__ */ new Map();
    for (const connection of libp2p.getConnections()) {
      const peer = {
        addr: connection.remoteAddr,
        peer: connection.remotePeer
      };
      peers2.set(connection.remotePeer.toString(), peer);
    }
    return Array.from(peers2.values());
  }
  return withTimeoutOption(peers);
}

// node_modules/ipfs-core/src/components/swarm/index.js
var SwarmAPI = class {
  constructor({ network }) {
    this.addrs = createAddrs2({ network });
    this.connect = createConnect2({ network });
    this.disconnect = createDisconnect2({ network });
    this.localAddrs = createLocalAddrs2({ network });
    this.peers = createPeers3({ network });
  }
};

// node_modules/ipfs-core/src/components/ping.js
var basePacket = { success: true, time: 0, text: "" };
function createPing2({ network }) {
  async function* ping(peerId, options = {}) {
    const { libp2p } = await network.use();
    options.count = options.count || 10;
    const storedPeer = await libp2p.peerStore.get(peerId);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield { ...basePacket, text: `Looking up peer ${peerId}` };
      const remotePeer = await libp2p.peerRouting.findPeer(peerId);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error("Peer was not found");
    }
    yield { ...basePacket, text: `PING ${id.toString()}` };
    let packetCount = 0;
    let totalTime = 0;
    for (let i2 = 0; i2 < options.count; i2++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield { ...basePacket, time };
      } catch (err2) {
        yield { ...basePacket, success: false, text: err2.toString() };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield { ...basePacket, text: `Average latency: ${average}ms` };
    }
  }
  return withTimeoutOption(ping);
}

// node_modules/ipfs-core/src/components/dht.js
var import_err_code136 = __toESM(require_err_code(), 1);
init_concat();
var IPNS_PREFIX2 = "/ipns/";
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX2)) {
    str = str.substring(IPNS_PREFIX2.length);
  }
  let buf2;
  if (str[0] === "1" || str[0] === "Q") {
    str = `z${str}`;
  }
  if (str[0] === "z") {
    buf2 = base58btc2.decode(str);
  }
  if (str[0] === "k") {
    buf2 = base36.decode(str);
  }
  if (!buf2) {
    throw new Error("Could not parse string");
  }
  if (buf2[0] !== 1 && buf2[1] !== 114) {
    buf2 = concat4([
      [1, 114],
      buf2
    ]);
  }
  if (buf2.length !== 40) {
    throw new Error("Incorrect length " + buf2.length);
  }
  return concat4([
    fromString3(IPNS_PREFIX2),
    buf2.subarray(2)
  ]);
}
function createDht2({ network, repo, peerId }) {
  const { get: get3, put, findProvs, findPeer: findPeer2, provide, query } = {
    async *get(key, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.get(dhtKey, options);
    },
    async *put(key, value2, options) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.put(dhtKey, value2, options);
    },
    async *findProvs(cid, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findProviders(cid, {
        signal: options.signal
      });
    },
    async *findPeer(peerIdToFind, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findPeer(peerIdToFind, {
        signal: options.signal
      });
    },
    async *provide(cid, options = { recursive: false }) {
      const { libp2p } = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw (0, import_err_code136.default)(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
      }
      if (options.recursive) {
        throw (0, import_err_code136.default)(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.provide(cid);
    },
    async *query(peerIdToQuery, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      let bytes2;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes2 = asCid.multihash.bytes;
      } else {
        bytes2 = peerIdFromString(peerIdToQuery.toString()).toBytes();
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code136.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.getClosestPeers(bytes2, options);
    }
  };
  return {
    get: withTimeoutOption(get3),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer2),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
var use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (net.libp2p.dht != null) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: "QUERY_ERROR",
        type: 3,
        error: new NotEnabledError("dht not enabled")
      };
    };
    return {
      libp2p: {
        dht: {
          get: fn,
          put: fn,
          findProviders: fn,
          findPeer: fn,
          provide: fn,
          getClosestPeers: fn
        }
      }
    };
  }
};

// node_modules/ipfs-core/src/components/pubsub.js
var import_err_code137 = __toESM(require_err_code(), 1);
function createPubsub3({ network, config: config2 }) {
  const isEnabled = dlv_es_default(config2 || {}, "Pubsub.Enabled", true);
  const handlers = {};
  let onMessage;
  return {
    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,
    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
    peers: isEnabled ? withTimeoutOption(peers) : notEnabled
  };
  async function subscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    libp2p.pubsub.subscribe(topic);
    if (onMessage == null) {
      onMessage = (evt) => {
        const msg = evt.detail;
        if (handlers[msg.topic]) {
          handlers[msg.topic].forEach((handler2) => {
            if (typeof handler2 === "function") {
              handler2(msg);
              return;
            }
            if (handler2 != null && handler2.handleEvent != null) {
              handler2.handleEvent(msg);
            }
          });
        }
      };
      libp2p.pubsub.addEventListener("message", onMessage);
    }
    if (handler != null) {
      if (handlers[topic] == null) {
        handlers[topic] = [];
      }
      handlers[topic].push(handler);
    }
  }
  async function unsubscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    if (handler != null && handlers[topic] != null) {
      handlers[topic] = handlers[topic].filter((h) => h !== handler);
      if (handlers[topic].length === 0) {
        delete handlers[topic];
      }
    }
    if (typeof handler !== "function") {
      delete handlers[topic];
    }
    if (handlers[topic] == null) {
      libp2p.pubsub.unsubscribe(topic);
    }
    if (Object.keys(handlers).length === 0) {
      libp2p.pubsub.removeEventListener("message", onMessage);
      onMessage = void 0;
    }
  }
  async function publish(topic, data, options = {}) {
    const { libp2p } = await network.use(options);
    if (!data) {
      throw (0, import_err_code137.default)(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
    }
    await libp2p.pubsub.publish(topic, data);
  }
  async function ls(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getTopics();
  }
  async function peers(topic, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getSubscribers(topic);
  }
}
var notEnabled = async () => {
  throw new NotEnabledError("pubsub not enabled");
};

// node_modules/ipfs-core/src/components/index.js
var mergeOptions16 = merge_options_default.bind({ ignoreUndefined: true });
var log107 = logger("ipfs");
var IPNS_INIT_KEYSPACE_TIMEOUT = 3e4;
var IPFS2 = class {
  constructor({ print, storage, codecs: codecs2, options }) {
    const { peerId, repo, keychain } = storage;
    const network = Service.create(Network3);
    const preload2 = createPreloader(options.preload);
    const dns = createDns();
    const isOnline = createIsOnline({ network });
    const ipns = new IPNSAPI(options);
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    this.hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(bases);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base30) => multibaseCodecs.push(base30));
    this.bases = new Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new PinAPI({ repo, codecs: codecs2 });
    const block = new BlockAPI({ codecs: codecs2, hashers: this.hashers, preload: preload2, repo });
    const name22 = new NameAPI({
      dns,
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain,
      options
    });
    const resolve7 = createResolve({ repo, codecs: codecs2, bases: this.bases, name: name22 });
    const dag = new DagAPI({ repo, codecs: codecs2, hashers: this.hashers, preload: preload2 });
    const refs = Object.assign(createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }), {
      local: createLocal({ repo: storage.repo })
    });
    const { add, addAll, cat, get: get3, ls } = new RootAPI({
      preload: preload2,
      repo,
      options: options.EXPERIMENTAL,
      hashers: this.hashers
    });
    const files = createFiles({
      repo,
      preload: preload2,
      hashers: this.hashers,
      options
    });
    const mfsPreload = createMfsPreloader({
      files,
      preload: preload2,
      options: options.preload
    });
    this.preload = preload2;
    this.name = name22;
    this.ipns = ipns;
    this.pin = pin;
    this.resolve = resolve7;
    this.block = block;
    this.refs = refs;
    this.start = createStart({
      network,
      peerId,
      repo,
      preload: preload2,
      ipns,
      mfsPreload,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = createStop({
      network,
      preload: preload2,
      mfsPreload,
      ipns,
      repo
    });
    this.dht = createDht2({ network, repo, peerId });
    this.pubsub = createPubsub3({ network, config: options.config });
    this.dns = dns;
    this.isOnline = isOnline;
    this.id = createId({ network, peerId });
    this.version = createVersion({ repo });
    this.bitswap = new BitswapAPI({ network });
    this.bootstrap = new BootstrapAPI({ repo });
    this.config = createConfig({ repo });
    this.ping = createPing2({ network });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get3;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new KeyAPI({ keychain });
    this.object = new ObjectAPI({ preload: preload2, codecs: codecs2, repo });
    this.repo = new RepoAPI({ repo, hashers: this.hashers });
    this.stats = new StatsAPI({ repo, network });
    this.swarm = new SwarmAPI({ network });
    Object.defineProperty(this, "libp2p", {
      get() {
        const net = network.try();
        return net ? net.libp2p : void 0;
      }
    });
    const notImplemented = () => Promise.reject((0, import_err_code138.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
    const notImplementedIter = async function* () {
      throw (0, import_err_code138.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs2;
  }
  async init() {
    throw new AlreadyInitializedError();
  }
};
var addEmptyDir2 = async (ipfs2) => {
  const buf2 = encode4({
    Data: new UnixFS({ type: "directory" }).marshal(),
    Links: []
  });
  const cid = await ipfs2.block.put(buf2, {
    mhtype: "sha2-256",
    format: "dag-pb"
  });
  await ipfs2.pin.add(cid);
  return cid;
};
var getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !import_env2.isTest,
    addresses: [
      "/dns4/node0.preload.ipfs.io/https",
      "/dns4/node1.preload.ipfs.io/https",
      "/dns4/node2.preload.ipfs.io/https",
      "/dns4/node3.preload.ipfs.io/https"
    ]
  }
});
async function create24(options = {}) {
  options = mergeOptions16(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [src_exports, esm_exports, esm_exports2, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log107 : console.log;
  log107("creating repo");
  const storage = await Storage.start(print, multicodecs, options);
  log107("getting repo config");
  const config2 = await storage.repo.config.getAll();
  const ipfs2 = new IPFS2({
    storage,
    print,
    codecs: multicodecs,
    options: { ...options, config: config2 }
  });
  log107("starting preload");
  await ipfs2.preload.start();
  log107("starting storage");
  ipfs2.ipns.startOffline(storage);
  if (storage.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir2(ipfs2);
    log107("adding default assets");
    await initAssets({ addAll: ipfs2.addAll, print });
    log107("initializing IPNS keyspace");
    if (storage.peerId.publicKey == null) {
      throw (0, import_err_code138.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const timeoutController = new import_timeout_abort_controller19.TimeoutController(IPNS_INIT_KEYSPACE_TIMEOUT);
    try {
      await ipfs2.ipns.initializeKeyspace(storage.peerId, fromString3(`/ipfs/${cid}`), {
        signal: timeoutController.signal
      });
    } finally {
      timeoutController.clear();
    }
  }
  if (options.start !== false) {
    log107("starting node");
    await ipfs2.start();
  }
  return ipfs2;
}

// node_modules/ipfs-core/src/index.js
var import_glob_source2 = __toESM(require_glob_source());
var import_url_source2 = __toESM(require_url_source());
var create25 = create24;
var globSource = import_glob_source2.default;
var urlSource = import_url_source2.default;
export {
  create25 as create,
  globSource,
  urlSource
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=ipfs-core.js.map
